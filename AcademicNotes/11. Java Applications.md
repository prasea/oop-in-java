
# Unit 11: Java Applications (8 Hrs)

## AWT & Swing Programming

*(BCA – Tribhuvan University | Examination Notes)*


## 1. Introduction to AWT and Swing

### 1.1 AWT (Abstract Window Toolkit)

**AWT** is Java’s **first GUI toolkit** used to develop window-based applications.

### Key Characteristics of AWT

* Heavyweight components
* Platform dependent
* Uses native OS components
* Faster but limited flexibility

### Example AWT Components

* Button
* Label
* TextField
* Frame


### 1.2 Swing

**Swing** is an **advanced GUI toolkit** built on top of AWT.

### Key Characteristics of Swing

* Lightweight components
* Platform independent
* Written entirely in Java
* Supports **MVC architecture**
* Rich set of components

### Swing Package

```java
javax.swing.*
```


## 2. JFrame (Top-Level Container)

### Definition

**JFrame** is a **top-level window** in Swing used to contain other components.

### Characteristics

* Has title bar
* Can be resized
* Supports menus

### Example

```java
import javax.swing.*;

public class MyFrame {
  public static void main(String[] args) {
    JFrame f = new JFrame("My First Frame");
    f.setSize(300, 200);
    f.setVisible(true);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  }
}
```


## 3. Swing Components

### 3.1 JLabel

**JLabel** is used to display **text or image**.

```java
JLabel lbl = new JLabel("Welcome to Swing");
```

### 3.2 JTextField

**JTextField** is used to take **single-line text input**.

```java
JTextField txt = new JTextField(15);
```


### 3.3 JButton

**JButton** is a **clickable button**.

```java
JButton btn = new JButton("Submit");
```

A simple app that creates components and attaches it to frame. 
```java 
class SimpleFrame extends JFrame {
  JLabel lbl;
  JTextField tf;
  JButton btn; 
  
  public SimpleFrame() {
    lbl = new JLabel("Enter your name");
    tf = new JTextField(30);
    btn = new JButton("Submit");
    
    this.setLayout(null);
    
    lbl.setBounds(0, 100, 100, 20);
    tf.setBounds(0, 130, 100, 20);
    btn.setBounds(0,150, 100, 20);
    
    this.add(lbl);
    this.add(tf);
    this.add(btn);
  }
} 
public class SimpleSwing {
  public static void main(String[] args) {
    SimpleFrame sf = new SimpleFrame();        
    sf.setVisible(true);
    sf.setSize(500, 500);
    sf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        
  }    
}
```

## 4. Event Handling in Swing
Event Handling is the mechanism that controls the event and decides what should happen if an event occurs. This mechanism has a code which is known as an event handler, that is executed when an event occurs.

Java uses the **Event Delegation Model** to handle the events. This model defines the standard mechanism to generate and handle the events. 
The **Event Delegation Model** is a mechanism where a **component generates an event**, the event is **delegated** to a **listener** and the listener **handles** the event


The Delegation Event Model has the following key participants.
**Source** − The source is an object on which the event occurs. Source is responsible for providing information of the occurred event to it's handler. Java provide us with classes for the source object.

**Listener** − It is also known as event handler. The listener is responsible for generating a response to an event. From the point of view of Java implementation, the listener is also an object. The listener waits till it receives an event. Once the event is received, the listener processes the event and then returns.

The benefit of this approach is that the user interface logic is completely separated from the logic that generates the event. The user interface element is able to delegate the processing of an event to a separate piece of code.

In this model, the listener needs to be registered with the source object so that the listener can receive the event notification. This is an efficient way of handling the event because the event notifications are sent only to those listeners who want to receive them.

### Steps Involved in Event Handling
- Step 1 − The user clicks the button and the event is generated.

- Step 2 − The object of concerned event class is created automatically and information about the source and the event get populated within the same object.

- Step 3 − Event object is forwarded to the method of the registered listener class.

- Step 4 − The method is gets executed and returns.

### Common Events

| Event           | Trigger                 | Listener           |
|  | -- |  |
| ActionEvent     | Button click, ENTER key | ActionListener     |
| MouseEvent      | Mouse click/move        | MouseListener      |
| KeyEvent        | Key press/release       | KeyListener        |
| ItemEvent       | Checkbox/List selection | ItemListener       |
| TextEvent       | Text change             | TextListener       |
| MouseWheelEvent | Scroll wheel            | MouseWheelListener |
| WindowEvent     | Open/close window       | WindowListener     |
| ComponentEvent  | Resize/show/hide        | ComponentListener  |
| ContainerEvent  | Add/remove component    | ContainerListener  |

```java 
import javax.swing.*;
import java.awt.event.*;

class SimpleFrame extends JFrame implements ActionListener, KeyListener {
  JLabel lbl;
  JTextField tf;
  JButton btn;
  
  public SimpleFrame() {
    lbl = new JLabel("Enter your name:");
    tf = new JTextField(30);
    btn = new JButton("Submit");
    
    // Setting layout and component bounds
    this.setLayout(null);
    lbl.setBounds(50, 100, 150, 20);
    tf.setBounds(200, 100, 150, 20);
    btn.setBounds(200, 150, 100, 30);
    
    // Adding components to the frame
    this.add(lbl);
    this.add(tf);
    this.add(btn);
    
    // Add ActionListener for button click
    btn.addActionListener(this);
    
    // Add KeyListener for the text field
    tf.addKeyListener(this);
  }

  // Overriding the actionPerformed method for button click event
  @Override
  public void actionPerformed(ActionEvent e) {
    // When the button is clicked
    String name = tf.getText(); // Get the text from the text field
    JOptionPane.showMessageDialog(this, "Hello, " + name + "!");
  }

  // Overriding the keyTyped, keyPressed, and keyReleased methods for key events
  @Override
  public void keyTyped(KeyEvent e) {
    // Not used in this case, but required to implement the KeyListener
  }

  @Override
  public void keyPressed(KeyEvent e) {
    // Not used in this case, but required to implement the KeyListener
  }

  @Override
  public void keyReleased(KeyEvent e) {
    // Detect ENTER key press
    if (e.getKeyCode() == KeyEvent.VK_ENTER) {
        String name = tf.getText();
        JOptionPane.showMessageDialog(this, "You entered: " + name);
    }
  }
}

public class SimpleSwing {
  public static void main(String[] args) {
      SimpleFrame sf = new SimpleFrame();
      sf.setVisible(true);
      sf.setSize(500, 500);
      sf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  }
}
```

## 5. Layout Management

A **layout manager** controls the **position and size** of components in a container.


### 5.1 FlowLayout

The FlowLayout in Swing is a simple layout manager that arranges components in a directional flow, similar to how words are arranged in a paragraph. Components are placed in a row from left to right, using their preferred sizes. If the horizontal space is insufficient, the layout manager automatically wraps components to the next line. 

```java
setLayout(new FlowLayout());
```


### 5.2 BorderLayout

The BorderLayout in Java Swing is a layout manager that arranges components into five regions: NORTH, SOUTH, EAST, WEST, and CENTER. Each region can contain at most one component. The CENTER component receives any extra space and stretches both horizontally and vertically, while the NORTH and SOUTH components stretch horizontally, and EAST and WEST stretch vertically. 

**By default, the content pane of a JFrame, JWindow, and JDialog uses BorderLayout.**

```java
setLayout(new BorderLayout());
add(btn, BorderLayout.NORTH);
```


### 5.3 GridLayout

The GridLayout in Swing is a layout manager that arranges components in a rectangular grid of equal-sized cells, with one component placed in each cell. All components are resized to fill their assigned cell, and all cells in the grid have the same width and height. 
It arranges components in **rows and columns**.

```java
setLayout(new GridLayout(2,2));
```


## 6. JPanel

**JPanel** is a **container used to group components**.

### Importance

* Helps organize GUI
* Supports nested layouts

```java
public class JPanelDemo extends JFrame {
  public static void main(String[] args) {
    JFrame frame = new JFrame("Jpanel Demo"); 
    frame.setSize(300, 200);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    JPanel panel = new JPanel();
    panel.setLayout(new FlowLayout());
    
    JButton button = new JButton("Click Me!");
    panel.add(button);

    frame.add(panel);
    frame.setVisible(true);
  }
}
```


## 7. Choice Components


### 7.1 JCheckBox

Allows **multiple selections**.

```java
JCheckBox cb = new JCheckBox("Java");
```


### 7.2 JRadioButton

Allows **single selection** (used with ButtonGroup).

```java
JRadioButton r1 = new JRadioButton("Male");
JRadioButton r2 = new JRadioButton("Female");
ButtonGroup bg = new ButtonGroup();
bg.add(r1);
bg.add(r2);
```

An example app using both JCheckBox and JRadioButton, 


```java 
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;


class MyFrame extends JFrame implements ActionListener
{
  JCheckBox c1,c2;
  JRadioButton r1,r2;

  JTextField tf;

  MyFrame()
  {
    super("Demo");
    
    tf=new JTextField("Demo Text",20);
    tf.setBounds(10,20,100,80);
    
    c1=new JCheckBox("Bold");
    c1.setMnemonic(KeyEvent.VK_B);
    
    c2=new JCheckBox("Italic");
    c2.setMnemonic(KeyEvent.VK_I);
    
    r1=new JRadioButton("lower");
    r2=new JRadioButton("UPPER");
    //Only one radio button can be selected
    ButtonGroup bg=new ButtonGroup(); 
    bg.add(r1);
    bg.add(r2);
    
    c1.addActionListener(this);
    c2.addActionListener(this);
    r1.addActionListener(this);
    r2.addActionListener(this);
    
    r1.setActionCommand("lower");
    r2.setActionCommand("UPPER");
    
    setLayout(new FlowLayout());
    
    add(tf);
    add(c1);
    add(c2);
    add(r1);
    add(r2);          
  }
    
  public void actionPerformed(ActionEvent ae)
  {
    switch(ae.getActionCommand())
    {
      case "lower": 
        tf.setText(tf.getText().toLowerCase());
        break;
      case "UPPER": 
        tf.setText(tf.getText().toUpperCase());
        break;
    }
    int b=0,i=0;
    
    if(c1.isSelected())
      b=Font.BOLD;
    if(c2.isSelected())
      i=Font.ITALIC;
    
    // Font f=new Font("Times New Roman",Font.BOLD|Font.Italic,15);
    Font f=new Font("Times New Roman",b|i,15);
    tf.setFont(f);      
  }    
}

public class SwingItemDemo 
{
  public static void main(String[] args) 
  {
    MyFrame f=new MyFrame();
    f.setSize(500,500);
    f.setVisible(true);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  }    
}
```

## 8. Borders in Swing

In **Swing**, borders are used to:
* Group related components together
* Visually separate sections of a form
* Improve the **look and organization** of GUI applications

To use border, `import javax.swing.border.*;`
### Example

```java
panel.setBorder(BorderFactory.createTitledBorder("Details"));
```

```java 
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;

class MyFrame extends JFrame 
{
  JLabel l;
  JTextField tf;
  JButton b;
  
  JPanel p;
  
  MyFrame()
  {
    l=new JLabel("Name");
    tf=new JTextField(20);
    b=new JButton("OK");
    p=new JPanel();
    
    p.add(l);
    p.add(tf);
    p.add(b);
    
    Border br = BorderFactory.createLoweredBevelBorder();
    p.setBorder(br);
    // p.setBorder(BorderFactory.createTitledBorder("Details"));
    
    setLayout(new FlowLayout());
    add(p);
  }
  
}
public class SwingBorders 
{
  
  public static void main(String[] args) 
  {
    MyFrame f=new MyFrame();
    f.setSize(800,800);
    f.setVisible(true);
    
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  }
}
```


## 9. JComboBox and Its Events

**JComboBox** provides a **drop-down list** but shows one item at a time. 

```java
String[] countries = {"India", "USA", "UK", "Nepal"};
JComboBox<String> cb = new JComboBox<>(countries);
```

### **Event Handling**

- Step 1: Implement Listener `ActionListener`

- Step 2: Override Callback Methods
```java
@Override
public void actionPerformed(ActionEvent e) {
    textField.setText((String) cb.getSelectedItem());
}
```

- Step 3: Register Listeners
```java
cb.addActionListener(this); // 'this' implements ActionListener
```

## 10. JList and MVC Pattern

**JList** displays a **list of items**. It Shows **multiple items at a time**
* Supports **single or multiple selection** (`Ctrl` or `Command` key)
* Usually **scrollable**, added inside `JScrollPane`

```java
String[] months = {"January", "February", "March", "April", "May"};
JList<String> list = new JList<>(months);
list.setVisibleRowCount(5);  // show 5 items at a time
JScrollPane scrollPane = new JScrollPane(list);
```


### Event Handling of JList

- Step 1: Implements `ListSelectionListener`

- Step 2: Override Callback Methods
```java
@Override
public void valueChanged(ListSelectionEvent e) {
    textField.setText((String) list.getSelectedValue());
}
```

- Step 3: Register Listeners
```java
list.addListSelectionListener(this);
```


### MVC Concept

##### **Model** 
* The array `months` is converted internally into a **ListModel**
* JList uses a **DefaultListModel** or internal model to store items
* The **model contains the actual data**.

You can also create the model explicitly:

```java
DefaultListModel<String> model = new DefaultListModel<>();
model.addElement("January");
model.addElement("February");

JList<String> list = new JList<>(model);
```

####  **View** → JList
The **View** is the visual representation. The **view only displays data from the model**.

```java
JList<String> list = new JList<>(months);
JScrollPane scrollPane = new JScrollPane(list);
```

* JList displays the data.
* JScrollPane allows scrolling.
* `setVisibleRowCount(5)` controls how many rows are visible.

#### **Controller** → Event listeners

The **Controller** handles user interaction.

```java
list.addListSelectionListener(this)
@Override
public void valueChanged(ListSelectionEvent e) {
  String selected = list.getSelectedValue();
  System.out.println("Selected: " + selected);
}
```

## 11. Key and Mouse Event Handling


### 11.1 Key Events

Handled using `KeyListener`.

```java
txt.addKeyListener(new KeyAdapter() {
  public void keyPressed(KeyEvent e) {
    System.out.println(e.getKeyChar());
  }
});
```


### 11.2 Mouse Events

Handled using `MouseListener`.

```java
btn.addMouseListener(new MouseAdapter() {
  public void mouseClicked(MouseEvent e) {
    System.out.println("Mouse Clicked");
  }
});
```


## 12. Menus in Swing

### Components

* JMenuBar
* JMenu
* JMenuItem

### Example

```java
JMenuBar mb = new JMenuBar();      // menu bar
JMenu fileMenu = new JMenu("File"); // menu

JMenuItem saveItem = new JMenuItem("Save");
JMenuItem openItem = new JMenuItem("Open");
openItem.setMnemonic(KeyEvent.VK_O); // shortcut: Alt+O

fileMenu.add(saveItem);
fileMenu.addSeparator();  // adds a line separator
fileMenu.add(openItem);

mb.add(fileMenu);
setJMenuBar(mb);           // add menu bar to frame
```



## 13. JTextArea

**JTextArea** allows **multi-line text input**.
* Use `JTextArea` as the main text component
* Wrap it inside `JScrollPane` to make it scrollable

```java
// JTextArea ta = new JTextArea(5,20);
JTextArea ta = new JTextArea();
JScrollPane sp = new JScrollPane(ta);
add(sp, BorderLayout.CENTER);
```


## 14. Dialog Boxes in Swing

### Types

* Message Dialog
* Confirm Dialog
* Input Dialog


```java 
package unit10;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class MyFrame implements ActionListener {

  JFrame frame;
  JButton messageBtn, confirmBtn, inputBtn;

  public MyFrame() {

    frame = new JFrame("Swing Dialog Example");
    frame.setSize(400, 200);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.setLayout(null);

    messageBtn = new JButton("Message Dialog");
    messageBtn.setBounds(30, 30, 150, 30);

    confirmBtn = new JButton("Confirm Dialog");
    confirmBtn.setBounds(200, 30, 150, 30);

    inputBtn = new JButton("Input Dialog");
    inputBtn.setBounds(115, 80, 150, 30);

    // Register listener
    messageBtn.addActionListener(this);
    confirmBtn.addActionListener(this);
    inputBtn.addActionListener(this);

    frame.add(messageBtn);
    frame.add(confirmBtn);
    frame.add(inputBtn);

    frame.setLocationRelativeTo(null);
    frame.setVisible(true);
  }

  @Override
  public void actionPerformed(ActionEvent e) {

    if (e.getSource() == messageBtn) {
        JOptionPane.showMessageDialog(
          frame,
          "Hello! This is a message dialog."
        );
    }

    else if (e.getSource() == confirmBtn) {
        int choice = JOptionPane.showConfirmDialog(
          frame,
          "Do you want to continue?",
          "Confirm",
          JOptionPane.YES_NO_OPTION
        );

        JOptionPane.showMessageDialog(
          frame,
          choice == JOptionPane.YES_OPTION ? "You chose YES" : "You chose NO"
        );
    }

    else if (e.getSource() == inputBtn) {
      String name = JOptionPane.showInputDialog(
          frame,
          "Enter your name:"
      );

      if (name != null && !name.trim().isEmpty()) {
        JOptionPane.showMessageDialog(frame, "Hello, " + name + "!");
      }
    }
  }

  public static void main(String[] args) {
    new MyFrame();
  }
}
```

## 15. JTable (Tabular Data Display)

**JTable** is used to display data in **row and column format**.

```java 
import javax.swing.*;

class TableFrame extends JFrame {

  JTable table;

  public TableFrame() {
    String[] columnNames = {"ID", "Name", "Course"};

    String[][] data = {
      {"101", "Rahul", "Java"},
      {"102", "Anita", "Python"},
      {"103", "Amit", "C++"},
      {"104", "Neha", "JavaScript"}
    };

    table = new JTable(data, columnNames);

    // Add table inside JScrollPane
    JScrollPane sp = new JScrollPane(table);

    // Add scroll pane to frame
    this.add(sp);

    // Frame settings
    this.setTitle("Simple JTable Example");
    this.setSize(400, 300);
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    this.setVisible(true);
  }
}

public class SimpleTableDemo {
  public static void main(String[] args) {
    new TableFrame();
  }
}
```


## 16. MDI (Multiple Document Interface)


### JDesktopPane

Acts as a **container for internal frames**.

### JInternalFrame

Acts as **child windows**.

```java
JDesktopPane dp = new JDesktopPane();
JInternalFrame f = new JInternalFrame("Doc", true, true);
dp.add(f);
```


## 17. Using IDEs (NetBeans, JBuilder)

### Advantages

* Drag and Drop UI design
* Automatic code generation
* Faster development
* Error highlighting

### NetBeans

* Most popular for Swing
* GUI Builder (Matisse)


## 18. Adapter Classes

**Adapter classes** provide **empty implementations** of listener interfaces.

### Common Adapter Classes

* KeyAdapter
* MouseAdapter
* WindowAdapter

### Advantage

* No need to implement all methods

```java
addWindowListener(new WindowAdapter() {
  public void windowClosing(WindowEvent e) {
    System.exit(0);
  }
});
```
