
# Unit 11: Java Applications (8 Hrs)

## AWT & Swing Programming

*(BCA – Tribhuvan University | Examination Notes)*


## 1. Introduction to AWT and Swing

### 1.1 AWT (Abstract Window Toolkit)

**AWT** is Java’s **first GUI toolkit** used to develop window-based applications.

### Key Characteristics of AWT

* Heavyweight components
* Platform dependent
* Uses native OS components
* Faster but limited flexibility

### Example AWT Components

* Button
* Label
* TextField
* Frame


### 1.2 Swing

**Swing** is an **advanced GUI toolkit** built on top of AWT.

### Key Characteristics of Swing

* Lightweight components
* Platform independent
* Written entirely in Java
* Supports **MVC architecture**
* Rich set of components

### Swing Package

```java
javax.swing.*
```


## 2. JFrame (Top-Level Container)

### Definition

**JFrame** is a **top-level window** in Swing used to contain other components.

### Characteristics

* Has title bar
* Can be resized
* Supports menus

### Example

```java
import javax.swing.*;

public class MyFrame {
  public static void main(String[] args) {
    JFrame f = new JFrame("My First Frame");
    f.setSize(300, 200);
    f.setVisible(true);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  }
}
```


## 3. Swing Components

### 3.1 JLabel

**JLabel** is used to display **text or image**.

```java
JLabel lbl = new JLabel("Welcome to Swing");
```

### 3.2 JTextField

**JTextField** is used to take **single-line text input**.

```java
JTextField txt = new JTextField(15);
```


### 3.3 JButton

**JButton** is a **clickable button**.

```java
JButton btn = new JButton("Submit");
```

A simple app that creates components and attaches it to frame. 
```java 
class SimpleFrame extends JFrame {
  JLabel lbl;
  JTextField tf;
  JButton btn; 
  
  public SimpleFrame() {
    lbl = new JLabel("Enter your name");
    tf = new JTextField(30);
    btn = new JButton("Submit");
    
    this.setLayout(null);
    
    lbl.setBounds(0, 100, 100, 20);
    tf.setBounds(0, 130, 100, 20);
    btn.setBounds(0,150, 100, 20);
    
    this.add(lbl);
    this.add(tf);
    this.add(btn);
  }
} 
public class SimpleSwing {
  public static void main(String[] args) {
    SimpleFrame sf = new SimpleFrame();        
    sf.setVisible(true);
    sf.setSize(500, 500);
    sf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        
  }    
}
```

## 4. Event Handling in Swing
Event Handling is the mechanism that controls the event and decides what should happen if an event occurs. This mechanism has a code which is known as an event handler, that is executed when an event occurs.

Java uses the **Event Delegation Model** to handle the events. This model defines the standard mechanism to generate and handle the events. 
The **Event Delegation Model** is a mechanism where a **component generates an event**, the event is **delegated** to a **listener** and the listener **handles** the event


The Delegation Event Model has the following key participants.
**Source** − The source is an object on which the event occurs. Source is responsible for providing information of the occurred event to it's handler. Java provide us with classes for the source object.

**Listener** − It is also known as event handler. The listener is responsible for generating a response to an event. From the point of view of Java implementation, the listener is also an object. The listener waits till it receives an event. Once the event is received, the listener processes the event and then returns.

The benefit of this approach is that the user interface logic is completely separated from the logic that generates the event. The user interface element is able to delegate the processing of an event to a separate piece of code.

In this model, the listener needs to be registered with the source object so that the listener can receive the event notification. This is an efficient way of handling the event because the event notifications are sent only to those listeners who want to receive them.

### Steps Involved in Event Handling
- Step 1 − The user clicks the button and the event is generated.

- Step 2 − The object of concerned event class is created automatically and information about the source and the event get populated within the same object.

- Step 3 − Event object is forwarded to the method of the registered listener class.

- Step 4 − The method is gets executed and returns.

### Common Events

| Event           | Trigger                 | Listener           |
|-----------------|-------------------------|--------------------|
| ActionEvent     | Button click, ENTER key | ActionListener     |
| MouseEvent      | Mouse click/move        | MouseListener      |
| KeyEvent        | Key press/release       | KeyListener        |
| ItemEvent       | Checkbox/List selection | ItemListener       |
| TextEvent       | Text change             | TextListener       |
| MouseWheelEvent | Scroll wheel            | MouseWheelListener |
| WindowEvent     | Open/close window       | WindowListener     |
| ComponentEvent  | Resize/show/hide        | ComponentListener  |
| ContainerEvent  | Add/remove component    | ContainerListener  |

```java 
import javax.swing.*;
import java.awt.event.*;

class SimpleFrame extends JFrame implements ActionListener {
  JLabel lbl;
  JTextField tf;
  JButton btn;
  
  public SimpleFrame() {
    lbl = new JLabel("Enter your name:");
    tf = new JTextField(30);
    btn = new JButton("Submit");
    
    // Setting layout and component bounds
    this.setLayout(null);
    lbl.setBounds(50, 100, 150, 20);
    tf.setBounds(200, 100, 150, 20);
    btn.setBounds(200, 150, 100, 30);
    
    // Adding components to the frame
    this.add(lbl);
    this.add(tf);
    this.add(btn);
    
    // Add ActionListener for button click
    btn.addActionListener(this);

  }

  // Overriding the actionPerformed method for button click event
  @Override
  public void actionPerformed(ActionEvent e) {
    // When the button is clicked
    String name = tf.getText(); // Get the text from the text field
    JOptionPane.showMessageDialog(this, "Hello, " + name + "!");
  }

  
}

public class SimpleSwing {
  public static void main(String[] args) {
      SimpleFrame sf = new SimpleFrame();
      sf.setVisible(true);
      sf.setSize(500, 500);
      sf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  }
}
```

## 5. Layout Management

A **layout manager** controls the **position and size** of components in a container.


### 5.1 FlowLayout

The FlowLayout in Swing is a simple layout manager that arranges components in a directional flow, similar to how words are arranged in a paragraph. Components are placed in a row from left to right, using their preferred sizes. If the horizontal space is insufficient, the layout manager automatically wraps components to the next line. 

```java
setLayout(new FlowLayout());
```


### 5.2 BorderLayout

The BorderLayout in Java Swing is a layout manager that arranges components into five regions: NORTH, SOUTH, EAST, WEST, and CENTER. Each region can contain at most one component. The CENTER component receives any extra space and stretches both horizontally and vertically, while the NORTH and SOUTH components stretch horizontally, and EAST and WEST stretch vertically. 

**By default, the content pane of a JFrame, JWindow, and JDialog uses BorderLayout.**

```java
setLayout(new BorderLayout());
add(btn, BorderLayout.NORTH);
```


### 5.3 GridLayout

The GridLayout in Swing is a layout manager that arranges components in a rectangular grid of equal-sized cells, with one component placed in each cell. All components are resized to fill their assigned cell, and all cells in the grid have the same width and height. 
It arranges components in **rows and columns**.

```java
setLayout(new GridLayout(2,2));
```


## 6. JPanel

**JPanel** is a **container used to group components**.

### Importance

* Helps organize GUI
* Supports nested layouts

```java
public class JPanelDemo extends JFrame {
  public static void main(String[] args) {
    JFrame frame = new JFrame("Jpanel Demo"); 
    frame.setSize(300, 200);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    JPanel panel = new JPanel();
    panel.setLayout(new FlowLayout());
    
    JButton button = new JButton("Click Me!");
    panel.add(button);

    frame.add(panel);
    frame.setVisible(true);
  }
}
```


## 7. Choice Components


### 7.1 JCheckBox

Allows **multiple selections**.

```java
JCheckBox cb = new JCheckBox("Java");
```


### 7.2 JRadioButton

Allows **single selection** (used with ButtonGroup).

```java
JRadioButton r1 = new JRadioButton("Male");
JRadioButton r2 = new JRadioButton("Female");
ButtonGroup bg = new ButtonGroup();
bg.add(r1);
bg.add(r2);
```

An example app using both JCheckBox and JRadioButton, 


```java 
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;


class MyFrame extends JFrame implements ActionListener
{
  JCheckBox c1,c2;
  JRadioButton r1,r2;

  JTextField tf;

  MyFrame()
  {
    super("Demo");
    
    tf=new JTextField("Demo Text",20);
    tf.setBounds(10,20,100,80);
    
    c1=new JCheckBox("Bold");
    c1.setMnemonic(KeyEvent.VK_B);
    
    c2=new JCheckBox("Italic");
    c2.setMnemonic(KeyEvent.VK_I);
    
    r1=new JRadioButton("lower");
    r2=new JRadioButton("UPPER");
    //Only one radio button can be selected
    ButtonGroup bg=new ButtonGroup(); 
    bg.add(r1);
    bg.add(r2);
    
    c1.addActionListener(this);
    c2.addActionListener(this);
    r1.addActionListener(this);
    r2.addActionListener(this);
    
    r1.setActionCommand("lower");
    r2.setActionCommand("UPPER");
    
    setLayout(new FlowLayout());
    
    add(tf);
    add(c1);
    add(c2);
    add(r1);
    add(r2);          
  }
    
  public void actionPerformed(ActionEvent ae)
  {
    switch(ae.getActionCommand())
    {
      case "lower": 
        tf.setText(tf.getText().toLowerCase());
        break;
      case "UPPER": 
        tf.setText(tf.getText().toUpperCase());
        break;
    }
    int b=0,i=0;
    
    if(c1.isSelected())
      b=Font.BOLD;
    if(c2.isSelected())
      i=Font.ITALIC;
    
    // Font f=new Font("Times New Roman",Font.BOLD|Font.Italic,15);
    Font f=new Font("Times New Roman",b|i,15);
    tf.setFont(f);      
  }    
}

public class SwingItemDemo 
{
  public static void main(String[] args) 
  {
    MyFrame f=new MyFrame();
    f.setSize(500,500);
    f.setVisible(true);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  }    
}
```

## 8. Borders in Swing

In **Swing**, borders are used to:
* Group related components together
* Visually separate sections of a form
* Improve the **look and organization** of GUI applications

To use border, `import javax.swing.border.*;`
### Example

```java
panel.setBorder(BorderFactory.createTitledBorder("Details"));
```

```java 
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;

class MyFrame extends JFrame 
{
  JLabel l;
  JTextField tf;
  JButton b;
  
  JPanel p;
  
  MyFrame()
  {
    l=new JLabel("Name");
    tf=new JTextField(20);
    b=new JButton("OK");
    p=new JPanel();
    
    p.add(l);
    p.add(tf);
    p.add(b);
    
    Border br = BorderFactory.createLoweredBevelBorder();
    p.setBorder(br);
    // p.setBorder(BorderFactory.createTitledBorder("Details"));
    
    setLayout(new FlowLayout());
    add(p);
  }
  
}
public class SwingBorders 
{
  
  public static void main(String[] args) 
  {
    MyFrame f=new MyFrame();
    f.setSize(800,800);
    f.setVisible(true);
    
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  }
}
```


## 9. JComboBox and Its Events

**JComboBox** provides a **drop-down list** but shows one item at a time. 

```java
String[] countries = {"India", "USA", "UK", "Nepal"};
JComboBox<String> cb = new JComboBox<>(countries);
```

### **Event Handling**

- Step 1: Implement Listener `ActionListener`

- Step 2: Override Callback Methods
```java
@Override
public void actionPerformed(ActionEvent e) {
  textField.setText((String) cb.getSelectedItem());
}
```

- Step 3: Register Listeners
```java
cb.addActionListener(this); // 'this' implements ActionListener
```

## 10. JList and MVC Pattern

**JList** displays a **list of items**. It Shows **multiple items at a time**
* Supports **single or multiple selection** (`Ctrl` or `Command` key)
* Usually **scrollable**, added inside `JScrollPane`

```java
String[] months = {"January", "February", "March", "April", "May"};
JList<String> list = new JList<>(months);
list.setVisibleRowCount(5);  // show 5 items at a time
JScrollPane scrollPane = new JScrollPane(list);
```


### Event Handling of JList

- Step 1: Implements `ListSelectionListener`

- Step 2: Override Callback Methods
```java
@Override
public void valueChanged(ListSelectionEvent e) {
    textField.setText((String) list.getSelectedValue());
}
```

- Step 3: Register Listeners
```java
list.addListSelectionListener(this);
```


### MVC Concept

##### **Model** → DefaultListModel
* The array `months` is converted internally into a **ListModel**
* JList uses a **DefaultListModel** or internal model to store items
* The **model contains the actual data**.

You can also create the model explicitly:

```java
DefaultListModel<String> model = new DefaultListModel<>();
model.addElement("January");
model.addElement("February");

JList<String> list = new JList<>(model);
```

####  **View** → JList
The **View** is the visual representation. The **view only displays data from the model**.

```java
JList<String> list = new JList<>(months);
JScrollPane scrollPane = new JScrollPane(list);
```

* JList displays the data.
* JScrollPane allows scrolling.
* `setVisibleRowCount(5)` controls how many rows are visible.

#### **Controller** → Event listeners

The **Controller** handles user interaction.

```java
list.addListSelectionListener(this)
@Override
public void valueChanged(ListSelectionEvent e) {
  String selected = list.getSelectedValue();
  System.out.println("Selected: " + selected);
}
```

## 11. Key and Mouse Event Handling


### 11.1 Key Events

* **KeyEvent** is generated whenever a key is pressed on the keyboard.
* It has **three types**:
   **KeyPressed** – Triggered when a key is pressed.
   **KeyTyped** – Triggered when a valid character is typed (holding the key can generate multiple KeyTyped events).

     * Only for character keys. Non-character keys (Shift, Ctrl, Alt) do not generate KeyTyped.
   **KeyReleased** – Triggered when a key is released.
* KeyEvent can be captured **on containers** like a Frame.
* Pressing a single key can generate all three events.
* KeyTyped events repeat if the key is held down (like in Notepad).

**Handled using `KeyListener`**

* Must implement **all three methods**:

  `keyPressed(KeyEvent e)`
  `keyReleased(KeyEvent e)`
  `keyTyped(KeyEvent e)`

**Usage**:
```java
class MyFrame extends JFrame implements KeyListener {
  JLabel l1, l2, l3, l4;

  MyFrame() {
    super("KeyEventDemo");
    setLayout(null);  // No layout; manual positioning

    // Create labels
    l1 = new Label(""); l2 = new Label(""); 
    l3 = new Label(""); l4 = new Label("");

    // Set bounds (x, y, width, height)
    l1.setBounds(20, 20, 100, 20);
    l2.setBounds(20, 50, 100, 20);
    l3.setBounds(20, 80, 100, 20);
    l4.setBounds(20, 110, 200, 20);

    // Add labels to frame
    add(l1); add(l2); add(l3); add(l4);

    // Add KeyListener to frame
    addKeyListener(this);
  }

  public void keyPressed(KeyEvent k) {
    l1.setText("KeyPressed");
    l2.setText("");
  }

  public void keyReleased(KeyEvent k) {
    l2.setText("KeyReleased");
    l1.setText("");
    l3.setText("");
    l4.setText("");
  }

  public void keyTyped(KeyEvent k) {
    l3.setText("KeyTyped");
    l4.setText(new java.util.Date(k.getWhen()) + "");
  }
}
```


### 11.2 Mouse Events


Mouse events are triggered by **actions of the mouse pointer** on a component (like a Frame, Panel, or Button). The main cases are:

| Event Type        | Trigger Condition                                                                   |
| ----------------- | ----------------------------------------------------------------------------------- |
| **mouseEntered**  | Cursor enters the component area.                                                   |
| **mouseExited**   | Cursor leaves the component area.                                                   |
| **mouseClicked**  | Mouse button pressed and released at the same location (single or multiple clicks). |
| **mousePressed**  | Mouse button is pressed.                                                            |
| **mouseReleased** | Mouse button is released.                                                           |
| **mouseMoved**    | Mouse moves without pressing any button.                                            |
| **mouseDragged**  | Mouse moves while a button is pressed (drag).                                       |


* `mouseClicked` is a combination of `mousePressed` + `mouseReleased`.
* `mouseDragged` only occurs when a button is pressed while moving.
* Mouse coordinates can be obtained using `getX()` and `getY()` for **component coordinates**, or `getXOnScreen()`/`getYOnScreen()` for **screen coordinates**.



**Constants**: `BUTTON1`, `BUTTON2`, `BUTTON3` correspond to left, middle, and right mouse buttons.



##  Mouse Listener Interfaces

### a) MouseListener

Handles **five main events**:

 `mouseClicked(MouseEvent e)`
 `mousePressed(MouseEvent e)`
 `mouseReleased(MouseEvent e)`
 `mouseEntered(MouseEvent e)`
 `mouseExited(MouseEvent e)`

### b) MouseMotionListener

Handles **two events**:

 `mouseMoved(MouseEvent e)`
 `mouseDragged(MouseEvent e)`

> To handle all mouse events, implement **both interfaces**.



##  Sample Application

**Objective**: Show mouse events and coordinates on a frame using labels.

```java
class MyFrame extends JFrame implements MouseListener, MouseMotionListener {

  JLabel l1, l2; // l1 = event name, l2 = coordinates

  MyFrame() {
    super("MouseEventDemo");
    setLayout(null); // manual positioning

    // Create labels
    l1 = new Label(""); l2 = new Label("");

    // Set bounds (x, y, width, height)
    lsetBounds(20, 20, 200, 20);
    lsetBounds(20, 50, 200, 20);

    add(l1); add(l2);

    // Register listeners
    addMouseListener(this);
    addMouseMotionListener(this);
  }

  // MouseListener methods
  public void mouseClicked(MouseEvent e)   { 
    l1.setText("Mouse Clicked"); 
  }
  public void mousePressed(MouseEvent e)   { 
    l1.setText("Mouse Pressed"); 
  }
  public void mouseReleased(MouseEvent e)  { 
    l1.setText("Mouse Released"); 
  }
  public void mouseEntered(MouseEvent e)   { 
    l1.setText("Mouse Entered"); 
  }
  public void mouseExited(MouseEvent e)    { 
    l1.setText("Mouse Exited"); 
  }

  // MouseMotionListener methods
  public void mouseMoved(MouseEvent e)     { 
    l1.setText("Mouse Moved");
    l2.setText("X: " + e.getX() + ", Y: " + e.getY()); 
  }
  public void mouseDragged(MouseEvent e)   { 
    l1.setText("Mouse Dragged");
  }
}
```


## 12. Menus in Swing

### Components

* JMenuBar
* JMenu
* JMenuItem

### Example

```java
JMenuBar mb = new JMenuBar();      // menu bar
JMenu fileMenu = new JMenu("File"); // menu

JMenuItem saveItem = new JMenuItem("Save");
JMenuItem openItem = new JMenuItem("Open");
openItem.setMnemonic(KeyEvent.VK_O); // shortcut: Alt+O

fileMenu.add(saveItem);
fileMenu.addSeparator();  // adds a line separator
fileMenu.add(openItem);

mb.add(fileMenu);
setJMenuBar(mb);           // add menu bar to frame
```



## 13. JTextArea

**JTextArea** allows **multi-line text input**.
* Use `JTextArea` as the main text component
* Wrap it inside `JScrollPane` to make it scrollable

```java
// JTextArea ta = new JTextArea(5,20);
JTextArea ta = new JTextArea();
JScrollPane sp = new JScrollPane(ta);
add(sp, BorderLayout.CENTER);
```


## 14. Dialog Boxes in Swing

### Types

* Message Dialog
* Confirm Dialog
* Input Dialog


```java 
package unit10;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class MyFrame implements ActionListener {

  JFrame frame;
  JButton messageBtn, confirmBtn, inputBtn;

  public MyFrame() {

    frame = new JFrame("Swing Dialog Example");
    frame.setSize(400, 200);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.setLayout(null);

    messageBtn = new JButton("Message Dialog");
    messageBtn.setBounds(30, 30, 150, 30);

    confirmBtn = new JButton("Confirm Dialog");
    confirmBtn.setBounds(200, 30, 150, 30);

    inputBtn = new JButton("Input Dialog");
    inputBtn.setBounds(115, 80, 150, 30);

    // Register listener
    messageBtn.addActionListener(this);
    confirmBtn.addActionListener(this);
    inputBtn.addActionListener(this);

    frame.add(messageBtn);
    frame.add(confirmBtn);
    frame.add(inputBtn);

    frame.setLocationRelativeTo(null);
    frame.setVisible(true);
  }

  @Override
  public void actionPerformed(ActionEvent e) {

    if (e.getSource() == messageBtn) {
        JOptionPane.showMessageDialog(
          frame,
          "Hello! This is a message dialog."
        );
    }

    else if (e.getSource() == confirmBtn) {
        int choice = JOptionPane.showConfirmDialog(
          frame,
          "Do you want to continue?",
          "Confirm",
          JOptionPane.YES_NO_OPTION
        );

        JOptionPane.showMessageDialog(
          frame,
          choice == JOptionPane.YES_OPTION ? "You chose YES" : "You chose NO"
        );
    }

    else if (e.getSource() == inputBtn) {
      String name = JOptionPane.showInputDialog(
          frame,
          "Enter your name:"
      );

      if (name != null && !name.trim().isEmpty()) {
        JOptionPane.showMessageDialog(frame, "Hello, " + name + "!");
      }
    }
  }

  public static void main(String[] args) {
    new MyFrame();
  }
}
```

## 15. JTable (Tabular Data Display)

**JTable** is used to display data in **row and column format**.

```java 
import javax.swing.*;

class TableFrame extends JFrame {

  JTable table;

  public TableFrame() {
    String[] columnNames = {"ID", "Name", "Course"};

    String[][] data = {
      {"101", "Rahul", "Java"},
      {"102", "Anita", "Python"},
      {"103", "Amit", "C++"},
      {"104", "Neha", "JavaScript"}
    };

    table = new JTable(data, columnNames);

    // Add table inside JScrollPane
    JScrollPane sp = new JScrollPane(table);

    // Add scroll pane to frame
    this.add(sp);

    // Frame settings
    this.setTitle("Simple JTable Example");
    this.setSize(400, 300);
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    this.setVisible(true);
  }
}

public class SimpleTableDemo {
  public static void main(String[] args) {
    new TableFrame();
  }
}
```


## 16. MDI (Multiple Document Interface)



### 1. **JInternalFrame**

* A child window that exists **inside a JFrame**
* Can be:

  * Minimized (iconified)
  * Maximized
  * Closed
  * Selected (only one active at a time)
* Commonly used in applications like:

  * Text editors
  * Drawing tools
  * IDEs
  * Document-based software (MS Word–style)


### 2. **JDesktopPane**

* Acts as a **container for multiple JInternalFrame objects**
* Must be set as the **content pane** of the main JFrame
* Without JDesktopPane, internal frames cannot function properly

**Important Rule**

> JInternalFrame **must** be added to a JDesktopPane.


### 3. **Multi-Document Interface (MDI)**

* Allows multiple documents to be open simultaneously
* Each document is represented by a **JInternalFrame**
* Only one internal frame can be selected at a time




```java 
package swinginternalframe;

import javax.swing.*;
import java.awt.event.*;

class MyInternalFrame extends JInternalFrame
{
  static int count =0;
  JTextArea ta;
  JScrollPane sp;
  MyInternalFrame()
  {
    super("Document "+(++count),true,true,true,true);
    
    ta=new JTextArea();
    sp=new JScrollPane(ta);
    add(sp);
    
    JMenuBar mb=new JMenuBar();
    JMenu file=new JMenu("File");
    JMenuItem m1=new JMenuItem("Save");
    
    file.add(m1);
    mb.add(file);
    setJMenuBar(mb);
    
    setSize(300,300);
    setLocation(50,50);
    setVisible(true);
  }
    
}

class MyFrame extends JFrame implements ActionListener
{
  JDesktopPane jDesktopPane;
  MyFrame()
  {
    super("Internal Frame Demo");
    
    jDesktopPane=new JDesktopPane();
    setContentPane(jDesktopPane);
    
    JMenuBar mb=new JMenuBar();
    JMenu d=new JMenu("Document");
    JMenuItem m1=new JMenuItem("New");
    
    d.add(m1);
    mb.add(d);
    setJMenuBar(mb);
    
    m1.addActionListener(this);
  }
  
  public void actionPerformed(ActionEvent ae)
  {
    MyInternalFrame mi=new MyInternalFrame();
    jDesktopPane.add(mi);    
  }
}
public class SwingInternalFrame 
{
  public static void main(String[] args) 
  {
    MyFrame f=new MyFrame();
    f.setSize(800,800);
    f.setVisible(true);
    
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  }   
}
```

## 17. Using IDEs (NetBeans, JBuilder)

### Advantages

* Drag and Drop UI design
* Automatic code generation
* Faster development
* Error highlighting

### NetBeans

* Most popular for Swing
* GUI Builder (Matisse)


## 18. Adapter Classes

Adapter classes provide a **simpler way to handle event listeners** that have **multiple abstract methods**. Instead of implementing all methods (even unused ones), you can **extend an adapter class** and override **only the methods you need**.



##  The Problem with Listeners

* **Single-method listeners** (functional interfaces) like `ActionListener` are easy:

  ```java
  public void actionPerformed(ActionEvent e) { ... }
  ```

  Only one method to implement.

* **Multi-method listeners** like `WindowListener`:

  ```java
  windowActivated
  windowClosed
  windowClosing
  windowDeactivated
  windowDeiconified
  windowIconified
  windowOpened
  ```

  * If you implement `WindowListener`, you must override **all seven methods**.
  * Even if you need only `windowClosing`, you must write dummy bodies for the other six—this is tedious.



##  Adapter Classes: The Solution

* Adapter classes **already implement all methods** of the listener with empty (dummy) bodies.

* You can **extend an adapter class** and **override only the methods you need**.

* Examples:

  | Listener            | Adapter Class      |
  | --------------------|--------------------|
  | WindowListener      | WindowAdapter      |
  | MouseListener       | MouseAdapter       |
  | MouseMotionListener | MouseMotionAdapter |
  | KeyListener         | KeyAdapter         |
  | FocusListener       | FocusAdapter       |

* **Not needed** for single-method listeners (`ActionListener`, `ItemListener`, `AdjustmentListener`) because they are functional interfaces.




##  Using WindowAdapter

###  Inner Class Approach

```java
class MyFrame extends Frame {
  MyFrame() {
    super("Adaper Demo");
    addWindowListener(new MyWindowAdapter());
  }

  class MyWindowAdapter extends WindowAdapter {
    public void windowClosing(WindowEvent we) {
      System.exit(0);
    }
  }
}
```
* Inner class inherits `WindowAdapter`.
* Only `windowClosing()` is overridden.
* Other methods have default empty implementation.

###  Separate Class Approach

```java
class MyWindowAdapter extends WindowAdapter {
  public void windowClosing(WindowEvent we) {
    System.exit(0);
  }
}

class MyFrame extends Frame {
  MyFrame() {
    addWindowListener(new MyWindowAdapter());
  }
}
```

* The adapter class is **independent** and reusable for multiple frames.
