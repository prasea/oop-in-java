# Unit 10 Holding Collection of Data


**Collection Framework is Data Structure in Java**

  - Java provides built-in data structures called **collections**.
  - Collections are used to **store and organize data** inside a program.
  - Without a collection framework (or some data structure), developing real-world applications is nearly impossible.

- **Data is Central**

  - Programs process **data** to compute results.
  - Most applications don’t deal with single values—they deal with **lists of values** (e.g., students, books, accounts).

---

## **Sources of Data for a Java Program**

Java programs can get data from:

1. **Keyboard input**
2. **Files** (data already stored on disk)
3. **Databases**

   * Relational (SQL)
   * Object-oriented
4. **Remote computers / networks**

   * Through the internet or local network

**Important:** The data is often a **list** (collection), not just a single value.

---

#### **Examples of Data Lists**

* **List of primitive values:** integers, floats, etc.
* **List of objects:** students, books, customers, accounts, movies.
* **Purpose of Data** Computation, search, update, reporting, billing, etc.


```java
Student[] students = new Student[100];  // Array of 100 students
```

---

#### **Storing Data in Memory**

* Once data comes from the source, it must be held in memory (typically in the **heap** for objects in Java).
* The **organization of data** in memory is called a **data structure**.
* **Collections** are Java’s way of arranging data efficiently in memory.

---

## **Arrays: Basic Data Structure**

An **array** is a **fixed-size data structure** that stores elements of the **same data type** in contiguous memory locations. It is the simplest way to store a collection of values.

### **Limitations of Arrays**

* **Fixed Size:**

  * Once an array is created, its size **cannot change**.
  * To increase size:

    1. Create a new array of larger size.
    2. Copy existing elements into the new array.
    3. Make the original reference point to the new array.
    4. Optionally, discard the old array.

  Example:

  ```java
  int[] A = new int[5];  // original array
  int[] B = new int[10]; // new bigger array
  // System.arraycopy(A, 0, B, 0, A.length);
  for(int i=0; i< A.length; i++) {
    B[i] = A[i];
  }
  A = B;  // A now points to bigger array
  B = null;
  ```

* **Drawbacks:**

  * Programmer must handle resizing manually.
  * Cannot predict the number of elements coming at runtime.
  * Insertion/deletion in the middle of array requires shifting elements manually.
  * No built-in methods for insertion, deletion, or sorting

---

### **Why Arrays Are Not Always Suitable**

* Real-world applications often need **dynamic-sized collections**.
* Arrays are not flexible for:

  * Unknown size at runtime
  * Frequent insertion/deletion in the middle
  * Ensuring uniqueness of elements
  * Maintaining sorted order automatically
---

### **Collection Framework to the Rescue**

Java provides **built-in classes** under the **Collections Framework** to overcome array limitations:

**ArrayList**
  * Dynamic resizing (auto-expands when more elements are added)

* **LinkedList**
  * Also allows dynamic insertion/deletion anywhere in the list

* **Set**
  * Automatically prevents duplicate elements

* **SortedSet**
  * Ensures elements are unique **and** sorted automatically

---

### **Common Operations on Collections**

1. **Insertion**

   * Collections handle insertion automatically.
   * No need to manually shift elements like arrays.

2. **Deletion**

   * Collections handle deletion automatically.
   * No need to manually shift elements.

3. **Searching**

   * Collections provide built-in methods.
   * Methods can implement:

     * Linear Search
     * Binary Search
     * Hash-based search (key-value pair via Map classes)
   * Hashing provides **fast search** for large collections.

---

### **Key Takeaways**

* Arrays are simple but **limited in flexibility**.
* Collections Framework provides:

  * **Dynamic sizing** (ArrayList, LinkedList)
  * **Uniqueness** (Set)
  * **Sorting** (SortedSet)
  * **Efficient operations**: insert, delete, search, hash-based lookup
* Collections let the programmer **focus on using data**, not managing it.



## Java Collection Framework

The **Java Collection Framework (JCF)** is a **set of classes and interfaces** that provide **dynamic data structures** for storing and manipulating groups of objects.

### Advantages of Collections

* Dynamic resizing
* Built-in algorithms
* Reduces programming effort
* Increases performance and code reusability

### Hierarchy 

* **Collection (interface)**

  * List
  * Set
* **Map (interface)** *(does not extend Collection)*

---

# PART I: COLLECTION INTERFACES

---

## 3. Collection Interface

### Definition

The **Collection interface** is the **root interface** of the collection hierarchy.

### Important Methods

* `add()`
* `remove()`
* `size()`
* `clear()`
* `contains()`
* `iterator()`

---

## 4. List Interface

### Definition

A **List** is an **ordered collection** that allows:

* Duplicate elements
* Positional access using index

### Key Features

* Maintains insertion order
* Allows multiple `null` values


* **Classes implementing List:**

  * **ArrayList:** Dynamic array, widely used
  * **LinkedList:** Doubly-linked list structure
  * **Vector (Legacy):** Old dynamic array class
  * **Stack (Legacy):** Last-In-First-Out structure

---

## 5. Set Interface

### Definition

A **Set** is a collection that **does not allow duplicate elements**.

### Key Features

* Unordered (except sorted sets)
* No index-based access


* **Classes implementing Set:**

  * **HashSet:** Uses hashing, unordered List.
  * **LinkedHashSet:** Maintains insertion order using LinkedList.
  * **SortedSet (interface):** Elements are **sorted**
    * **TreeSet:** Implements SortedSet interface using tree data structure. You can search element faster. 


---

## 6. Map Interface

### Definition

A **Map** stores data in the form of **key–value pairs**.

### Key Characteristics

* Keys must be unique
* Values may be duplicated
* Does **not** extend Collection interface

* **Classes implementing Map Interface:**

  * **HashMap:** Unordered, uses hashing
  * **LinkedHashMap:** Maintains insertion order
  * **Hashtable (Legacy):** Old synchronized class
  * **SortedMap (interface):** Maintains sorted keys
    * **TreeMap:** Implementation using tree data structure

### Common Methods

* `put(key, value)`
* `get(key)`
* `remove(key)`
* `keySet()`
* `values()`

---

# PART II: COLLECTION CLASSES

---

## 7. ArrayList Class

### Definition

**ArrayList** is a **resizable array implementation** of the List interface.

### Characteristics

* Allows duplicate elements
* Maintains insertion order
* Fast random access
* Not synchronized

### Example

```java
import java.util.ArrayList;
import java.util.List;

public class Demo {
  public static void main(String[] args) {
    List<Integer> al1 = new ArrayList<>(20); // Initial capacity 20
    al1.add(10); // Adds 10 at the end
    al1.add(0, 5); // Inserts 5 at index 0, shifts 10 to index 1
    ArrayList<Integer> al2 = new ArrayList<>(List.of(50, 60, 70, 80, 90));
    al1.addAll(al2); // Adds all elements at the end
    System.out.println(al1);
    al1.addAll(1, al2); // Inserts all elements starting at index 1

    Integer val = al1.get(5); // Access element at index 
    al1.set(6, 100); // Replaces element at index 6 with 100
    al1.remove(3); // Remove element at index 3
    al1.clear();   // Removes all elements

  }
}
```

### When to Use

* When frequent read operations are required


### **Iterating through ArrayList**

**a) Using for loop**

```java
for(int i = 0; i < al1.size(); i++) {
  System.out.println(al1.get(i));
}
```

**b) Using Iterator**

```java
ArrayList<Integer> al1 = new ArrayList<>(List.of(10,20,30,40));
Iterator<Integer> it = al1.iterator();
while(it.hasNext()) {
  System.out.println(it.next());
}
```


---

## LinkedList Class


A **LinkedList** in Java is a collection of nodes arranged in a **doubly-linked list** structure:

* **Node Components**:

  * **Data/Value**: The actual element (can be Integer, String, or any object type).
  * **Next Pointer**: Points to the next node in the list.
  * **Previous Pointer**: Points to the previous node in the list.

* **Head Node**: First node in the list; stores the starting reference.

* **Tail Node**: Last node; its `next` pointer is `null`.

---

### **2. Why Use LinkedList?**

#### **Advantages**

1. **Efficient Insertion/Deletion**:

   * Inserting or deleting a node doesn’t require shifting other elements (unlike arrays).
   * Example: Inserting `10` between `45` and `3` only updates pointers, no data movement.

2. **Dynamic Size**:

   * LinkedList can grow or shrink as needed.
   * No need to predefine a size (unlike arrays where resizing requires copying all elements).

#### **Disadvantages**

1. **Extra Memory**:

   * Each node requires extra memory for `next` and `prev` pointers.
2. **Random Access Slower**:

   * Accessing an element by index is slower than arrays because it requires traversal.

---

### **3. LinkedList vs ArrayList**

| Feature              | ArrayList                | LinkedList                      |
| -------------------- | ------------------------ | ------------------------------- |
| Structure            | Dynamic array            | Doubly-linked list              |
| Insertion/Deletion   | Slow (requires shifting) | Fast (adjust pointers only)     |
| Memory Usage         | Less                     | More (extra space for pointers) |
| Size Flexibility     | Fixed / Resizable        | Fully dynamic                   |
| Access Time by Index | Fast (O(1))              | Slow (O(n))                     |

**Key Takeaway:**

* Use **LinkedList** when frequent insertions/deletions are needed.
* Use **ArrayList** for fast random access and memory efficiency.

---

### **4. Java LinkedList Class**

### **Initialization**

```java
import java.util.LinkedList;

LinkedList<Integer> list1 = new LinkedList<>();
// LinkedList<Integer> list2 = new LinkedList<>(Arrays.asList(50, 60, 70, 80, 90));
LinkedList<Integer> list2 = new LinkedList<>(List.of(50, 60, 70, 80, 90));
```

**Notes:**

* No initial size is required.
* Elements are added dynamically.

```java 
import java.util.*;

public class ListDemo {
  public static void main(String[] args) {
    LinkedList<Integer> list1 = new LinkedList<>();
    LinkedList<Integer> list2 = new LinkedList<>(List.of(50, 60, 70, 80, 90));
    list1.add(10);
    list1.add(0,5);
    list1.addAll(1, list2);
    list1.set(6, 100);

    list1.addFirst(0);
    list.addLast(100);

    
    list1.removeFirst();
    list1.removeLast();

    ListIterator<Integer> li = list1.listIterator();
    while(li.hasNext()) {
      System.out.println(li.next());
    }
  }
}
```


### **Common Methods**

**Inherited from List Interface (similar to ArrayList):**

* `add(element)` – Add at end.
* `add(index, element)` – Add at specific position.
* `addAll(collection)` – Add all elements of another collection.
* `get(index)` – Retrieve element by index.
* `set(index, element)` – Update element at index.
* `contains(element)` – Check if element exists.
* `indexOf(element)` / `lastIndexOf(element)` – Find element positions.
* Iteration: `for-each`, `ListIterator`, lambda expressions.

**Specific to LinkedList / Deque Interface:**

* `addFirst(element)` – Add at beginning.
* `addLast(element)` – Add at end.
* `removeFirst()` / `removeLast()` – Remove from start or end.
* `getFirst()` / `getLast()` – Retrieve first or last element without removing.
* `peekFirst()` / `peekLast()` – View first or last element without removal.
* `pollFirst()` / `pollLast()` – Retrieve and remove first/last element.
* `descendingIterator()` – Iterate from last to first.

---

## 9. HashSet Class

* **Hashing** is a technique to map **keys or values** to specific **locations** in a table using a **hash function**.
* Each location in a hash table is called a **bucket**.
* A bucket may store **one or more entries**, depending on the collision-handling method.
* Hashing allows **constant time operations** (O(1)) for insertion and searching in ideal cases.



* **HashSet** implements the Set interface using a **hash table**. Since **HashSet** is a **Set**, it **does not allow duplicate elements**.
* **Hash**: internally uses **hash table** for storing elements.
* Implements **Collection** and **Set** interfaces.
* Offers **constant time performance** (O(1)) for basic operations like `add`, `remove`, `contains`, and `size`.
* Unlike `ArrayList` or `LinkedList` which may take **O(n)** time, `HashSet` is faster due to hashing.


* **Load factor**: controls how full the hash table can be before resizing.
* Default: 0.75. So minimum 25% of space will be wasted
* Recommended: 0.5 for balance between space and performance.
* Should be **between 0 and 1**.

---

### **HashSet Characteristics**

* **No duplicates**: only unique elements are stored.
* **No guaranteed order**: elements may appear in any order.
* **Fast operations**: add, remove, and search in constant time.
* **Dynamic resizing**: table size increases automatically if more elements are added than allowed by the load factor.
* **Space trade-off**: some space is wasted to maintain constant time performance (default ~25%).

---

## **Common Methods**

| Method          | Description                      |
| --------------- | -------------------------------- |
| `add(E e)`      | Adds element to the HashSet      |
| `remove(E e)`   | Removes element from the HashSet |
| `contains(E e)` | Checks if element exists         |
| `size()`        | Returns number of elements       |
| `iterator()`    | Iterates through elements        |
| `clear()`       | Removes all elements             |


```java
import java.util.*;

public class HashSetDemo {
  public static void main(String[] args) {
    HashSet<Integer> hs = new HashSet<>();

    hs.add(10);
    hs.add(20);
    hs.add(30);
    hs.add(10); // duplicate, will be ignored

    System.out.println(hs); // Output: [10, 20, 30] (order not guaranteed)
  }
}
```


---

## 10. TreeSet Class

* **TreeSet** is a **Set**: it stores **unique elements** (no duplicates).
* **Tree**: uses a tree-based data structure for storage (likely a **Red-Black Tree** or **AVL Tree**).
* Guarantees **log(n) time complexity** for basic operations like `add`, `remove`, and `contains`.
* Implements multiple interfaces:

  * `Set` – ensures uniqueness.
  * `SortedSet` – maintains elements in **sorted order**.
  * `NavigableSet` – provides navigation methods (`ceiling`, `floor`, etc.).
  * `Collection` – basic collection interface.

### **TreeSet Characteristics**

* **No duplicates**: automatically removes duplicates.
* **Sorted elements**: maintains natural order (or custom order using `Comparator`).
* **Logarithmic performance**: `add`, `remove`, `contains` take **O(log n)** time.
* **Generic**: can store `Integer`, `Float`, `Double`, `Character`, `String`, or any **comparable object**.


## **Common Methods**

| Method                 | Description                         |
| ---------------------- | ----------------------------------- |
| `add(E e)`             | Adds an element                     |
| `addAll(Collection c)` | Adds all elements from a collection |
| `ceiling(E e)`         | Returns smallest element **≥ e**    |
| `floor(E e)`           | Returns largest element **≤ e**     |
| `first()`              | Returns first (smallest) element    |
| `last()`               | Returns last (largest) element      |
| `descendingSet()`      | Returns reversed order set          |
| `contains(E e)`        | Checks if element exists            |
| `iterator()`           | Iterates in ascending order         |
| `descendingIterator()` | Iterates in descending order        |
| `remove(E e)`          | Removes element                     |



```java
import java.util.*;

public class TreeSetDemo {
  public static void main(String[] args) {
    TreeSet<Integer> ts = new TreeSet<>(List.of(20, 30, 50, 70, 10, 40, 10));
    
    System.out.println(ts); // Output: [10, 20, 30, 40, 50, 70] (sorted, no duplicates)

    ts.add(25);
    System.out.println(ts); // Output: [10, 20, 25, 30, 40, 50, 70]

    System.out.println(ts.ceiling(55)); // Output: 70
    System.out.println(ts.floor(55));   // Output: 50
  }
}
```

---

# PART III: ACCESSING COLLECTIONS

---

## 11. Iterator Interface

### Definition

An **Iterator** is used to **traverse elements** of a collection one by one.

### Important Methods

* `hasNext()`
* `next()`
* `remove()`

### Example

```java
Iterator<String> it = list.iterator();
while(it.hasNext()) {
  System.out.println(it.next());
}
```

### Advantages

* Works for all collections
* Safer than loops
* Avoids `ConcurrentModificationException`

---

## 12. Comparator Interface

### Definition

A **Comparator** is used to define **custom sorting logic**.
* It allows **custom comparison logic** for sorting objects.
* It is Useful when:

  * Sorting **user-defined classes**.
  * Sorting in **custom order** (ascending, descending).

### Difference Between Comparable and Comparator

| Comparable       | Comparator       |
| ---------------- | ---------------- |
| `compareTo()`    | `compare()`      |
| Natural ordering | Custom ordering  |
| Single sorting   | Multiple sorting |

### Example


```java
import java.util.Comparator;

class MyComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer i1, Integer i2) {
        // return i2 - i1; //Reverse order
        return a.compareTo(b);
    }
}

public class ComparatorDemo {
  public static void main(String[] args) {
    List<Integer> numbers = new ArrayList<>();
    numbers.add(5);
    numbers.add(2);
    numbers.add(8);
    numbers.add(1);
    // Collections.sort(numbers);
    Collections.sort(a, new MyComparator());
    System.out.println(Collections.toString(a)); // [8,7,6,5,4,3,2,1]
  }
}
```

---
