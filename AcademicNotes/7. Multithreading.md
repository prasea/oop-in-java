# Unit: Multithreading in Java

## 1. Introduction to Multithreading

**Multithreading** is a core feature of Java that allows a program to execute multiple tasks concurrently. Each task runs in a **thread**, which is a lightweight sub-process.

### Why Multithreading?

* Improves **CPU utilization**
* Enables **responsive applications** (e.g., GUI, servers)
* Allows **parallel execution** of tasks
* Essential for **banking systems, servers, and real-time applications**

### Real-World Example

In a banking application:

* One thread handles **user requests**
* Another thread processes **transaction validation**
* Another thread logs **audit information**

---

## 2. Understanding Threads in Java

### What is a Thread?

A **thread** is an independent path of execution within a program.

Java provides built-in support for multithreading through:

* `java.lang.Thread` class
* `java.lang.Runnable` interface

---

## 3. Creating Threads in Java

Java provides **two primary ways** to create threads:

---

## 3.1 Extending `java.lang.Thread`

### Concept

A class can extend the **Thread** class and override its `run()` method.

**Implementing Multi-Threading Using `Thread` Class**

   * **Step 1:** Create a class that extends `Thread`.
   * **Step 2:** Override `public void run()` method with the thread logic. `run()` is starting point of thread just like `main()` is starting point of program.
   * **Step 3:** In `main()`, create an object of your class.
   * **Step 4:** Call `start()` on the object to start the thread. The `start()` calls `run()` as thread. 


### Syntax Example

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running");
    }
}

public class TestThread {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();  // starts a new thread
    }
}
```

### Key Points

* `run()` → contains the task
* `start()` → creates a new thread and calls `run()`
* Calling `run()` directly does **not** start a new thread

### Limitations

* Java does **not support multiple inheritance**
* Extending `Thread` restricts class extensibility

---

## 3.2 Implementing `java.lang.Runnable` Interface

### Concept

A class implements the **Runnable** interface and passes the object to a `Thread` instance.

**Implementing Multi-Threading Using `Runnable` Interface**
   1. Create a class implementing `Runnable`.
   2. Override `public void run()` with your thread logic.
   3. Create an object of your class:

      ```java
      MyRunnable m = new MyRunnable();
      ```
   4. Attach it to a Thread object:

      ```java
      Thread t = new Thread(m);
      ```
   5. Start the thread:

      ```java
      t.start();
      ```
      
### Syntax Example

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread is running using Runnable");
    }
}

public class TestRunnable {
    public static void main(String[] args) {
        MyRunnable r = new MyRunnable();
        Thread t = new Thread(r);
        t.start();
    }
}
```

### Advantages

* Supports **multiple inheritance**
* Better **object-oriented design**
* Preferred in **real-world applications**

---

## 4. Thread Execution and Life Cycle

### Thread Life Cycle States

Threads, like objects or real-world things, have **states** representing their current situation. For example:

* A person: standing, sitting
* A car: running, parked
 
Similarly, a thread can be in different states during its life cycle.

---

## **1. New State**

* **When it occurs:** When a thread object is created.
* **How to enter:** `Thread t = new Thread();`
* **Meaning:** Thread exists but has **not started yet**.

---

## **2. Runnable / Ready State**

* **When it occurs:** After calling `start()` on a thread.
* **Meaning:** Thread is **ready to run** and waiting for CPU scheduling.
* **Transition:** The JVM schedules it to run.

---

## **3. Running State**

* **When it occurs:** JVM calls the `run()` method.
* **Meaning:** Thread is **actively executing its task**.

---

## **4. Terminated / Dead State**

* **When it occurs:** Thread completes execution of `run()`.
* **Meaning:** Thread has **finished its task**.
* **Important:** A terminated thread **cannot be restarted**. To run the same task again, you must create a **new thread object**.

---

## **5. Waiting State**

* **When it occurs:** Thread is waiting for another thread to notify it for a resource. Waiting to acquire resource.
* **How:** Using `wait()` method.
* **Meaning:** Thread is **inactive but not terminated**, waiting for a condition or signal.

---

## **6. Timed Waiting / Sleep State**

* **When it occurs:** Thread is made to **pause for a specified time**.
* **How:** Using `sleep(milliseconds)` or `join(milliseconds)`.
* **Meaning:** Thread is temporarily inactive, then resumes automatically after the time expires.
* **Use Case:** Animations, controlling speed of operations, etc.

---

## **7. Blocked State**

* **When it occurs:** Thread is **trying to access a resource** that is locked by another thread.
* **Meaning:** Thread is waiting to **acquire a lock or monitor**.
* **Transition:** Once the resource is available, the thread continues execution(running).

---

### Diagram Concept

```
New → Runnable → Running → Terminated
           ↓
        Waiting / Blocked
```

### Example

```java
Thread t = new Thread();
t.start(); // Runnable
```

---

## 5. Thread Priorities

Threads in Java can have **priorities**, which help the JVM **scheduler** decide which thread should get more CPU time.

---

### **1. Ready Queue and Scheduler**

* All threads ready to run are placed in a **ready queue** by the JVM scheduler.
* **CPU executes only one thread at a time**.
* **Time sharing**: CPU time is divided among threads in slices (e.g., 1 second per thread in round-robin fashion).

---

### **2. Concept of Priority**

* Each thread can have a **priority value** from **1 to 10**.

  * **MIN_PRIORITY** = 1
  * **NORM_PRIORITY** = 5 (default)
  * **MAX_PRIORITY** = 10

* **Higher priority threads** get preference:

  * May be executed first.
  * May receive a **larger time slice**.
  * Lower priority threads may have to wait longer (**starvation** can occur if not managed properly).


### Example

```java
class PriorityThread extends Thread {
  private String threadName;

  PriorityThread(String name) {
    this.threadName = name;
  }

  public void run() {
    // The loop is just to give the scheduler a chance to show the priority effect
    for (int i = 0; i < 5; i++) {
      System.out.println(threadName + " running with priority: " + getPriority() + ", iteration: " + i);
    }
  }
}

public class ThreadPriorityExample {
  public static void main(String[] args) {
    PriorityThread t1 = new PriorityThread("HighPriorityThread");
    PriorityThread t2 = new PriorityThread("LowPriorityThread");

    // Set priorities using predefined constants or integer values (1-10)
    t1.setPriority(Thread.MAX_PRIORITY); // Value 10
    t2.setPriority(Thread.MIN_PRIORITY); // Value 1

    System.out.println(t1.threadName + " priority: " + t1.getPriority());
    System.out.println(t2.threadName + " priority: " + t2.getPriority());

    // Start the threads
    t2.start();
    t1.start();
  }
}

```

### Key Notes

* Higher priority threads **may** execute first
* Execution order is **not guaranteed**
* OS-dependent behavior

---

## 6. Thread Synchronization


### **Resource Sharing**

* **Definition:** When multiple threads access the same resource (file, printer, data object, network connection).
* **Example:** An object in the heap is accessible by multiple threads.
* **Memory Note:** Each thread has its **own stack**, but object in **heap is shared**.

---

### **Critical Section**

* **Definition:** The piece of code that **accesses the shared resource** is called a critical section.
* **Example:** If a shared file is accessed by lines 10–20 of Thread 1 and lines 15–25 of Thread 2, these lines are **critical sections**.

---

### **Mutual Exclusion (Mutex)**

* **Definition:** Only one thread should access a shared resource at a time. Both should not be using the same object simultaneously.
Mutual Exclusion means happening of one prevents happening of another.
* **Purpose:** Prevents data corruption due to concurrent access.
* **Example:**

  * Two people sending print jobs to the same printer: Without coordination, printouts mix up.
  * With mutual exclusion, only **one thread uses the printer** at a time.

---

## **3. Achieving Synchronization**


### **3.1 Locking/Mutex**

* Each thread checks a **mutex variable** before accessing a shared resource. CPU executes threads in queue in time-sharing or round robin fashion. Suppose there are 2 threads and both requires **Shared Object**

* **Example Flow:**

  1. Thread 1 sees `mutex = 0` → locks it → uses resource → releases lock.
  2. Thread 2 sees `mutex = 1` → waits → tries again later.

So, Thread themeself will try to achieve Synchronization. It is like two people co-ordinating to access same thing. 

* **Problem:**

  * If a thread checks the mutex find it to be free (mutex = 0) but is preempted(time slice over) from CPU queue before locking, another thread may also start using the resource → **race condition**.

Two people saw that washroom is free. They are unaware. So both are using same washroom.

With mutex, two threads are coordinating by just one variable. They may fight. So we need some system. In olden days before Java, OS was supposed to take care of it.


### **3.2 Semaphore**

* **Definition:** OS-level mechanism to control access to shared resources.

* **Methods:** `wait()` (acquire), `signal()` (release) are provided by OS

* **How it works:**

  1. Thread calls `wait()` → if resource is free, it locks it.
  2. If resource is busy, thread moves to a **blocked queue** from **ready queue**
  3. When thread finishes use of resource, it is released by calling `signal()` methods and that blocked thread moves back to the **ready queue**.

- Blocked Queue is maintained by Semaphore and contains Threads waiting to access shared resource. 
- Ready Queue contains Threads waiting to access CPU

* **Example:**

  * ATM analogy: Security person ensures **only one person enters at a time**; others wait in queue.
  * Thread 1 uses resource → signal → Thread 2 from blocked queue gets resource.

* **Advantages:** Solves race conditions present with simple mutex.

### **3.3 Monitor (Modern OOP Approach)**

* Monitors were introduced for **object-oriented multithreading**.
* Java uses **monitors** to synchronize access to shared objects (via `synchronized` keyword).
* Conceptually, a monitor is like a **watchman for shared resources**, ensuring **mutual exclusion and coordination** automatically.

### What is a Monitor?

A **monitor** is ashared **object** that contains
  * Shared Data
  * Methods (read/write)
  * Lock/Mutex
  * Waiting queue
* And enforces **mutual exclusion automatically**

### What is Synchronization?

**Synchronization** is the process of controlling access to shared resources to prevent data inconsistency.

### Problem: Race Condition

Occurs when multiple threads access shared data simultaneously.

### Example Without Synchronization

```java
package unit7;

class MyData {
  public void display(String str) {
    for(int i=0;i<str.length();i++) {
      System.out.print(str.charAt(i) + "   ");
    }
  }
}

class MyThread1 extends Thread {
  MyData d; 
  
  public MyThread1(MyData data) {
    d = data;
  } 
  public void run() {
    d.display("Hello World");
  }
}

class MyThread2 extends Thread {
  MyData d; 
  
  public MyThread2(MyData data) {
    d = data;
  } 
  public void run() {
    d.display("Welcome");
  }
}

public class ThreadSync {
  public static void main(String[] args) {
    MyData md = new MyData(); // Shared Resource
    
    MyThread1 mt1 = new MyThread1(md);
    MyThread2 mt2 = new MyThread2(md);
    
    mt1.start();
    mt2.start();
  }    
}

```


* Threads access `display()` simultaneously.
* Output letters are **mixed**, showing no control over sequence.

---

## 6.1 Synchronized Method

```java
package unit7;

// Common Resource
class MyData {
  public synchronized void display(String str) {
    for(int i=0;i<str.length();i++) {
      System.out.print(str.charAt(i) + "   ");
    }
  }
}

class MyThread1 extends Thread {
  MyData d; 
  
  public MyThread1(MyData data) {
    d = data;
  } 
  public void run() {
    d.display("Hello World");
  }
}

class MyThread2 extends Thread {
  MyData d; 
  
  public MyThread2(MyData data) {
    d = data;
  } 
  public void run() {
    d.display("Welcome");
  }
}

public class ThreadSync {
  public static void main(String[] args) {
    MyData md = new MyData(); 
    
    MyThread1 mt1 = new MyThread1(md);
    MyThread2 mt2 = new MyThread2(md);
    
    mt1.start();
    mt2.start();
  }    
}

```

* Only **one thread at a time** can enter the synchronized block.
* Ensures **complete printing of one string** before another thread starts.

---

## 7. Inter-Thread Communication

**Inter-thread communication** allows threads to communicate and coordinate execution.

Java provides methods:

* `wait()`
* `notify()`
* `notifyAll()`

These methods belong to the **Object class**.


###  **1. Interthread Communication (Producer-Consumer Example)**

* Shared object (`data`) accessed by two threads:

  1. **Producer** → writes data to shared object.
  2. **Consumer** → reads data from shared object.

* Goal: Ensure **coordinated access** so:

  * Producer writes only if consumer has read previous data.
  * Consumer reads only if producer has written new data.

---

### **Mechanism**
Java doesn't provide any built-in mechanism for Inter-Thread communication. Programmer has to implement their own logic. 

* Use a **flag** to control turns:

  * `true` → Producer’s turn
  * `false` → Consumer’s turn
* Steps:

  1. Producer checks flag → if `true`, produces data and sets flag to `false`.
  2. Consumer checks flag → if `false`, consumes data and sets flag to `true`.
* Ensures orderly **communication between threads**.


## **2. Shared Object Class: MyData**

```java
class MyData {
  private int value = 0;
  
  // Producer writes value
  public void set(int v) {
    value = v;
  }

  // Consumer reads value
  public  int get() {    
    int x = value;
    return x;
  }
}
```

---

## **3. Producer Thread**

```java
class Producer extends Thread {
  MyData data;

  public Producer(MyData d) { 
    data = d; 
  }

  public void run() {
    int count = 1;
    while(true) {
      data.set(count);  // Set value in shared object
      System.out.println("Producer produced: " + count);
      count++;
    }
  }
}
```

---

## **4. Consumer Thread**

```java
class Consumer extends Thread {
  MyData data;

  public Consumer(MyData d) { data = d; }

  public void run() {
    while(true) {
      int value = data.get();   // Get value from shared object
      System.out.println("Consumer consumed: " + value);
    }
  }
}
```

---

## **5. Main Method**

```java
public class Main {
  public static void main(String[] args) {
    MyData data = new MyData();   // Shared object

    Producer p = new Producer(data);
    Consumer c = new Consumer(data);

    p.start();  // Start producer thread
    c.start();  // Start consumer thread
  }
}
```


Using just **synchronized** is not enough because Producer thread is using `set()` and Consumer thread is using `get()`. Both are separate methods. No more than one Producer can use set() and no more than one Consumer can use get(). But they can use different method at same time. No conflict.
```java
class MyData {
  private int value = 0;
  
  // Producer writes value
  public synchronized void set(int v) {
    value = v;
  }

  // Consumer reads value
  public synchronized  int get() {    
    int x = value;
    return x;
  }
}
```

Hence, using a **flag + wait/notify**, we ensure strict alternation of access to the shared resource. This pattern can be extended for multiple producers and consumers, using `notifyAll()` instead of `notify()`.

```java
class MyData {
  private int value = 0;
  private boolean flag = true; // true = Producer's turn, false = Consumer's turn

  // Producer writes value
  public synchronized void set(int v) {
    while(flag != true) {
      try { wait(); } catch(Exception e) {}
    }
    value = v;      // Set value
    flag = false;   // Switch turn to consumer
    notify();       // Wake up consumer
  }

  // Consumer reads value
  public synchronized int get() {
    while(flag != false) {
      try { wait(); } catch(Exception e) {}
    }
    int x = value;  // Get value
    flag = true;    // Switch turn to producer
    notify();       // Wake up producer
    return x;
  }
}
```


### Key Points
* `synchronized` ensures that only one thread can execute `set()` or `get()` at a time.
* `wait()` releases lock and waits for its turn.
* `notify()` wakes up waiting thread
* Prevents unnecessary CPU usage

---

## 8. Deadlock

### What is Deadlock?

Deadlock is a situation in which threads (or processes) are indefinitely blocked, waiting for resources that other threads hold. This scenario leads to an unbreakable cycle of dependencies, where no involved thread can make progress.

### Conditions for Deadlock

For a deadlock to occur, four conditions must be met simultaneously, known as the Coffman conditions:

- **Mutual Exclusion**: At least one resource must be held in a non-shareable mode, meaning only one thread can use it at a time.
- **Hold and Wait**: A thread must hold one resource and wait to acquire additional resources that other threads hold.
- **No Preemption**: Resources cannot be forcibly taken away from threads. They must be released voluntarily.
- **Circular Wait**: A closed chain of threads exists, where each thread holds at least one resource needed by the next thread in the chain.

---

## 8.1 Deadlock Example

```java
package unit7;

class Locks {
  public static final Object LOCK_A = new Object();
  public static final Object LOCK_B = new Object();
}

class DeadlockThreadOne extends Thread {

  @Override
  public void run() {
    synchronized (Locks.LOCK_A) {
      System.out.println("ThreadOne: Holding LOCK_A");

      try { Thread.sleep(100); } catch (InterruptedException e) {}

      System.out.println("ThreadOne: Waiting for LOCK_B");
      synchronized (Locks.LOCK_B) {
        System.out.println("ThreadOne: Holding LOCK_A and LOCK_B");
      }
    }
  }
}

class DeadlockThreadTwo extends Thread {

  @Override
  public void run() {
    synchronized (Locks.LOCK_B) {
      System.out.println("ThreadTwo: Holding LOCK_B");

      try { Thread.sleep(100); } catch (InterruptedException e) {}

      System.out.println("ThreadTwo: Waiting for LOCK_A");
      synchronized (Locks.LOCK_A) {
        System.out.println("ThreadTwo: Holding LOCK_B and LOCK_A");
      }
    }
  }
}

public class DeadlockDemo {

  public static void main(String[] args) {
    Thread t1 = new DeadlockThreadOne();
    Thread t2 = new DeadlockThreadTwo();

    t1.start();
    t2.start();
  }
}


```

### Result

Both threads wait forever.

---

## 8.2 Deadlock Prevention Techniques

* **Avoid nested locks**
* Lock resources in **fixed order**
* Use **timeouts**
* Minimize synchronized blocks

---

## 9. Summary

### Key Takeaways

* **Threads** enable concurrent execution
* Threads can be created using:

  * `Thread` class
  * `Runnable` interface (preferred)
* **Thread life cycle** governs execution flow
* **Thread priority** influences scheduling
* **Synchronization** ensures data consistency
* **Inter-thread communication** coordinates threads
* **Deadlock** is a critical issue requiring careful design

---

## 10. Examination-Oriented Points

* Difference between `start()` and `run()`
* Thread vs Runnable
* Advantages of synchronization
* Producer–Consumer problem
* Causes and prevention of deadlock

---
