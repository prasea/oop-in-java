# Unit: Multithreading in Java

## 1. Introduction to Multithreading

**Multithreading** is a core feature of Java that allows a program to execute multiple tasks concurrently. Each task runs in a **thread**, which is a lightweight sub-process.

### Why Multithreading?

* Improves **CPU utilization**
* Enables **responsive applications** (e.g., GUI, servers)
* Allows **parallel execution** of tasks
* Essential for **banking systems, servers, and real-time applications**

### Real-World Example

In a banking application:

* One thread handles **user requests**
* Another thread processes **transaction validation**
* Another thread logs **audit information**

---

## 2. Understanding Threads in Java

### What is a Thread?

A **thread** is an independent path of execution within a program.

Java provides built-in support for multithreading through:

* `java.lang.Thread` class
* `java.lang.Runnable` interface

---

## 3. Creating Threads in Java

Java provides **two primary ways** to create threads:

---

## 3.1 Extending `java.lang.Thread`

### Concept

A class can extend the **Thread** class and override its `run()` method.

**Implementing Multi-Threading Using `Thread` Class**

   * **Step 1:** Create a class that extends `Thread`.
   * **Step 2:** Override `public void run()` method with the thread logic. `run()` is starting point of thread just like `main()` is starting point of program.
   * **Step 3:** In `main()`, create an object of your class.
   * **Step 4:** Call `start()` on the object to start the thread. The `start()` calls `run()` as thread. 


### Syntax Example

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running");
    }
}

public class TestThread {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();  // starts a new thread
    }
}
```

### Key Points

* `run()` → contains the task
* `start()` → creates a new thread and calls `run()`
* Calling `run()` directly does **not** start a new thread

### Limitations

* Java does **not support multiple inheritance**
* Extending `Thread` restricts class extensibility

---

## 3.2 Implementing `java.lang.Runnable` Interface

### Concept

A class implements the **Runnable** interface and passes the object to a `Thread` instance.

**Implementing Multi-Threading Using `Runnable` Interface**
   1. Create a class implementing `Runnable`.
   2. Override `public void run()` with your thread logic.
   3. Create an object of your class:

      ```java
      MyRunnable m = new MyRunnable();
      ```
   4. Attach it to a Thread object:

      ```java
      Thread t = new Thread(m);
      ```
   5. Start the thread:

      ```java
      t.start();
      ```
      
### Syntax Example

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread is running using Runnable");
    }
}

public class TestRunnable {
    public static void main(String[] args) {
        MyRunnable r = new MyRunnable();
        Thread t = new Thread(r);
        t.start();
    }
}
```

### Advantages

* Supports **multiple inheritance**
* Better **object-oriented design**
* Preferred in **real-world applications**

---

## 4. Thread Execution and Life Cycle

### Thread Life Cycle States

Threads, like objects or real-world things, have **states** representing their current situation. For example:

* A person: standing, sitting
* A car: running, parked
 
Similarly, a thread can be in different states during its life cycle.

---

## **1. New State**

* **When it occurs:** When a thread object is created.
* **How to enter:** `Thread t = new Thread();`
* **Meaning:** Thread exists but has **not started yet**.

---

## **2. Runnable / Ready State**

* **When it occurs:** After calling `start()` on a thread.
* **Meaning:** Thread is **ready to run** and waiting for CPU scheduling.
* **Transition:** The JVM schedules it to run.

---

## **3. Running State**

* **When it occurs:** JVM calls the `run()` method.
* **Meaning:** Thread is **actively executing its task**.

---

## **4. Terminated / Dead State**

* **When it occurs:** Thread completes execution of `run()`.
* **Meaning:** Thread has **finished its task**.
* **Important:** A terminated thread **cannot be restarted**. To run the same task again, you must create a **new thread object**.

---

## **5. Waiting State**

* **When it occurs:** Thread is waiting for another thread to notify it for a resource. Waiting to acquire resource.
* **How:** Using `wait()` method.
* **Meaning:** Thread is **inactive but not terminated**, waiting for a condition or signal.

---

## **6. Timed Waiting / Sleep State**

* **When it occurs:** Thread is made to **pause for a specified time**.
* **How:** Using `sleep(milliseconds)` or `join(milliseconds)`.
* **Meaning:** Thread is temporarily inactive, then resumes automatically after the time expires.
* **Use Case:** Animations, controlling speed of operations, etc.

---

## **7. Blocked State**

* **When it occurs:** Thread is **trying to access a resource** that is locked by another thread.
* **Meaning:** Thread is waiting to **acquire a lock or monitor**.
* **Transition:** Once the resource is available, the thread continues execution(running).

---

### Diagram Concept

```
New → Runnable → Running → Terminated
           ↓
        Waiting / Blocked
```

### Example

```java
Thread t = new Thread();
t.start(); // Runnable
```

---

## 5. Thread Priorities

Threads in Java can have **priorities**, which help the JVM **scheduler** decide which thread should get more CPU time.

---

### **1. Ready Queue and Scheduler**

* All threads ready to run are placed in a **ready queue** by the JVM scheduler.
* **CPU executes only one thread at a time**.
* **Time sharing**: CPU time is divided among threads in slices (e.g., 1 second per thread in round-robin fashion).

---

### **2. Concept of Priority**

* Each thread can have a **priority value** from **1 to 10**.

  * **MIN_PRIORITY** = 1
  * **NORM_PRIORITY** = 5 (default)
  * **MAX_PRIORITY** = 10

* **Higher priority threads** get preference:

  * May be executed first.
  * May receive a **larger time slice**.
  * Lower priority threads may have to wait longer (**starvation** can occur if not managed properly).


### Example

```java
class PriorityThread extends Thread {
  private String threadName;

  PriorityThread(String name) {
    this.threadName = name;
  }

  public void run() {
    // The loop is just to give the scheduler a chance to show the priority effect
    for (int i = 0; i < 5; i++) {
      System.out.println(threadName + " running with priority: " + getPriority() + ", iteration: " + i);
    }
  }
}

public class ThreadPriorityExample {
  public static void main(String[] args) {
    PriorityThread t1 = new PriorityThread("HighPriorityThread");
    PriorityThread t2 = new PriorityThread("LowPriorityThread");

    // Set priorities using predefined constants or integer values (1-10)
    t1.setPriority(Thread.MAX_PRIORITY); // Value 10
    t2.setPriority(Thread.MIN_PRIORITY); // Value 1

    System.out.println(t1.threadName + " priority: " + t1.getPriority());
    System.out.println(t2.threadName + " priority: " + t2.getPriority());

    // Start the threads
    t2.start();
    t1.start();
  }
}

```

### Key Notes

* Higher priority threads **may** execute first
* Execution order is **not guaranteed**
* OS-dependent behavior

---

## 6. Thread Synchronization

### What is Synchronization?

**Synchronization** is the process of controlling access to shared resources to prevent data inconsistency.

### Problem: Race Condition

Occurs when multiple threads access shared data simultaneously.

### Example Without Synchronization

```java
class Counter {
    int count = 0;

    void increment() {
        count++;
    }
}
```

Multiple threads may produce incorrect results.

---

## 6.1 Synchronized Method

```java
synchronized void increment() {
    count++;
}
```

* Locks the object
* Only one thread executes at a time

---

## 6.2 Synchronized Block

```java
synchronized(this) {
    count++;
}
```

* More efficient
* Locks only critical code

---

## 7. Inter-Thread Communication

### Definition

**Inter-thread communication** allows threads to communicate and coordinate execution.

Java provides methods:

* `wait()`
* `notify()`
* `notifyAll()`

These methods belong to the **Object class**.

---

## 7.1 Producer–Consumer Problem (Case Study)

### Scenario

* **Producer** produces data
* **Consumer** consumes data
* Both share a common resource

### Example

```java
class Shared {
  int data;
  boolean available = false;

  synchronized void produce(int value) throws InterruptedException {
    while (available)
      wait();
    data = value;
    available = true;
    notify();
  }

  synchronized int consume() throws InterruptedException {
    while (!available)
      wait();
    available = false;
    notify();
    return data;
}
}
```

### Key Points

* `wait()` releases the lock
* `notify()` wakes up waiting thread
* Prevents unnecessary CPU usage

---

## 8. Deadlock

### What is Deadlock?

A **deadlock** occurs when two or more threads are waiting indefinitely for resources held by each other.

### Conditions for Deadlock

1. **Mutual Exclusion**
2. **Hold and Wait**
3. **No Preemption**
4. **Circular Wait**

---

## 8.1 Deadlock Example

```java
class DeadlockExample {
    static final Object A = new Object();
    static final Object B = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            synchronized (A) {
                synchronized (B) {
                    System.out.println("Thread 1");
                }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (B) {
                synchronized (A) {
                    System.out.println("Thread 2");
                }
            }
        });

        t1.start();
        t2.start();
    }
}
```

### Result

Both threads wait forever.

---

## 8.2 Deadlock Prevention Techniques

* **Avoid nested locks**
* Lock resources in **fixed order**
* Use **timeouts**
* Minimize synchronized blocks

---

## 9. Summary

### Key Takeaways

* **Threads** enable concurrent execution
* Threads can be created using:

  * `Thread` class
  * `Runnable` interface (preferred)
* **Thread life cycle** governs execution flow
* **Thread priority** influences scheduling
* **Synchronization** ensures data consistency
* **Inter-thread communication** coordinates threads
* **Deadlock** is a critical issue requiring careful design

---

## 10. Examination-Oriented Points

* Difference between `start()` and `run()`
* Thread vs Runnable
* Advantages of synchronization
* Producer–Consumer problem
* Causes and prevention of deadlock

---
