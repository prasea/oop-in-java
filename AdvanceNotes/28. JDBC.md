
# Introduction to Databases

### A. How Programs and Data Exist in a Computer

**Core Components**

* **Hard Disk (HDD)**: Permanent storage where programs and data files are saved.
* **RAM (Main Memory)**: Temporary working area where programs execute.
* **CPU**: Executes instructions of programs loaded into RAM.

**Key Idea**

* Programs (like Java `.class` files) and data are stored on the hard disk.
* When a program runs, it is loaded into RAM.
* Any data processing happens in RAM, not directly on the disk.


### B. Using Files in Java (File-Based Storage)

**What Java Files Are**

* Java programs can store data in files using the `java.io` package.
* Common tools:

  * `FileInputStream`
  * `FileOutputStream`
  * `RandomAccessFile`

**How Data Is Stored**

* The **programmer decides the format** of data storage.
* Data has **no inherent structure** unless the programmer enforces it.

**Example Problem**

* If a student record is stored as:

  ```
  Roll No â†’ Name â†’ Phone â†’ Branch
  ```
* It must be read in the **exact same order**.
* Reading incorrectly (e.g., reading name where roll number was stored) causes errors.

**Limitations of Files**

* Programmer must manually manage:

  * Data format
  * Data order
  * Data consistency
* Becomes **very difficult for large datasets**
* Error-prone and hard to maintain

**Conclusion**: Files are suitable for **small-scale data**, not large or complex systems.


### C. Why Databases Are Needed

**What a Database Is**

> A database is a collection of interrelated data permanently stored on disk, along with programs to manage and access that data.

**Important Concept**

* A database is itself a **program**:

  * Stored on disk
  * Runs in RAM
* It handles storage, organization, and retrieval of data automatically.


### D. How Databases Organize Data

**Tabular Structure**

* Data is stored in **tables** (rows and columns).

**Example Tables**

* **Student Table**

  * Roll Number | Name | Address | Branch
* **Department Table**
* **Faculty Table**

**Relationships**

* Tables can be related:

  * Student â†” Department
  * Faculty â†” Department

This is called **relational data organization**.

**Key Advantage**

* Programmers do **not** worry about how data is stored internally.
* The database engine handles structure and consistency.


### E. Retrieving Data Using SQL

**SQL (Structured Query Language)**

* Standard language used to:

  * Retrieve data
  * Insert data
  * Update data
  * Delete data

**Why SQL Matters**

* You donâ€™t manually read files.
* You simply write a **query**.
* The database returns the required result.


### F. Java and Databases: JDBC

**Problem**

* Java cannot directly access database storage.

**Solution**

* Java communicates with the database **through the database program**.

**This Mechanism Is Called**

> **JDBC â€“ Java Database Connectivity**

**What JDBC Does**

* Acts as a bridge between:

  * Java program
  * Database program
* Enables:

  * Storing data in databases
  * Retrieving data using SQL


### G. Files vs Database (Clear Comparison)

| Aspect             | Files               | Database              |
| ------------------ | ------------------- | --------------------- |
| Data Size          | Small               | Large                 |
| Structure          | Programmer-defined  | Table-based           |
| Complexity         | High for large data | Managed automatically |
| Query Support      | No                  | Yes (SQL)             |
| Data Relationships | Manual              | Built-in              |
| Reliability        | Low                 | High                  |


### H. Popular Database Programs

Some widely used database systems include:

* **Oracle** â€“ Commercial enterprise database
* **MySQL** â€“ Popular open-source database (now owned by Oracle)
* **Microsoft SQL Server** â€“ Enterprise database by Microsoft
* **SQLite** â€“ Lightweight, free database (used for learning)

Learning **one database + JDBC** makes it easier to work with others (only minor changes required).


## 2. Summary

* Programs and data are stored on disk but run in RAM.
* Java can store data using files, but file-based storage becomes complex for large data.
* Databases solve this by organizing data into tables with relationships.
* Databases use SQL to retrieve and manage data efficiently.
* Java accesses databases using **JDBC (Java Database Connectivity)**.
* Files are best for small data; databases are essential for large, structured, and reliable systems.
* Learning JDBC with one database (like SQLite) prepares you for all major databases.


# Database Terminology


|Roll |name     |City     |Deptno|
|---|---|---|---|
|1    |Ajay     |Delhi      |10
|2    |Vijay    |Kolkata    |10
|3    |Ajay     |Mumbai     |20
|4    |Ramesh   |Delhi      |30
|5    |Suneeta  |Lucknow    |40
|6    |Anita    |Kolkata    |30
|7    |Raj      |Jaipur     |30
|8    |Ali      |Lucknow    |40
|9    |Michael  |Cochin     |10
|10   |Pavan    |Vijaywada  |20
|11   |Suraj    |Hyderabad  |10
|12   |Altaf    |Bangaluru  |40
|13   |Ravi     |Indore     |20
|14   |Verma    |Delhi      |20
|15   |Sharma   |Vizag      |10


|Deptno  | Name
|--------|-----
|10      | CSE
|20      | ECE
|30      | Civil
|40      | Mech
### A. Tables, Relations, and RDBMS

**Tables**

* In databases, data is stored in **tables**.
* A table is also called a **relation**.

**RDBMS**

* DBMS is often called **RDBMS (Relational Database Management System)**.
* Why â€œrelationalâ€?

  * Because data is stored in **relations (tables)**
  * Tables can be **related to each other**


### B. Schema (Table Structure)

**Schema**

* The **schema** is the **definition/structure** of a table.
* It describes:

  * Column names
  * Data organization

**Example**

* **Students table schema**:

  * Roll Number
  * Name
  * City
  * Department Number
* **Department table schema**:

  * Department Number
  * Department Name

**Important Rule**

* Before inserting data into a table:

  1. Define the schema
  2. Then insert records according to that schema


### C. Fields (Columns)

* **Columns** in a table are called **fields**.
* Examples:

  * Roll Number
  * Name
  * City
  * Department Number

A field represents **one type of data** across all records.


### D. Records, Rows, and Tuples

* **Rows** represent individual entries in a table.
* A row is also called:

  * **Record**
  * **Tuple**

**Example**

```
Roll No: 7 | Name: Raj | City: Jaipur | Dept No: 30
```

This single row = **one student record**


### E. NULL Values and Uniqueness

**NULL**

* NULL means **no value is provided**
* Example: City is unknown â†’ City = NULL

**Uniqueness**

* Some fields may repeat:

  * Name â†’ duplicated
  * City â†’ duplicated
* Some fields must be unique:

  * Roll Number


### F. Primary Key

**Why Primary Key Is Needed**

* To uniquely identify **one and only one record**

**Primary Key Definition**

> A column that is **unique** and **not NULL**

**Examples**

* Students table â†’ Roll Number (Primary Key)
* Department table â†’ Department Number (Primary Key)

**Why Not Name or City?**

* They may contain duplicate values

Primary keys ensure **accurate searching and identification**


### G. Relationship Between Tables

**Why Relationships Are Needed**

* To avoid data duplication
* To keep data organized

**Example Relationship**

* Student table contains **Department Number**
* Department table stores department details

**How It Works**

1. Find studentâ€™s Department Number
2. Match it with Department table
3. Get Department Name

This links:

* Student â†’ Department


### H. Foreign Key

**Foreign Key Definition**

> A column in one table that refers to the **primary key of another table**

**Example**

* Department Number in Student table â†’ Foreign Key
* Department Number in Department table â†’ Primary Key

**Rule**

* Foreign key values must already exist in the referenced primary key

**Example Constraint**

* If Department 15 does not exist â†’ Student with Dept No 15 cannot be inserted


### I. Constraints

**What Are Constraints?**

* Rules enforced on table data to maintain correctness

**Types Discussed**

1. **Primary Key Constraint**

   * Must be unique
   * Must not be NULL
2. **Foreign Key Constraint**

   * Must reference an existing primary key
   * Ensures valid relationships
3. **Integrity Constraint**

   * Maintains consistency between related tables

Constraints protect the database from invalid data.


### J. Why This Matters for JDBC

* JDBC works with:

  * Tables
  * Primary keys
  * Foreign keys
  * Relationships
* Understanding these terms is essential before writing SQL queries from Java.


## 2. Summary

* Tables are also called **relations**
* Columns are called **fields**
* Rows are called **records or tuples**
* A **schema** defines the structure of a table
* **Primary key** = unique + not NULL
* **Foreign key** references a primary key in another table
* Relationships between tables are built using **primary keyâ€“foreign key**
* Primary key and foreign key are **constraints**
* These concepts are foundational for working with **JDBC and SQL**


# Introduction to SQL (DDL and DML)

The database used is **SQLite**, and the database file is `Univ.db` i.e. `.open Univ.db`


## SQL Command Categories

SQL commands are divided into **four categories**:

### 1. DDL â€“ Data Definition Language

Used to **define or modify the structure** of database objects.

Common DDL commands:

* `CREATE` â€“ create tables
* `DROP` â€“ delete tables
* `ALTER` â€“ modify table structure
* `TRUNCATE` â€“ remove all rows from a table
* `RENAME` â€“ rename a table (rarely used)

DDL defines the **schema (structure)** of tables.


### 2. DML â€“ Data Manipulation Language

Used to **manipulate the data inside tables**.

Common DML commands:

* `INSERT` â€“ add rows
* `DELETE` â€“ remove rows
* `UPDATE` â€“ modify existing rows


### 3. Query Language (DQL)

Used to **retrieve data**.

* `SELECT` â€“ fetch data from tables


### 4. DCL â€“ Data Control Language (Optional)

* Used for permissions and access control
* Not covered in this course (can be self-studied)


## Importance of Data Types

When creating tables, each column must have a **data type**.

Although SQLite is loosely typed, **defining data types is a best practice** for consistency and clarity.


## SQLite Data Types

### Common SQLite Data Types

| Data Type        | Meaning                                    |
| ---------------- | ------------------------------------------ |
| `NULL`           | No value                                   |
| `INTEGER`        | Whole numbers (no decimals)                |
| `REAL`           | Floating-point numbers                     |
| `TEXT`           | Strings (like Java `String`)               |
| `CHAR / VARCHAR` | Same as TEXT                               |
| `BLOB`           | Binary Large Object (images, audio, video) |

### About BLOB

* Used to store **raw binary data**
* Requires additional conversion logic
* Usually avoided unless necessary
* Often, file paths are stored instead


## Database Design Plan

### Tables Required

1. **Department**
2. **Students**

### Keys

* Department Table â†’ Primary Key: `deptno`
* Student Table â†’ Primary Key: `rollno`
* Student Table â†’ Foreign Key: `deptno`

### Table Creation Order

1. Create **Department table first**
2. Then create **Student table**

   * Because foreign key depends on primary key


## Creating Tables (DDL)

### Department Table

* Columns:

  * `deptno` â†’ INTEGER, PRIMARY KEY
  * `dname` â†’ TEXT

### Student Table

* Columns:

  * `rollno` â†’ INTEGER, PRIMARY KEY
  * `name` â†’ TEXT
  * `city` â†’ TEXT
  * `deptno` â†’ INTEGER (FOREIGN KEY â†’ Department.deptno)

**Foreign keys must be defined separately and correctly**
Syntax mistakes are common; SQLite error messages may be vague, so careful checking is required.


## Viewing & Creating Tables

Command:

```sql
sqlite>.open univ.db
sqlite>.tables
sqlite>create table dept(deptno integer primary key not null unique, dname text);

sqlite>create table students(roll integer primary key, name text, city text, deptno integer, foreign key(deptno) references dept(deptno));
```

Shows all tables created in the database.


## Inserting Data (DML)

### Inserting into Department Table

Two insertion styles are shown:

#### 1. Default Column Order

```sql
INSERT INTO dept VALUES (10, 'CSE');
INSERT INTO dept VALUES (20, 'ECE');
INSERT INTO dept VALUES (30, 'Civil');
INSERT INTO dept VALUES (40, 'Mech');
```

#### 2. Custom Column Order

```sql
INSERT INTO dept (dname, deptno)
VALUES ('Chemical Engineering', 50);
```

Column order in `VALUES` must match the column list.


## Retrieving Data (Query Language)

To view table contents:

```sql
SELECT * FROM dept;
```

This retrieves all rows and columns.


## Enabling Foreign Key Constraints in SQLite

**Important SQLite Behavior**

* Foreign key constraints are **OFF by default**
* Must be explicitly enabled

Command:

```sql
PRAGMA foreign_keys = ON;
```

Without this:

* Invalid foreign key values can be inserted
* Referential integrity is NOT enforced


## Inserting Data into Student Table

Example:

```sql
INSERT INTO students VALUES (1,'Ajay','Delhi',10);
INSERT INTO students VALUES (2,'Vijay','Kolkata',10);
INSERT INTO students VALUES (3,'Ajay','Mumbai',20);
INSERT INTO students VALUES (4,'Ramesh','Delhi',30);
INSERT INTO students VALUES (5,'Suneeta','Lucknow',40);
INSERT INTO students VALUES (6,'Anita','Kolkata',30);
INSERT INTO students VALUES (7,'Raj','Jaipur',30);
INSERT INTO students VALUES (8,'Ali','Lucknow',40);
INSERT INTO students VALUES (9,'Michael','Cochin',10);
INSERT INTO students VALUES (10,'Pavan','Vijaywada',20);
INSERT INTO students VALUES (11,'Suraj','Hyderabad',10);
INSERT INTO students VALUES (12,'Altaf','Bangaluru',40);
INSERT INTO students VALUES (13,'Ravi','Indore',20);
INSERT INTO students VALUES (14,'Verma','Delhi',20);
INSERT INTO students VALUES (15,'Sharma','Vizag',10);
```

Rules enforced:

* `rollno` must be unique
* `deptno` must exist in Department table
* Invalid department numbers will be rejected (after enabling FK)


## Integrity Constraints in Action

* Primary Key â†’ uniqueness + not null
* Foreign Key â†’ valid reference
* Together they enforce **referential integrity**


## Summary

* SQL commands are divided into **DDL, DML, Query Language, and DCL**
* DDL defines table structure
* DML inserts and modifies data
* `SELECT` retrieves data
* SQLite supports basic data types like INTEGER, TEXT, REAL, and BLOB
* Tables must be created in the correct order when foreign keys exist
* Foreign key constraints must be enabled explicitly in SQLite
* This setup prepares the database for **JDBC querying and integration**


# SQL (Select, From & Where clause)

## A. What Is SQL Query Language?

**SQL Query Language** is also known as:

* **Data Retrieval Language (DRL / DQL)**
* Commonly referred to as the **`SELECT` command**

Its purpose is to **retrieve data from database tables**.

In this lecture, queries are demonstrated using the **Students** and **Department** tables created earlier in **SQLite**.


## B. General Structure of a SELECT Query

A SQL query is written using **clauses in a fixed order**:

```
SELECT
FROM
[JOIN]
WHERE
GROUP BY
HAVING
ORDER BY
```

In this lecture, focus is on:

* `SELECT`
* `FROM`
* `WHERE`


## C. SELECT and FROM Clauses

### 1. SELECT Clause â€“ Column Filtering

Used to specify **which columns** you want to retrieve.

### 2. FROM Clause â€“ Table Selection

Used to specify **from which table** the data should be retrieved.

These two clauses **must be used together**.


### Examples

#### Retrieve one column

```sql
SELECT name FROM students;
```

Returns only student names.


#### Retrieve multiple columns

```sql
SELECT rollno, name FROM students;
```


#### Retrieve all columns

```sql
SELECT * FROM students;
```

`*` means **all columns**.


#### Retrieve data from another table

```sql
SELECT * FROM dept;
```


## D. DISTINCT Keyword (Removing Duplicates)

### Purpose

Removes **duplicate values** from the result set.


#### Example: Repeated department numbers

```sql
SELECT deptno FROM students;
```

Duplicates appear.


#### Remove duplicates

```sql
SELECT DISTINCT deptno FROM students;
```

Only unique department numbers are shown.


### DISTINCT with Multiple Columns

```sql
SELECT DISTINCT name, deptno FROM students;
```

Rows are considered duplicates **only if all column values match**.


## E. WHERE Clause â€“ Row Filtering

### Purpose

Filters **rows** based on conditions.

Think of it as:

* `SELECT` â†’ filters **columns**
* `WHERE` â†’ filters **rows**


### Basic Condition

```sql
SELECT * FROM students
WHERE city = 'Delhi';
```

Only students from Delhi are shown.


### NOT EQUAL

```sql
SELECT * FROM students
WHERE city <> 'Delhi';
```

All students except those from Delhi.


### Comparison Operators

| Operator | Meaning               |
| -------- | --------------------- |
| `=`      | Equal                 |
| `<>`     | Not equal             |
| `<`      | Less than             |
| `<=`     | Less than or equal    |
| `>`      | Greater than          |
| `>=`     | Greater than or equal |


### Example

```sql
SELECT * FROM students
WHERE deptno > 30;
```


## F. Logical Operators: AND, OR, NOT

### AND (Both conditions must be true)

```sql
SELECT * FROM students
WHERE deptno > 30 AND city = 'Lucknow';
```


### NOT

```sql
SELECT * FROM students
WHERE deptno > 30 AND NOT city = 'Lucknow';
```


### OR (Either condition can be true)

```sql
SELECT * FROM students
WHERE city = 'Delhi' OR city = 'Jaipur';
```


## G. LIKE Operator (Pattern Matching)

Used with **strings** and `%` wildcard.

### `%` â†’ any number of characters


### Starts with A

```sql
SELECT * FROM students
WHERE name LIKE 'A%';
```


### Ends with Y

```sql
SELECT * FROM students
WHERE name LIKE '%Y';
```


### Contains letter M

```sql
SELECT * FROM students
WHERE name LIKE '%M%';
```

Matches names containing `M` anywhere.


## H. BETWEEN Operator (Range Queries)

### Numeric Range

```sql
SELECT * FROM students
WHERE deptno BETWEEN 10 AND 30;
```

Includes **10 and 30**.


### Roll Number Range

```sql
SELECT * FROM students
WHERE rollno BETWEEN 5 AND 10;
```


## I. IN and NOT IN Operators

Used when checking **multiple values efficiently**.


### IN

```sql
SELECT * FROM students
WHERE city IN ('Delhi', 'Jaipur');
```

Same as:

```sql
WHERE city = 'Delhi' OR city = 'Jaipur'
```


### NOT IN

```sql
SELECT * FROM students
WHERE city NOT IN ('Delhi', 'Jaipur');
```

Excludes those cities.

`IN` is cleaner and faster when checking many values.


## J. Key Learning Strategy 

* Practice each query yourself
* Modify conditions
* Experiment with combinations
* Master `SELECT + WHERE` before moving forward

Upcoming topics:

* `JOIN`
* `GROUP BY`
* `HAVING`
* `ORDER BY`


## 2. Summary

* SQL Query Language is used for **data retrieval**
* `SELECT` filters columns, `WHERE` filters rows
* `DISTINCT` removes duplicates
* Conditions use comparison and logical operators
* `LIKE` enables pattern matching
* `BETWEEN` handles ranges
* `IN` simplifies multi-value conditions
* Mastering these basics is essential before learning **JOINs and aggregation**




# SQL (Join, Group By & Having clause)

## 1. ORDER BY Clause

### Purpose

The **ORDER BY** clause is used to **sort records** based on a column.

By default, sorting is:

* **Ascending order (ASC)**

You can explicitly specify:

* **ASC** â†’ Increasing / Alphabetical order
* **DESC** â†’ Decreasing / Reverse order


### Example 1: Sort Departments by Name

```sql
SELECT * FROM dept ORDER BY dname;
```

Departments appear in **alphabetical order**


### Example 2: Sort Departments in Reverse Order

```sql
SELECT * FROM dept ORDER BY dname DESC;
```

Departments appear in **descending order**


### Example 3: Sort Students by Name

```sql
SELECT name FROM students ORDER BY name;
```


### Example 4: Sort Students by Name (Descending)

```sql
SELECT * FROM students ORDER BY name DESC;
```

Entire row is displayed, but sorting is based on `name`.


### Example 5: Sort by City

```sql
SELECT * FROM students ORDER BY city DESC;
```

Records are arranged based on city name (reverse alphabetical order).


### Key Points

* Sorting happens **after filtering**
* Works on **any column**
* Can be used with `SELECT *` or specific columns


## 2. JOIN Concept (Combining Tables)

### Why JOIN is Needed

When data exists in **multiple tables**, JOIN allows you to **combine related rows**.

Example:

* `students` table has `deptno`
* `dept` table has `deptno` and `dname`

We want:

> Student â†’ Department Name


## 3. Cartesian Product (Wrong Way)

### Query

```sql
SELECT * FROM students, dept;
```

### What Happens?

* Every student row is combined with **every department row**
* If:

  * Students = 15 rows
  * Departments = 5 rows
* Result = **75 rows**

This is called a **Cartesian Product** âŒ
It has **no meaning** logically.


## 4. JOIN Using WHERE Clause

### Correct Way

```sql
SELECT * 
FROM students, dept
WHERE students.deptno = dept.deptno;
```

Only matching rows are combined
Foreign key matches primary key
Logical and meaningful result


## 5. JOIN Using JOIN Keyword (Preferred)

### Query

```sql
SELECT *
FROM students
JOIN dept
ON students.deptno = dept.deptno;
```

### Important Rule

* When using `JOIN`, **ON condition is mandatory**
* JOIN without condition is **invalid**


## 6. Table Alias (Renaming Tables)

### Purpose

* Makes queries **shorter**
* Improves **readability**


### Example with Alias

```sql
SELECT *
FROM students S, dept D
WHERE S.deptno = D.deptno;
```

`S` â†’ students
`D` â†’ department

Same result, cleaner query.


## 7. GROUP BY Clause

### Purpose

Groups rows based on a column.


### Example 1: Group by City

```sql
SELECT city
FROM students
GROUP BY city;
```

Each city appears **only once**


## 8. Aggregate Functions

Aggregate functions work **with GROUP BY**.

Common aggregate functions:

* `COUNT()`
* `SUM()`
* `AVG()`
* `MAX()`
* `MIN()`


### Example 2: Count Students per City

```sql
SELECT city, COUNT(*)
FROM students
GROUP BY city;
```

Output:

* Delhi â†’ 3
* Lucknow â†’ 2
* Kolkata â†’ 2
* Others â†’ 1


### Important Rule

When using `GROUP BY`:

* Columns in `SELECT` **must appear in GROUP BY**
* OR be part of an **aggregate function**

Invalid:

```sql
SELECT name, city FROM students GROUP BY city;
```


## 9. HAVING Clause

### Purpose

Applies **conditions on grouped data**

Difference:

* `WHERE` â†’ filters **rows**
* `HAVING` â†’ filters **groups**


### Example: Cities with â‰¥ 2 Students

```sql
SELECT city, COUNT(*)
FROM students
GROUP BY city
HAVING COUNT(*) >= 2;
```

Output:

* Delhi
* Lucknow
* Kolkata


### Rules of HAVING

* Used **only with GROUP BY**
* Conditions use **aggregate functions**


## 10. Clause Execution Order (Very Important)

SQL executes in this order:

1. FROM
2. JOIN
3. WHERE
4. GROUP BY
5. HAVING
6. SELECT
7. ORDER BY


## 11. Summary Table

| Clause   | Purpose        |
| -------- | -------------- |
| SELECT   | Choose columns |
| FROM     | Choose table   |
| WHERE    | Filter rows    |
| ORDER BY | Sort results   |
| JOIN     | Combine tables |
| GROUP BY | Group rows     |
| HAVING   | Filter groups  |


## 12. Instructorâ€™s Advice (Key Exam Tip)

> **Donâ€™t memorize â€” practice and observe output.**
> GROUP BY and HAVING become clear **only through usage**.

Try:

* Different columns
* Different aggregate functions
* Different conditions


# SQL Advanced Features: Aggregate Functions & Set Operations

## 1. Aggregate Functions

### What Are Aggregate Functions?

Aggregate functions perform **calculations on multiple rows** and return **a single value**.

They are commonly used with:

* `SELECT`
* Optionally with `GROUP BY`

These functions are **standard SQL** and work the same in SQLite, MySQL, Oracle, SQL Server, etc.

(Examples in the lecture are demonstrated using **SQLite**.)


## 2. COUNT() Function

### Count All Rows

```sql
SELECT COUNT(*) FROM students;
```

Returns total number of rows (students)


### Count Using Column Name

```sql
SELECT COUNT(rollno) FROM students;
```

Same result as `COUNT(*)`


### COUNT with DISTINCT

```sql
SELECT COUNT(DISTINCT name) FROM students;
```

Counts **unique names only**

**Why result is smaller?**

* Name **Ajay** appears twice
* DISTINCT removes duplicates


## 3. MAX() and MIN() Functions

### MAX Example

```sql
SELECT MAX(rollno) FROM students;
```

Finds the **largest numeric value**


### MIN Example

```sql
SELECT MIN(rollno) FROM students;
```

Finds the **smallest numeric value**


### Use Cases

* Highest marks
* Lowest salary
* Maximum price


## 4. SUM() and AVG() Functions

### SUM Example

```sql
SELECT SUM(rollno) FROM students;
```

Adds all roll numbers


### AVG Example

```sql
SELECT AVG(rollno) FROM students;
```

Calculates average

In real systems:

* SUM â†’ total marks
* AVG â†’ average score


## 5. Aggregate Functions with GROUP BY

### Rule (Very Important)

If a column appears in `SELECT`, it must:

* Appear in `GROUP BY`, **OR**
* Be inside an aggregate function


### Example: Max Roll Number Per City

```sql
SELECT MAX(rollno), city
FROM students
GROUP BY city;
```

Groups students by city
Finds highest roll number in each city


### Example: Count Students Per City

```sql
SELECT city, COUNT(*)
FROM students
GROUP BY city;
```

Result:

* Delhi â†’ 3
* Kolkata â†’ 2
* Lucknow â†’ 2
* Others â†’ 1


### Example: Sum per Group

```sql
SELECT city, SUM(rollno)
FROM students
GROUP BY city;
```

Demonstrates grouping + aggregation
Practical use: total marks per student / subject


## 6. Aggregate Functions Without GROUP BY

```sql
SELECT COUNT(*) FROM students;
```

Function applies to **entire table**

With `GROUP BY` â†’ works per group
Without `GROUP BY` â†’ works on whole table


## 7. Set Operations in SQL

Set operations combine results of **two SELECT queries**, similar to **mathematical set theory**.


## 8. UNION

### Purpose

Combines results of two queries
Removes duplicates automatically


### Example

```sql
SELECT * FROM students WHERE city='Delhi'
UNION
SELECT * FROM students WHERE city='Kolkata';
```

Combines students from both cities
No duplicates in final result


### UNION with Common Data

```sql
SELECT name FROM students WHERE city='Delhi'
UNION
SELECT name FROM students WHERE city='Mumbai';
```

Ajay appears **only once**, even though present in both cities


### UNION Rules

* Same number of columns
* Same data types
* Same column order

Invalid:

```sql
SELECT name FROM students
UNION
SELECT rollno, name FROM students;
```


## 9. INTERSECT

### Purpose

Returns **common values** from both queries


### Example

```sql
SELECT name FROM students WHERE city='Delhi'
INTERSECT
SELECT name FROM students WHERE city='Mumbai';
```

Result: `Ajay`
Only common name


## 10. EXCEPT (Difference)

### Purpose

Returns rows from **left query minus right query**


### Example

```sql
SELECT name FROM students WHERE city='Delhi'
EXCEPT
SELECT name FROM students WHERE city='Mumbai';
```

Output:

* Ramesh
* Verma

Ajay removed (common element)


## 11. Set Operation Summary

| Operation | Meaning                     |
| --------- | --------------------------- |
| UNION     | Combine + remove duplicates |
| INTERSECT | Common elements only        |
| EXCEPT    | Left side minus right side  |



## 12. Instructorâ€™s Practical Advice

> SQL cannot be learned by reading alone.
> **Create tables, run queries, observe results.**

Especially important for:

* GROUP BY
* HAVING
* Set operations



## 13. Summary (Quick Revision)

* Aggregate functions return **single values**
* Common aggregate functions:

  * COUNT, MAX, MIN, SUM, AVG
* GROUP BY divides data into groups
* Set operations combine query results
* UNION removes duplicates
* INTERSECT finds common rows
* EXCEPT subtracts sets
* Column count & data type must match in set operations


# SQL Subqueries & DML Commands (INSERT, DELETE, UPDATE)

## 1. Subqueries (Inner Queries)

### What Is a Subquery?

A **subquery** is a query written **inside another SQL query**.

* The **inner query** executes first
* Its result is passed to the **outer query**
* Also called **nested query**

(Examples are demonstrated using **SQLite**.)



## 2. Basic Subquery Example (Using `IN`)

### Step-by-step Logic

```sql
SELECT * 
FROM students
WHERE city IN (
    SELECT city 
    FROM students 
    WHERE name = 'Ajay'
);
```

### Execution Order

1. **Inner query executes first**

   ```sql
   SELECT city FROM students WHERE name='Ajay';
   ```

   Result:

   * Delhi
   * Mumbai

2. **Outer query executes**

   ```sql
   WHERE city IN ('Delhi','Mumbai')
   ```

### Meaning (Very Important)

> Find **all students who live in the same city as Ajay**

### Result Includes

* Ajay (Delhi)
* Ajay (Mumbai)
* Ramesh (Delhi)
* Verma (Delhi)



## 3. Subquery with Different Input Value

```sql
SELECT * 
FROM students
WHERE city IN (
    SELECT city 
    FROM students 
    WHERE name = 'Ali'
);
```

### Meaning

> Find all students who live in the same city as Ali

Ali â†’ Lucknow
Result â†’ Ali & Suneeta



## 4. Subquery Using `=` (Single-Value Subquery)

### Rule

* Use `=` when subquery returns **only one value**
* Use `IN` when subquery returns **multiple values**



### Example: Same Department as Ajay

```sql
SELECT * 
FROM students
WHERE deptno = (
    SELECT deptno 
    FROM students 
    WHERE name = 'Ajay'
);
```

### Meaning

> Find all students who belong to **Ajayâ€™s department**

Ajayâ€™s department = 10
Output â†’ Vijay, Michael, Suraj, Sharma



## 5. Subquery with Comparison Operators

### Example: Roll Number Comparison

```sql
SELECT * 
FROM students
WHERE rollno > (
    SELECT rollno 
    FROM students 
    WHERE name = 'Suraj'
);
```

### Meaning

> Find students whose roll number is **greater than Surajâ€™s roll number**

Surajâ€™s roll number = 11
Output â†’ Roll numbers 12â€“15



## 6. Subquery with Aggregate Functions

```sql
SELECT * 
FROM students
WHERE rollno > (
    SELECT AVG(rollno) 
    FROM students
);
```

### Execution Logic

1. Inner query finds average roll number (â‰ˆ 8)
2. Outer query selects students with roll number > average

### Meaning

> Find students whose roll number is **above average**



## 7. Subquery Rules Summary

| Rule                       | Explanation     |
| -------------------------- | --------------- |
| Inner query executes first | Always          |
| `IN`                       | Multiple values |
| `=`                        | Single value    |
| Aggregate allowed          | Yes             |
| Comparison operators       | `< > = <= >=`   |



## 8. DML (Data Manipulation Language)

### DML Commands

Used to **change data** inside tables:

1. `INSERT`
2. `DELETE`
3. `UPDATE`



## 9. INSERT Command

```sql
INSERT INTO dept
VALUES (60, 'Electrical and Electronics Engineering');
```

Adds a new department row



## 10. DELETE Command

```sql
DELETE FROM dept
WHERE dname = 'Electrical and Electronics Engineering';
```

### Important

* `WHERE` clause controls **which rows are deleted**
* Without `WHERE`, **entire table is deleted**

Dangerous without condition



## 11. UPDATE Command

### Example: Change Department Name

```sql
UPDATE dept
SET dname = 'Aeronautical Engineering'
WHERE deptno = 50;
```

### Meaning

> Update department name **only** where dept number is 50



## 12. DML Syntax Comparison

| Command | Uses `FROM` | Uses `SET` |
| ------- | ----------- | ---------- |
| INSERT  |           |          |
| DELETE  | âœ…           |          |
| UPDATE  |           | âœ…          |


## 13. Best Practice Advice (Instructor Insight)

* SQL **cannot be learned by watching only**
* Create tables
* Insert data
* Run queries
* Observe results

> Practice â†’ Observation â†’ Understanding


## 14. Summary (Quick Revision)

### Subqueries

* Query inside another query
* Inner executes first
* Can be used with:

  * `IN`
  * `=`
  * Comparisons
  * Aggregate functions

### DML

* `INSERT` â†’ add rows
* `DELETE` â†’ remove rows
* `UPDATE` â†’ modify rows
* Always use `WHERE` carefully

# JDBC Fundamentals & Driver Architecture

### What Problem Does JDBC Solve?

Databases such as **Oracle**, **MySQL**, **Microsoft SQL Server**, and SQLite store data and understand **SQL**.

However:

* Java programs **do not understand database internals**
* Databases **do not understand Java**
* A **communication layer** is required

**JDBC (Java Database Connectivity)** is that layer.


### High-Level JDBC Working Flow

```
Java Program
   â†“
JDBC Driver
   â†“
Database Engine
   â†“
Database Storage
```

This flow is universal across programming languagesâ€”not only Java.


### Core Components of a JDBC Program

Every JDBC program is built on **four mandatory components**:

#### 1. Driver

Acts as a **translator + connector** between Java and the database.

**Responsibilities:**

* Establishes the database connection
* Converts **Java data types â†” Database data types**

Example conversions:

| Database Type | Java Type                |
| ------------- | ------------------------ |
| INTEGER       | int                      |
| FLOAT         | float                    |
| TEXT          | String                   |
| NUMERIC       | BigDecimal / int / float |

> Java and databases use *similar but not identical* data types.


#### 2. Connection

* Represents a **live communication channel** between Java Program and Database Program.
* Created using the driver
* Provided by `java.sql.Connection`

> Without a connection, **nothing else works**


#### 3. Statement

Used to send **SQL queries** to the database.

Types of operations:

* `SELECT`
* `INSERT`
* `UPDATE`
* `DELETE`

Created **from the Connection object**


#### 4. ResultSet

* Holds the **output of SELECT queries**
* Acts like a **table in memory**
* Data is already converted into Java-compatible types by the driver


### JDBC Execution Lifecycle (Step-by-Step)

1. Load Driver
2. Establish Connection
3. Create Statement
4. Execute SQL Query
5. Receive ResultSet
6. Process Data

> This lifecycle is **conceptually identical** in Python, C#, PHP, etc.


## JDBC Driver Types (Most Important Exam Topic)

For every programming language to communicate with every database, you need driver. There will be many drivers. So Microsoft has introduced a solution. That solution is **ODBC(Open Database Connectivity)**


Java supports **four types of JDBC drivers**.


### Type-1 Driver: JDBCâ€“ODBC Bridge

**Key Concept:** Uses **ODBC (Open Database Connectivity)** by Microsoft

```
Java â†’ JDBC â†’ ODBC â†’ Database
```

#### Why ODBC Exists

* Every programming language + every database would otherwise need a separate driver
* ODBC acts as a **neutral middle layer**

#### Characteristics

* Partially Java, partially native (Windows-based)
* Requires ODBC drivers installed
* **Not pure Java**
* Platform dependent

**Deprecated** in modern Java versions


### Type-2 Driver: Native-API Driver

Uses **database-specific native libraries**. Initially Oracle was written in C and it provides interface or driver called OCI. Using it, the C or C++ program can talk to Oracle database program. 
Java program to talk to Oracle takes help of OCI and the driver code to communicate with OCI should be written in Java.

Example:

* Oracle â†’ OCI (Oracle Call Interface)
* SQLite â†’ native SQLite libraries

```
Java â†’ JDBC â†’ Native API â†’ Database
```

#### Characteristics

* Part Java, part native code
* Faster than Type-1
* Platform dependent
* Requires native libraries installed

**SQLite commonly uses Type-2**


### Type-3 Driver: Network Protocol Driver

Introduces a **middleware server** between Java Program and Database Program. 

```
Java â†’ JDBC â†’ Middleware Server â†’ Database
```

#### Characteristics

* Java talks only to middleware
* Middleware handles database specifics
* **Pure Java on client side**
* Supports multiple databases
* Adds network overhead


### Type-4 Driver: Thin Driver (Best & Most Used)

```
Java â†’ JDBC â†’ Database
```

#### Characteristics

* Fully written in Java
* No ODBC
* No native code
* Platform independent
* Best performance

Modern databases (including Oracle today) provide Type-4 drivers


### Driver Comparison Summary

| Driver Type | Java Only | Native Code | Platform Dependent | Status          |
| ----------- | --------- | ----------- | ------------------ | --------------- |
| Type-1      |         | âœ…           | âœ…                  | Deprecated      |
| Type-2      |         | âœ…           | âœ…                  | Limited use     |
| Type-3      | âœ…         |           |                  | Rare            |
| Type-4      | âœ…         |           |                  | **Recommended** |


## Summary (Quick Revision)

* JDBC enables Java programs to interact with databases using SQL
* Core JDBC components:

  * **Driver**
  * **Connection**
  * **Statement**
  * **ResultSet**
* Driver handles:

  * Connection establishment
  * Data type conversion
* JDBC driver types:

  * Type-1: JDBCâ€“ODBC Bridge
  * Type-2: Native API
  * Type-3: Network Protocol
  * Type-4: Thin (Pure Java)



# First JDBC Program: Java + SQLite

**From Driver Setup to Result Display**

Every JDBC program follows this **fixed sequence**:

1. Load JDBC Driver
2. Establish Database Connection
3. Create Statement
4. Execute SQL Query
5. Process ResultSet
6. Handle Exceptions

> ðŸ”‘ **Order matters** â€” skipping or rearranging steps causes runtime errors.


## Step 1: Downloading the SQLite JDBC Driver

### Why a Driver Is Required

* Java cannot communicate with SQLite directly
* The JDBC driver acts as the **communication bridge**

### Driver Type Used

* **Type-2 (Native API Driver)** for SQLite

### What You Download

* A `.jar` file (Java Archive). `sqlite-jdbc-3.30.1.jar`


## Step 2: Setting the Classpath

### Option A: Temporary (Command Prompt)

```bash
set classpath=C:\MyJava\sqlite-jdbc-3.30.1.jar;
```

### Option B: Permanent (Recommended)

1. Open **Environment Variables**
2. Create: `CLASSPATH = C:\MyJava\sqlite-jdbc-3.30.1.jar`

> If the classpath is incorrect, `ClassNotFoundException` will occur.


## Step 3: Writing the JDBC Program

### Import JDBC Classes

```java
import java.sql.*;
```


### Load the JDBC Driver

```java
Class.forName("org.sqlite.JDBC");
```

* Registers the driver with `DriverManager`
* Makes the driver available at runtime


### Establish Database Connection

```java
Connection con = DriverManager.getConnection(
    "jdbc:sqlite:C://SQLite//univ.db"
);
```

#### Key Rules for SQLite Connection String

* Use **forward slashes (`//`)**
* Do **not** use backslashes (`\`)
* Provide **absolute path** if database is not in working directory


### Create Statement

```java
Statement stm = con.createStatement();
```

* Statement is derived from Connection
* Used to execute SQL queries


### Execute SQL Query

```java
ResultSet rs = stm.executeQuery("select * from dept");
```

**No semicolon** (`;`) at the end of SQL inside Java strings


### Process ResultSet

```java
while (rs.next()) {
    int dnumber = rs.getInt("deptnumber");
    String dname = rs.getString("dename");

    System.out.println(dnumber + " " + dname);
}
```

**Important Points**

* `rs.next()` moves row by row
* Column names **must exactly match** database schema
* Use correct getter method:

  * `getInt()` â†’ INTEGER
  * `getString()` â†’ TEXT


### Exception Handling (Simplified)

```java
public static void main(String[] args) throws Exception
```

Handled exceptions:

* `ClassNotFoundException`
* `SQLException`

> In production code, you should **catch exceptions properly**, not throw them.


## Complete JDBC Program (Clean Version)

```java
import java.sql.*;

class Database {
  public static void main(String[] args) throws Exception {

    Class.forName("org.sqlite.JDBC");

    Connection con = DriverManager.getConnection(
        "jdbc:sqlite:C://SQLite//univ.db"
    );

    Statement stm = con.createStatement();

    ResultSet rs = stm.executeQuery("select * from dept");

    while (rs.next()) {
        int dnumber = rs.getInt("deptnumber");
        String dname = rs.getString("dename");

        System.out.println(dnumber + " " + dname);
    }

    con.close();
  }
}
```


## Common Errors & Their Meaning

### Database Not Found

```
SQLException: database not found
```

Fix: Provide correct **absolute path**


### Column Not Found

```
no such column: dname
```

Fix: Match column name **exactly** as defined in database


### Driver Not Found

```
ClassNotFoundException: org.sqlite.JDBC
```

Fix: Classpath not set correctly


## 2. Summary (Quick Revision)

* JDBC programs are **short but concept-heavy**
* Driver must be downloaded and added to classpath
* SQLite uses a **Type-2 JDBC driver**
* JDBC flow:

  * Driver â†’ Connection â†’ Statement â†’ ResultSet
* SQL syntax inside Java differs slightly (no semicolon)
* Most JDBC bugs are:

  * Path issues
  * Column name mismatches
  * Missing drivers

# JDBC: DriverManager, Connection, and ResultSet in java.sql pacakage

## 1. Key Interfaces and Classes in `java.sql`

| Type      | Name            | Purpose                              |
| --------- | --------------- | ------------------------------------ |
| Class     | `DriverManager` | Establishes connection to database   |
| Interface | `Connection`    | Represents the connection object     |
| Interface | `Statement`     | Executes SQL queries (covered later) |
| Interface | `ResultSet`     | Stores and navigates query results   |

---

## DriverManager: Connect Java to Database

* **Role:** Uses a JDBC driver to connect Java program to database.

* **How it works:**

  1. `Class.forName("org.sqlite.JDBC")` loads the driver class.

     * Creates an **anonymous object** in JVM.
     * DriverManager uses it to establish the connection.
  2. `DriverManager.getConnection(...)` returns a `Connection` object.

     * For SQLite, username/password is not needed.
     * URL example:

       ```java
       Connection con = DriverManager.getConnection("jdbc:sqlite:C://SQLite//univ.db");
       ```

* **DriverManager Methods**

  1. `getConnection(String url)`
  2. `getConnection(String url, String user, String password)`
  3. `getConnection(String url, Properties info)` â€“ optional properties for connection

---

## 3. Connection Interface: Handle Database Connection

* Obtained via `DriverManager.getConnection(...)`
* **Common Methods**

  | Method                      | Purpose                                                |
  | --------------------------- | ------------------------------------------------------ |
  | `createStatement()`         | Creates a `Statement` object to execute queries        |
  | `commit()`                  | Commits transactions (for DML: insert, update, delete) |
  | `setAutoCommit(true/false)` | Auto commit on/off                                     |
  | `close()`                   | Releases database resources                            |

> Always close the connection after use to free resources.

## 4. ResultSet: Access Query Results

* Represents a table of data returned from SQL queries.

* Cursor-based navigation: use `next()` to move row by row.

* **Accessing data**

  * By **column name**

    ```java
    int roll = rs.getInt("roll");
    String name = rs.getString("name");
    ```
  * By **column index** (starts at 1)

    ```java
    int deptNo = rs.getInt(4);
    ```

* **Common `ResultSet` getter methods**

  | Method        | Data Type    |
  | ------------- | ------------ |
  | `getInt()`    | INTEGER      |
  | `getString()` | TEXT/VARCHAR |
  | `getDouble()` | DOUBLE       |
  | `getFloat()`  | FLOAT        |
  | `getDate()`   | DATE         |

## 5. Sample JDBC Program (Student Table)

```java
import java.sql.*;

public class DatabaseDemo {
    public static void main(String[] args) throws Exception {
        // Load driver
        Class.forName("org.sqlite.JDBC");

        // Establish connection
        Connection con = DriverManager.getConnection(
            "jdbc:sqlite:C://SQLite//univ.db"
        );

        // Create statement
        Statement stmt = con.createStatement();

        // Execute query
        ResultSet rs = stmt.executeQuery("SELECT * FROM students");

        // Iterate through ResultSet
        while(rs.next()) {
            int roll = rs.getInt("roll");
            String name = rs.getString("name");
            String city = rs.getString("city");
            int deptNo = rs.getInt(4); // department number by index

            System.out.println(roll + " " + name + " " + city + " " + deptNo);
        }

        // Close resources
        rs.close();
        stmt.close();
        con.close();
    }
}
```

## 6. Important Notes

1. **Exceptions**

   * `ClassNotFoundException` â†’ if JDBC driver is missing
   * `SQLException` â†’ if database or table is not found
   * Can be handled with `try-catch` or `throws Exception` in main method.

2. **ResultSet navigation**

   * `next()` â†’ move cursor to next row
   * Returns `false` when no more rows

3. **Always release resources**

   * Close `ResultSet`, `Statement`, and `Connection` after use

## 7. Quick Debugging Tips

| Error                              | Likely Cause            | Solution                                       |
| ---------------------------------- | ----------------------- | ---------------------------------------------- |
| `ClassNotFoundException`           | Driver not in classpath | Add `.jar` to project libraries or CLASSPATH   |
| `SQLException: database not found` | Wrong DB path           | Use absolute path, double forward slashes      |
| `no such column: name`             | Column mismatch         | Match column name exactly, or use column index |

---

## 8. Best Practices

* Use **try-with-resources** to auto-close connections and statements
* Always **commit transactions** for DML
* Prefer **column names** for readability, indexes for performance if table structure is fixed
* Separate JDBC code into **utility classes** for cleaner architecture


# JDBC PreparedStatements in Java

In JDBC, **Statement** objects are used to execute SQL queries from Java programs. There are three main types:

1. **Statement** â€“ simple queries (SELECT, etc.)
2. **PreparedStatement** â€“ queries with parameters (dynamic input)
3. **CallableStatement** â€“ calls stored procedures in the database

## 1. Statement Interface

* **How to create:**

  ```java
  Statement stmt = con.createStatement();
  ```

* **Methods:**

  * `executeQuery(String sql)` â€“ for `SELECT` queries, returns `ResultSet`
  * `executeUpdate(String sql)` â€“ for DML queries (`INSERT`, `UPDATE`, `DELETE`)
  * `execute(String sql)` â€“ generic execution (returns boolean)

* **Limitations:**
  If your query has parameters (e.g., `WHERE dept_no = 10`) and you want to change it at runtime, you must **change the code and recompile**.

## 2. PreparedStatement Interface

* **Purpose:**
  Allows queries to have **placeholders** (`?`) so parameters can be set at runtime without modifying the code.

* **How to create:**

  ```java
  String query = "SELECT * FROM students WHERE dept_no = ?";
  PreparedStatement pstmt = con.prepareStatement(query);
  ```

* **Set parameter values:**

  ```java
  int deptNumber = 20;
  pstmt.setInt(1, deptNumber);  // 1 = first placeholder
  ```

  > Note: Placeholder numbering starts at **1**, not 0.

* **Execute the query:**

  ```java
  ResultSet rs = pstmt.executeQuery();
  ```

* **Advantages:**

  1. Can execute the same query multiple times with different parameters.
  2. Prevents SQL injection.
  3. Easier to read and maintain.

## 3. Example Program: Using PreparedStatement

```java
import java.sql.*;
import java.util.*;

public class PreparedDemo {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);

        // Load driver
        Class.forName("org.sqlite.JDBC");

        // Establish connection
        Connection con = DriverManager.getConnection(
            "jdbc:sqlite:C://SQLite//univ.db"
        );

        // Prepare statement with placeholder
        String query = "SELECT * FROM students WHERE dept_no = ?";
        PreparedStatement pstmt = con.prepareStatement(query);

        // Take department number as input
        System.out.print("Enter department number: ");
        int deptNumber = sc.nextInt();

        // Set parameter in query
        pstmt.setInt(1, deptNumber);

        // Execute query and get results
        ResultSet rs = pstmt.executeQuery();

        // Display results
        while (rs.next()) {
            int roll = rs.getInt("roll");
            String name = rs.getString("name");
            String city = rs.getString("city");
            int deptNo = rs.getInt("dept_no");
            System.out.println(roll + " " + name + " " + city + " " + deptNo);
        }

        // Close resources
        rs.close();
        pstmt.close();
        con.close();
        sc.close();
    }
}
```

* You can **reuse the same `PreparedStatement`** for different department numbers:

  ```java
  pstmt.setInt(1, 30);
  rs = pstmt.executeQuery();
  ```

## 4. CallableStatement Interface

* Used for **stored procedures** in the database.
* Example (generic):

  ```java
  CallableStatement cstmt = con.prepareCall("{call my_procedure(?, ?)}");
  cstmt.setInt(1, 10);
  cstmt.registerOutParameter(2, Types.VARCHAR);
  cstmt.execute();
  String result = cstmt.getString(2);
  ```
* **Note:** Not all databases support stored procedures. SQLite, for instance, does not.

## 5. Key Differences Between Statement and PreparedStatement

| Feature             | Statement                   | PreparedStatement             |
| ------------------- | --------------------------- | ----------------------------- |
| SQL with parameters | Not supported               | Supported using `?`           |
| Reusability         | Single-use                  | Multi-use                     |
| Security            | Prone to SQL injection      | Safe against SQL injection    |
| Performance         | Slower for repeated queries | Faster due to precompiled SQL |

## 6. Summary / Steps for PreparedStatement

1. Load JDBC driver: `Class.forName("org.sqlite.JDBC")`
2. Establish connection: `DriverManager.getConnection(...)`
3. Prepare statement with placeholders: `con.prepareStatement(query)`
4. Set parameters: `pstmt.setInt(index, value)`
5. Execute query: `ResultSet rs = pstmt.executeQuery()`
6. Read results: `rs.next()` and getters (`getInt`, `getString`)
7. Close resources: `rs.close()`, `pstmt.close()`, `con.close()`


# JDBC DML Operations

DML (Data Manipulation Language) operations allow you to **insert, update, or delete rows** in the database from a Java program.

Weâ€™ll focus on **SQLite** database (`univ` or `Unif`) and its tables: **department (DPT)** and **students**.

---

## 1. Insert Operation

### Using `Statement`

```java
Statement stm = con.createStatement();
stm.executeUpdate("INSERT INTO DPT VALUES(60, 'Chemical Engineering')");
```

* **Important notes:**

  * String values in SQL query should be in **single quotes** (`' '`) inside Java.
  * Integer values donâ€™t need quotes.
  * If you insert a **duplicate primary key**, it throws an exception:

    ```
    SQLite constraint: PRIMARY KEY constraint failed
    ```
  * After execution, always **close** statement and connection:

    ```java
    stm.close();
    con.close();
    ```

---

### Using `PreparedStatement` (Dynamic / Parameterized)

* Place **question marks `?`** for values to be filled at runtime.
* Example: Inserting a student into `students` table.

```java
String query = "INSERT INTO students VALUES(?, ?, ?, ?)";
PreparedStatement pstmt = con.prepareStatement(query);

Scanner sc = new Scanner(System.in);

System.out.println("Enter student data (roll, name, city, dept_no):");
int roll = sc.nextInt();
String name = sc.next();
String city = sc.next();
int deptNo = sc.nextInt();

// Set values in PreparedStatement
pstmt.setInt(1, roll);
pstmt.setString(2, name);
pstmt.setString(3, city);
pstmt.setInt(4, deptNo);

// Execute update
pstmt.executeUpdate();

pstmt.close();
con.close();
sc.close();
```

**Advantages of `PreparedStatement`:**

1. Allows **dynamic input** at runtime.
2. Prevents SQL injection.
3. Same query can be reused with different parameters.

---

## 2. Delete Operation

* Delete rows based on a condition.
* Example: Delete departments with `dept_no > 50`.

```java
Statement stm = con.createStatement();
stm.executeUpdate("DELETE FROM DPT WHERE dept_no > 50");
stm.close();
con.close();
```

* Deletes all matching rows in **one query**.
* Throws exception if table or connection issues occur.

---

## 3. Update Operation

* Update existing rows in a table.

```java
Statement stm = con.createStatement();
stm.executeUpdate(
    "UPDATE DPT SET DNAME = 'Chemical Engineering' WHERE DPTNO = 50"
);
stm.close();
con.close();
```

* Changes the department name of department number 50 to **Chemical Engineering**.
* Always ensure your **WHERE clause** is correct to avoid updating unwanted rows.

---

## 4. Key Notes

* For **DML queries (`INSERT`, `UPDATE`, `DELETE`)**, use:

  ```java
  executeUpdate()
  ```

* For **SELECT queries**, use:

  ```java
  executeQuery()
  ```

* **PreparedStatement** is preferred for:

  * Dynamic values
  * Preventing SQL injection
  * Reusing queries multiple times

* Always **close resources** (`ResultSet`, `Statement`, `PreparedStatement`, `Connection`) to prevent resource leaks.

### Example Flow Using PreparedStatement for Insert

1. Create a query with placeholders:

   ```java
   "INSERT INTO students VALUES(?, ?, ?, ?)"
   ```
2. Take input from the user using `Scanner`.
3. Set parameters in the `PreparedStatement`.
4. Execute using `executeUpdate()`.
5. Close all resources.

# JDBC DDL Operations

DDL (Data Definition Language) queries allow us to **create or delete database objects** such as tables. Unlike DML, these are **not frequent operations**, but they are useful for temporary or runtime tables.

## 1. Create Table

* Use `Statement` object to execute a DDL query.
* Method: `executeUpdate()` (used for both DML and DDL queries).

### Example: Create a temporary table `temp`

```java
// Assuming connection 'con' is already established
Statement stm = con.createStatement();

String createQuery = "CREATE TABLE temp (a INTEGER, b FLOAT)";
stm.executeUpdate(createQuery);

stm.close();
con.close();
```

* **Explanation:**

  * `a` â†’ Integer column
  * `b` â†’ Float column
  * Once executed, the table is created in the database.
* Can verify in SQLite prompt:

  ```sql
  .tables       -- shows all tables
  .schema temp  -- shows schema of temp table
  ```

## 2. Drop Table

* Dropping deletes a table permanently from the database.
* Use the same `Statement` and `executeUpdate()` method.

### Example: Drop the table `temp`

```java
Statement stm = con.createStatement();

String dropQuery = "DROP TABLE temp";
stm.executeUpdate(dropQuery);

stm.close();
con.close();
```

* Verifying in SQLite prompt:

  ```sql
  .tables  -- temp table will no longer be listed
  ```



## 3. Key Notes

1. **DDL queries are not used frequently** in Java programs because table creation is usually one-time.
2. Useful scenarios:

   * Creating **temporary tables** during runtime.
   * Deleting tables when application closes.
3. **Same queries** used in SQLite prompt can be executed through Java programs.



**Summary Table**

| Operation    | JDBC Method       | Example Query                            |
| ------------ | ----------------- | ---------------------------------------- |
| Create table | `executeUpdate()` | `CREATE TABLE temp (a INTEGER, b FLOAT)` |
| Drop table   | `executeUpdate()` | `DROP TABLE temp`                        |

