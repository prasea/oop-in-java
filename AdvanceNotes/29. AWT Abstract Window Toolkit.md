#  What is Graphical user interface

### Interface

* An interface is a **point of communication** between two entities
* In computing it is a way for users to interact with the computer system

### User Interface (UI)

* UI is the medium through which users communicate with a computer
* Two major types:
  * **CUI (Character User Interface)**
  * **GUI (Graphical User Interface)**

### Look and Feel
* The **visual appearance and behavior** of GUI components
* Varies across operating systems (Windows, macOS, Linux)

### Java GUI Frameworks

* **AWT** – Abstract Window Toolkit (oldest)
* **Swing** – Improved, richer GUI
* **JavaFX** – Modern, currently used framework


### What is an Interface?

An **interface** is a medium for communication.

* Users interact with a computer system
* The system provides services
* The interface acts as a **bridge** between user and system

When users interact → it is called a **User Interface**


###  Types of User Interfaces

####  Character User Interface (CUI)

* Interaction is done using **text commands**
* Output is also text-based
* Examples:

  * DOS (Disk Operating System)
  * Command Prompt
  * Terminal

Common CUI commands:

* `dir` → list files and directories
* `cls` → clear screen
* `cd` → change directory
* `dir *.class` → filter files using wildcards

* CUI is Fast & Lightweight bu Not user-friendly for beginners


####  Graphical User Interface (GUI)
* Interaction is done using **graphics**
* Uses:

  * Windows
  * Icons
  * Menus
  * Buttons
  * Mouse actions (click, drag, right-click)

Examples:

* Windows File Explorer
* macOS Finder
* Paint application

* GUI is Easy to use, Intuitive. It provides Visual feedback

###  CUI vs GUI (Clear Comparison)

| Feature     | CUI                     | GUI              |
| -- | -- | - |
| Interaction | Text commands           | Mouse & graphics |
| Output      | Character-based         | Visual           |
| Ease of use | Difficult for beginners | User-friendly    |
| Example     | DOS, Terminal           | Windows, macOS   |



###  Look and Feel in GUI

**Look and Feel** refers to:

* Window appearance
* Button style
* Menu placement
* Scroll bars
* Toolbar design

#### Windows Look and Feel

* Sharp edges
* Minimize / Maximize / Close buttons on right
* Title on left

#### macOS Look and Feel

* Soft edges
* Control buttons on left
* Title centered

Each operating system has its **own GUI style**


###  Can Java Create GUI Applications?

**Yes! Java fully supports GUI development**

Java provides **three GUI frameworks**:

####  AWT (Abstract Window Toolkit)

* First GUI framework in Java
* Simple and easy
* Limited components
* Platform-dependent
* Mostly outdated today

Best for learning fundamentals

####  Swing

* Advanced version of AWT
* Rich set of components
* Platform-independent
* Many legacy applications still use it

####  JavaFX

* Modern GUI framework
* Currently used
* Supports animations, media, CSS styling
* Preferred for new applications

###  Why Learn AWT First?

* Simple framework
* Easy to understand GUI basics
* Helps build foundation
* Makes Swing and JavaFX easier to learn later

Even though AWT and Swing are outdated, they are:

* Still available in Java
* Useful for understanding GUI concepts
* Important for exams and legacy systems

## Summary

* A **User Interface** allows users to communicate with a computer
* Interfaces are of two types: **CUI** and **GUI**
* GUI provides visual, user-friendly interaction
* **Look and Feel** defines the visual style of GUI components
* Java supports GUI programming via:

  * **AWT** (oldest, simple)
  * **Swing** (improved)
  * **JavaFX** (modern, preferred)
* Learning AWT first builds a strong foundation for GUI programming


# 2. Introduction to AWT

###  Why AWT is Called “Abstract”

AWT is called **Abstract Window Toolkit** because:

* It does **not define a fixed appearance**
* The **look and feel** of components depends on the OS
* Java internally maps AWT components to **native OS components**

Result:
A Java AWT application looks like a **native application** on every platform.

###  Window-Based Applications

* GUI applications are also called:

  * **Window-based applications**
  * **Windows applications**
* AWT provides:

  * Windows
  * Buttons
  * Text fields
  * Menus
  * Scroll bars

###  Frame Window (Main GUI Window)

A **Frame** represents a window with borders and includes components like
  * Title bar
  * Icon
  * Minimize / Maximize / Close buttons
* It acts as a **container**

**Frame contains other components**


###  AWT Components (Building Blocks)

| Component     | Purpose                              |
| - |  |
| Label         | Displays text                        |
| TextField     | Single-line input                    |
| TextArea      | Multi-line input                     |
| Button        | Push button                          |
| Checkbox      | Selectable option                    |
| CheckboxGroup | Radio buttons                        |
| Choice        | Dropdown list                        |
| List          | List box (single/multiple selection) |
| Scrollbar     | Scroll control                       |
| Canvas        | Drawing surface                      |

**Canvas**
Used for custom drawing (graphics, shapes, painting)

###  MenuComponent

AWT supports menu systems:

* `MenuBar`
* `Menu`
* `MenuItem`
* `CheckboxMenuItem`

Used for **pull-down menus** in applications

###  AWT Class Hierarchy (Conceptual View)

```
Object
 └── Component
      ├── Button
      ├── Label
      ├── TextComponent
      │    ├── TextField
      │    └── TextArea
      ├── Checkbox
      ├── Choice
      ├── List
      ├── Canvas
      ├── Scrollbar
      └── Container
           ├── Panel
           │    └── Applet
           └── Window
                ├── Frame
                └── Dialog
                     └── FileDialog
```

Important Observations:

* `Component` is the **core parent**
* `Container` allows nesting components
* `Frame` is most commonly used for desktop apps
* `Applet` is browser-based (now obsolete)



###  Desktop vs Browser-Based Applications

| Class  | Use Case                       |
|  |  |
| Frame  | Desktop GUI applications       |
| Applet | Browser-based GUI (deprecated) |

Modern Java no longer supports applets in browsers, but they exist for learning and legacy understanding.



###  Exploring Java AWT Documentation (JavaDocs)

* Official source: **Oracle Java Documentation**
* Package: `java.awt`
* Contains:

  * Interfaces
  * Classes
  * Methods
  * Fields

#### Commonly Seen Classes:

* `Button`
* `Frame`
* `Panel`
* `Canvas`
* `Color`
* `Font`
* `LayoutManagers` (FlowLayout, BorderLayout, CardLayout)

Tip:

> You don’t need to memorize methods—just know **what is possible**



###  Component Class – The Foundation

`Component` provides common functionality such as:

* Positioning (`getX()`, `getY()`)
* Size (`getWidth()`, `getSize()`)
* Appearance (`setBackground()`, `setForeground()`)
* Event handling:

  * MouseListener
  * KeyListener
  * FocusListener
* Visibility and enabling/disabling

Almost every GUI class inherits these capabilities
Other components add **few additional methods**


## Summary

* **AWT** is Java’s original GUI toolkit
* Called *abstract* because UI appearance depends on OS
* Provides native-looking GUI components
* Built around the `Component` class
* `Frame` is the main window container
* Components like Button, Label, TextField build the UI
* JavaDocs are essential for understanding available methods
* AWT is ideal for learning GUI fundamentals


# 3. Developing AWT App Method #1


###  Importing AWT Classes
`import java.awt.*;`


Best practice:

* Import **only required classes**
* `import java.awt.*` is acceptable for learning

###  Creating a Frame

* `Frame` is required for desktop GUI applications
* Constructor options:

  * No title
  * Title only
  * Title + GraphicsConfiguration

```java
Frame f = new Frame("My First App");
```


###  Making the Frame Visible

Just creating a Frame is not enough. You must explicitly make it visible `f.setVisible(true);`
Without this, **nothing appears on screen**

###  Setting Frame Size

Default frame size is very small. The  
`f.setSize(300, 300);`

* Width = 300 pixels
* Height = 300 pixels

```java 
import java.awt.*; 

public class FirstApp {
  public static void main(String[] args) {
    Frame f = new Frame("My First App");
    f.setVisibe(true);
  }
}
```

###  Important Observation: Closing the Frame

Clicking does **not close the application**. This requires **event handling** which will be covered later. For now, we stop program forcefully

###  Adding a Button
Button will not appear unless added to Frame


```java 
import java.awt.*; 

public class FirstApp {
  public static void main(String[] args) {
    Frame f = new Frame("My First App");
    Button b = new Button("OK");
    f.add(b);
    f.setSize(300 300);
    f.setVisibe(true);
  }
}
```

The Button Covers Entire Frame. Why?
* Default layout of Frame is `BorderLayout`
* Component added goes to **CENTER**, filling all space



###  Solution: Use FlowLayout

Components keep natural size
Appear left to right
```java 
import java.awt.*; 

public class FirstApp {
  public static void main(String[] args) {
    Frame f = new Frame("My First App");
    f.setLayout(new FlowLayout());

    Button b = new Button("OK");
    f.add(b);
    
    f.setSize(300 300);
    f.setVisibe(true);
  }
}
```


###  Adding Label and TextField

* Label → displays text
* TextField → single-line input
* `20` → number of columns


```java
import java.awt.*;

class MyFrameApp {
  public static void main(String[] args) {

    Frame f = new Frame("My First App");

    f.setLayout(new FlowLayout());

    Label l = new Label("Name:");
    TextField tf = new TextField(20);
    Button b = new Button("OK");

    f.add(l);
    f.add(tf);
    f.add(b);

    f.setSize(300, 300);
    f.setVisible(true);
  }
}
```

## Common Beginner Mistakes (Clarified)

| Mistake             | Reason                     |
| - | -- |
| Frame not visible   | `setVisible(true)` missing |
| Tiny window         | `setSize()` not called     |
| Button too large    | Layout not changed         |
| Button does nothing | No event handling          |
| Frame won’t close   | No window listener         |


## Summary

* AWT Frame is the base for desktop GUI applications
* Steps to build a frame-based app:

   Import AWT
   Create Frame
   Set Layout
   Create Components
  Add Components to Frame
  6. Set Size
  Make Visible
* Layout managers control component behavior
* Functionality requires **event handling**, which comes next

# 4. Developing AWT App Method #2

A **frame** is the main window of a GUI application in Java AWT.
All GUI components (labels, text fields, buttons) are placed inside a frame.


###  Two Ways to Use a Frame in Java AWT

| Approach                 | Description                                     | Relationship |
|  | -- |  |
| Create a `Frame` object  | Frame is used as an object inside another class | **has-A**    |
| Extend the `Frame` class | Your class itself becomes a frame               | **is-A**     |

###  is-A vs has-A Relationship

* **is-A relationship**

  * Achieved using **inheritance**
  * Example: `class MyFrame extends Frame`
  * Meaning: `MyFrame` **is a** `Frame`

* **has-A relationship**

  * Achieved using **object creation**
  * Example: `Frame f = new Frame()`
  * Meaning: the class **has a** `Frame`

This concept is fundamental in **Object-Oriented Programming (OOP)** and is often asked in exams.


## Method 1: Creating a Separate Frame Class (Recommended Design)

### Step 1: Create a Custom Frame Class

```java
class MyFrame extends Frame {
  Label l;
  TextField tf;
  Button b;

  public MyFrame() {
    super("My App"); // Calls Frame constructor to set Title of Frame

    setLayout(new FlowLayout());

    l = new Label("Name");
    tf = new TextField(20);
    b = new Button("OK");

    add(l);
    add(tf);
    add(b);
  }
}
```

### Key Design Principles

* GUI components are **declared as references**
* Objects are created **inside the constructor**
* Constructor automatically initializes the GUI
* Layout is set using `FlowLayout`

### Step 2: Main Method Controls the Frame

```java
public class FirstApp {
  public static void main(String[] args) {
      MyFrame f = new MyFrame();
      f.setSize(400, 400);
      f.setVisible(true);
  }
}
```

### Why This Is Good Design

* Separation of responsibilities
* Main method controls **visibility and size**
* Frame class focuses only on GUI construction
* Easy to extend later (event handling, more components)


## Method 2: Single-Class Approach (For Small Applications)

Instead of creating a separate frame class, the **application class itself extends `Frame`**.

### Example:

```java
class FirstApp extends Frame {
  Label l;
  TextField tf;
  Button b;

  public FirstApp() {
    super("My App");

    setLayout(new FlowLayout());

    l = new Label("Name");
    tf = new TextField(20);
    b = new Button("OK");

    add(l);
    add(tf);
    add(b);
  }

  public static void main(String[] args) {
    FirstApp f = new FirstApp();
    f.setSize(400, 400);
    f.setVisible(true);
  }
}
```
You can use Method 2 in Small applications but not on Large or scalable applications


## Important Clarifications

### TextField Size

```java
new TextField(20);
```

* **20 is the visible width**, not the maximum input length
* Users can type more characters than visible
* Text scrolls horizontally


### FlowLayout (Introduced, Explained Later)

* Places components **left to right**
* Automatically moves to the next line
* Default layout for `Frame`
* Simple and beginner-friendly

## Current Limitations

* Button does **not work yet**
* No event handling implemented
* This will be covered in upcoming lessons

## Summary

* Java AWT GUI applications revolve around the `Frame` class
* You can create a GUI using:

   **Separate Frame class** (best practice)
   **Single class extending Frame** (for small apps)
* Constructors are the **right place for GUI setup**
* `is-A` → inheritance, `has-A` → object usage
* `TextField` size controls visibility, not input length
* Event handling will be added later to make components interactive


# 5. Event Delegation Model

###  Component

A **component** is a graphical element that appears on the screen and can be placed inside a container.

**Examples of AWT Components:**

* `Button`
* `Checkbox`
* `RadioButton`
* `TextField`
* `Frame`
* `Window`
* `Panel`

Every GUI application is built using components.

###  Three Things Every Component Has

Every component has:

 **Properties**
   * Data members (size, color, label, state)

 **Methods**
   * Used to manipulate properties or perform actions

 **Events**
   * Generated when something happens to the component


###  Event

An **event** is an action or occurrence generated by a component.

**Examples:**

* Button click → `ActionEvent`
* Selecting an item in a list → `ItemEvent`
* Typing in a text field → `KeyEvent`
* Mouse movement → `MouseEvent`

**Components generate events — they do NOT handle them.**

## Event Delegation Model (Core Idea)

The **Event Delegation Model** is a mechanism where:

* A **component generates an event**
* The event is **delegated** to a **listener**
* The listener **handles** the event

Handling is delegated, not done by the component itself.


## Participants in Event Delegation Model

| Element         | Role                       |
|  | -- |
| Component       | Event Source               |
| Event Object    | Contains event information |
| Listener        | Handles the event          |
| Callback Method | Executed when event occurs |


## Real-Life Analogy (Very Important for Understanding)

### Shop & Customer Example

| Real Life        | Java Equivalent       |
| - |  |
| Shop             | Component             |
| Customer         | Listener              |
| Sale / New Stock | Event                 |
| SMS / Call       | Event Notification    |
| Buying Dress     | Callback Method       |
| Registration     | Listener Registration |


* Shop does **not** force you to buy
* You **register** to receive updates by giving contact details
* When an event occurs (sale/new stock), shop **notifies**
* You **respond** by buying

Same in Java:

* Component generates event
* Listener registers
* Event occurs
* Callback method executes


## Listener

A **listener** is a class that:

* Receives events
* Responds to events
* Implements a listener interface

Listeners are also called:
* Receiver
* Handler

In Java, we officially use the term **listener**.



## Callback Method

### What is a Callback Method?

A **callback method** is a method automatically invoked when an event occurs by the Java event system

This method is not called by us but is called by Java when the event happens

Example:

```java
public void actionPerformed(ActionEvent e)
```

## Listener Registration (Mandatory Step)

Before handling events:

* Listener must be **registered** with the component

Without registration → no event handling.

Example:

```java
button.addActionListener(this);
```

## Event Classes in Java

Java provides **event classes** inside `java.awt.event` package.


### Common Event Classes

* `ActionEvent`
* `AdjustmentEvent`
* `ComponentEvent`
* `FocusEvent`
* `InputEvent`
* `ItemEvent`
* `KeyEvent`
* `MouseEvent`

Each event object contains information about the event.

## Listener Interfaces in Java

For each event type, Java provides a **listener interface**.

### Common Listener Interfaces

* `ActionListener`
* `AdjustmentListener`
* `ComponentListener`
* `FocusListener`
* `ItemListener`
* `KeyListener`
* `MouseListener`

Listener interfaces contain **abstract callback methods**.

## Why Interfaces for Listeners?
When event occurs, a callback method will be called. That method mus be insider Handler. How can you can force any class have some method??
* Java enforces method implementation
* Ensures callback methods exist
* Enables polymorphism
* Supports loose coupling

A class **must implement** the listener interface to handle that event.

## Event Delegation Model – Flow Diagram (Conceptual)

```
Component (Button)
       |
       | generates event
       v
Event Object (ActionEvent)
       |
       | delegated to
       v
Listener (ActionListener)
       |
       | calls
       v
Callback Method (actionPerformed)
```

## Why Event Delegation Model is Used

* Better separation of concerns
* Component does not handle its own events
* Flexible and reusable design
* Easier to maintain and extend

This is why Java says **delegation**, not direct handling.

## Summary

* Components generate events
* Events represent user actions
* Listeners handle events
* Listener must be registered
* Callback methods are automatically invoked
* Events and listeners are predefined in Java
* Event Delegation Model improves modularity and design

# 6. When,  Which Event is Generated

## Overview: Event → Listener Mapping

Java categorizes events and provides:

* **Event classes** (what happened)
* **Listener interfaces** (who handles it)

Knowing **when** an event is generated is more important than memorizing names.

##  ActionEvent & ActionListener

### When is ActionEvent Generated?

* Button is pressed via Mouse click or Keyboard (SPACE / ENTER)
* Menu item is clicked
* Item in a list box is **double-clicked**
* ENTER key pressed inside a `TextField`


### Common Components

* `Button`
* `MenuItem`
* `TextField`

##  MouseEvent & MouseListener or MouseMotionListener

### When is MouseEvent Generated?

* Mouse click
* Double-click
* Mouse movement
* Mouse enters a component
* Mouse exits a component

Mostly handled by **containers** like `Panel`, `Frame`, `Window`.

##  KeyEvent & KeyListener

### When is KeyEvent Generated?

* Key is pressed
* Key is released
* Key is held down (typed)

Happens when keyboard input is given.


### Commonly Handled By

* `Frame`
* `Window`
* `Panel`

##  ItemEvent & ItemListener

### When is ItemEvent Generated?

* Checkbox selected or deselected
* Radio button selected
* Checkable menu item selected
* Item selected in list box
* Choice selected in drop-down list


### Common Components

* `Checkbox`
* `CheckboxGroup` (radio buttons)
* `List`
* `Choice`

## TextEvent & TextListener

### When is TextEvent Generated?

* Text is typed
* Text is modified programmatically
* Text changes in:

  * `TextField`
  * `TextArea`

Triggered on **text change**, not button press.


## 6. MouseWheelEvent & MouseWheelListener

### When is MouseWheelEvent Generated?

* Mouse wheel is rotated (scroll up/down)

Introduced later when mouse wheels became common.


## WindowEvent & WindowListener

### When is WindowEvent Generated?

* Window opened
* Window closed
* Window minimized (iconified)
* Window maximized (deiconified)
* Window activated or deactivated

Very important for handling **window close operations**.


## 8. ComponentEvent & ComponentListener

### When is ComponentEvent Generated?

* Component is shown or hidden
* Component is resized
* Component is moved

## 9. ContainerEvent & ContainerListener

### When is ContainerEvent Generated?

* Component added to a container
* Component removed from a container

Container = `Frame`, `Panel`, etc.


## Quick Revision Table (Exam Gold ⭐)

| Event           | Trigger                 | Listener           |
|  | -- |  |
| ActionEvent     | Button click, ENTER key | ActionListener     |
| MouseEvent      | Mouse click/move        | MouseListener      |
| KeyEvent        | Key press/release       | KeyListener        |
| ItemEvent       | Checkbox/List selection | ItemListener       |
| TextEvent       | Text change             | TextListener       |
| MouseWheelEvent | Scroll wheel            | MouseWheelListener |
| WindowEvent     | Open/close window       | WindowListener     |
| ComponentEvent  | Resize/show/hide        | ComponentListener  |
| ContainerEvent  | Add/remove component    | ContainerListener  |


## Important Conceptual Note

### Java vs JavaScript Event Naming

* **JavaScript:** `onclick`, `ondblclick`
* **Java:** Event classes + listener interfaces

Each language has its **own event-handling design**
Java uses **Event Delegation Model**


## Summary

* Events represent user or system actions
* Java categorizes events clearly
* Each event has a corresponding listener
* Correct listener selection is crucial
* Event Delegation Model separates event generation and handling


# 7. Button and ActionListener

We'll build an application that displays:
  * A **Label** showing a number (initially `0`)
  * A **Button** labeled `"Click"`
* Each time the button is clicked:
  * The label value increments by `1`
  * Acts as a **counter**

This application demonstrates:

* Button component
* ActionEvent
* ActionListener
* Event delegation in practice

## Components Required

| Component      | Purpose                |
| -- | - |
| Frame          | Main window            |
| Label          | Displays counter value |
| Button         | Generates ActionEvent  |
| ActionListener | Handles button click   |

## Design Decision

* Create a **custom frame class**
* Frame class will:

  * Extend `Frame`
  * Implement `ActionListener`
* Frame itself will act as **listener**

This follows **good object-oriented design**.

## Step 1: Import Required Packages

```java
import java.awt.*;
import java.awt.event.*;
```

* `java.awt` → GUI components
* `java.awt.event` → Event classes & listener interfaces

## Step 2: Create Custom Frame Class

```java
class MyFrame extends Frame implements ActionListener {
}
```

### Explanation

* `extends Frame` → MyFrame **is a** Frame
* `implements ActionListener` → MyFrame can handle ActionEvents


## Step 3: Declare Instance Variables

```java
int count = 0;
Label l;
Button b;
```

* `count` → stores counter value
* `Label` → displays count
* `Button` → triggers event

## Step 4: Constructor – GUI Initialization

```java
public MyFrame() {
    super("Button Demo");

    setLayout(new FlowLayout());

    l = new Label("     " + count);
    b = new Button("Click");

    add(l);
    add(b);

    b.addActionListener(this);
}
```

* `super("Button Demo")` sets frame title via parent constructor
* `FlowLayout` arranges components left to right
* `"     " + count` ensures label has enough width
* `addActionListener(this)` registers the listener

**Listener registration is mandatory**.

## Step 5: Implement Callback Method
Since ActionListener interface is implementd. We must override it's abstract method 

```java
public void actionPerformed(ActionEvent e) {
  count++;
  l.setText("     " + count);
}
```

* Automatically called when button is clicked
* Increments counter
* Updates label text

This is a **callback method**:

* You don’t call it
* Java calls it when event occurs

## Step 6: Main Method (Application Control)

* Creates frame object
* Sets size
* Makes frame visible

```java
public class ButtonDemo {
  public static void main(String[] args) {
    MyFrame f = new MyFrame();    
    f.setSize(400, 400);
    f.setVisible(true);
  }
}
```


[ButtonDemo.java]
```java 
import java.awt.*;
import java.awt.event.*; 

class MyFrame extends Frame implements ActionListener 
{

  int count = 0;
  Label l;
  Button b;
 
 public MyFrame() {
    super("Button Demo");

    setLayout(new FlowLayout());

    l = new Label("     " + count);
    b = new Button("Click");

    add(l);
    add(b);

    b.addActionListener(this);
  }

  public void actionPerformed(ActionEvent e) {
    count++;
    l.setText("     " + count);
  }
}
  
public class ButtonDemo {
  public static void main(String[] args) {
    MyFrame f = new MyFrame();    
    f.setSize(400, 400);
    f.setVisible(true);
  }
}

```
## Complete Event Handling Flow (Very Important)

```
Button Click
   ↓
ActionEvent Generated
   ↓
Event Delegated to ActionListener
   ↓
actionPerformed() Called
   ↓
Counter Incremented
   ↓
Label Updated
```

## Important Button Class Methods

| Method              | Purpose            |
| - |  |
| addActionListener() | Register listener  |
| getActionCommand()  | Get button label   |
| setLabel()          | Change button text |
| getLabel()          | Read button label  |

Useful when **multiple buttons share one listener**.

## Important Label Class Methods

| Method    | Purpose           |
|  | -- |
| setText() | Change label text |
| getText() | Read label text   |



## ActionEvent Object – Useful Methods

| Method             | Description                |
|  | -- |
| getActionCommand() | Button label               |
| getWhen()          | Time of event              |
| getModifiers()     | Modifier keys (Shift, Alt) |
| paramString()      | Debug info                 |

Mostly `getActionCommand()` is used in real applications.



## Why Button Doesn’t Close the Window?

* Window close handling requires **WindowListener**
This is expected behavior at this stage.


## Summary

* Button generates **ActionEvent**
* ActionEvent is handled by **ActionListener**
* Frame itself can act as a listener
* actionPerformed() is a callback method
* Event delegation separates event generation and handling
* Simple counter app demonstrates full event lifecycle


# 8. Checkbox, RadioButton and ItemListener

##  Introduction to Checkbox & Radio Button

In Java AWT, **Checkbox** and **Radio Button** are UI components used for **selection input**.

* A **Checkbox** allows **multiple selections**
* A **Radio Button** allows **only one selection at a time**

**Important fact:**
Java uses **the same `Checkbox` class** for both:

* Normal checkbox
* Radio button (when grouped)


##  Real-World Use Cases

Checkboxes are commonly used in:

* “I agree / I disagree” forms
* Saving passwords
* Selecting multiple preferences

Radio buttons are used when:

* Only **one option** must be selected
* Example: Gender, Payment Method, Language Choice


##  Application Requirement (Problem Statement)

* A **Frame**
* **Three Checkboxes**:

  * Java
  * Python
  * C#
* **One Label**


### Expected Behavior

| User Action          | Label Output        |
| -- | - |
| Select Java          | Java                |
| Select Java + Python | Java Python         |
| Deselect Java        | Python              |
| Deselect all         | Nothing Is Selected |



##  Required Java Components

| Component      | Purpose                 |
| -- | -- |
| `Frame`        | Main window             |
| `Label`        | Display selected items  |
| `Checkbox`     | User selection          |
| `FlowLayout`   | Arrange components      |
| `ItemListener` | Handle selection events |
| `ItemEvent`    | Detect select/deselect  |




Intial Label text → "Nothing Is Selected"

[CheckboxDemo.java]
```java 

import java.awt.*;
import java.awt.event.*;
class Frame1 extends  Frame implements ItemListener
{
  Label l;
  Checkbox c1, c2, c3;
  public Frame1()
  {
    super("Check Box Demo");
    l = new Label("Nothing is selected");
    c1 = new Checkbox("Java");
    c2 = new Checkbox("Python");
    c3 = new Checkbox("C#");
    
    //Registering Listener with corresponding component
    c1.addItemListener(this);
    c2.addItemListener(this);
    c3.addItemListener(this);
    setLayout(new FlowLayout());
    
    add(l);
    add(c1);
    add(c2);
    add(c3);
  }

  @Override
  public void itemStateChanged(ItemEvent e) {
    String output = "";
    if(c1.getState())
      output += " "+c1.getLabel();
    if(c2.getState())
      output += " "+c2.getLabel();
    if(c3.getState())
      output += " "+c3.getLabel();
    if(output.isEmpty())
      output = "Nothing is selected";
    l.setText(output);
  }
}
public class CheckBoxDemo {
  public static void main(String[] args) {
    Frame1 f1 = new Frame1();
    f1.setSize(400, 400);
    f1.setVisible(true);
  }
}
```

## Event Handling Concept

### Why ItemListener?

Whenever a checkbox is Selected or Deselected, an **ItemEvent** is generated. To handle it, we use `ItemListener`


## ItemListener Interface

* It contains **only one method**:

```java
public void itemStateChanged(ItemEvent e)
```

This method is **automatically called** whenever a checkbox state changes

## Important ItemEvent Methods

| Method                | Description                  |
|  | - |
| `getItem()`           | Returns the checkbox clicked |
| `getStateChange()`    | SELECTED / DESELECTED        |
| `getItemSelectable()` | Whether selectable           |
| `paramString()`       | Debug information            |

**Most useful approach:**
Instead of using `ItemEvent e`, directly ask the checkbox:

```java
checkbox.getState(); // true or false
```


## 8. Key Checkbox Methods

| Method              | Purpose                 |
| - | -- |
| `getState()`        | Check selected or not   |
| `getLabel()`        | Get checkbox text       |
| `setState(true)`    | Select programmatically |
| `addItemListener()` | Register event listener |


## Core Logic (Checkbox Handling)

### Step-by-Step Logic:

 Create an empty string
 Check each checkbox state
 If selected → append its label
 If nothing selected → show default message
Update label text

### Pseudocode

```java
String str = "";

if (c1.getState()) str += " " + c1.getLabel();
if (c2.getState()) str += " " + c2.getLabel();
if (c3.getState()) str += " " + c3.getLabel();

if (str.equals(""))
    str = "Nothing Is Selected";

label.setText(str);
```

## Registering the Listener

Each checkbox must **notify the listener**:

```java
caddItemListener(this);
caddItemListener(this);
caddItemListener(this);
```

Why?

* So the frame gets notified when a checkbox changes

## Converting Checkbox → Radio Button

Checkboxes become **radio buttons** when grouped using:

```java
CheckboxGroup
```

## CheckboxGroup (Radio Button Logic)

### Steps:

 Create a CheckboxGroup
 Pass it to each checkbox constructor

```java
CheckboxGroup cg = new CheckboxGroup();

Checkbox c1 = new Checkbox("Java", cg, false);
Checkbox c2 = new Checkbox("Python", cg, false);
Checkbox c3 = new Checkbox("C#", cg, false);
```

* Only **one checkbox** can be selected
* Selecting one **automatically deselects others**
* Cannot deselect all (one always stays selected)

* If **all are set `false`**, none selected initially
* If **multiple set `true`**, last one becomes selected
* Same `ItemListener` logic works for both checkbox & radio button


[RadioDemo.java]
```java 

import java.awt.*;
import java.awt.event.*;
class Frame1 extends  Frame implements ItemListener
{
  Label l;
  Checkbox c1, c2, c3;
  CheckboxGroup cbg;

  public Frame1()
  {
    super("Check Box Demo");
    l = new Label("Nothing is selected");

    cbg = new CheckboxGroup();

    c1 = new Checkbox("Java", false, cbg);
    c2 = new Checkbox("Python", false, cbg);
    c3 = new Checkbox("C#", false, cbg);
    
    //Registering Listener with corresponding component
    c1.addItemListener(this);
    c2.addItemListener(this);
    c3.addItemListener(this);
    setLayout(new FlowLayout());
    
    add(l);
    add(c1);
    add(c2);
    add(c3);
  }

  @Override
  public void itemStateChanged(ItemEvent e) {
    String output = "";
    if(c1.getState())
      output += " "+c1.getLabel();
    if(c2.getState())
      output += " "+c2.getLabel();
    if(c3.getState())
      output += " "+c3.getLabel();
    if(output.isEmpty())
      output = "Nothing is selected";
    l.setText(output);
  }
}
public class RadioDemo {
  public static void main(String[] args) {
    Frame1 f1 = new Frame1();
    f1.setSize(400, 400);
    f1.setVisible(true);
  }
}
```


# 9. TextField & TextEvent


A **TextField** is a component that allows **single-line user input**.
It can be used for:

* Entering text
* Password input (masking input using echo characters)
* Capturing **real-time typing** events

##  Application Requirements

* **One TextField** of size 20
* **Two Labels**:

  * `Label1` → updates while typing
  * `Label2` → updates only after **Enter key**

**Behavior:**

| User Action              | Label Output                                    |
|  | -- |
| Typing H → e → l → l → o | Label1 updates in real-time                     |
| Press Enter              | Label2 updates with complete text               |
| Optional: Mask input     | TextField shows `*` instead of typed characters |


```java 
import java.awt.*; 
import java.awt.event.*; 

class MyFrame extends Frame 
{
  Label l1, l2; 
  TextField tf; 

  public MyFrame() {
    super("TextField Demo"); 
    l1 = new Label("No Text is Entered Yet");
    l2 = new Label("Enter key is not yet hit");
    tf = new TextField(20);

    setLayout(new FlowLayout()); 
    add(l1); 
    add(tf); 
    add(l2); 
  }
}
```

###  Events Associated with TextField

| Event Type      | Trigger                  | Listener Interface | Callback Method                   |
|  |  |  |  |
| **TextEvent**   | Typing in TextField      | `TextListener`     | `textValueChanged(TextEvent e)`   |
| **ActionEvent** | Press Enter in TextField | `ActionListener`   | `actionPerformed(ActionEvent ae)` |


###  Important TextField Methods

| Method                | Purpose                                    |
|  |  |
| `getText()`           | Returns current text in TextField          |
| `setText(String s)`   | Sets/updates text in TextField             |
| `setEchoChar(char c)` | Masks input with a character (e.g., `'*'`) |

> **Tip:** Use `setEchoChar('*')` to make a password field.


## Event Handling

### Step 1: Implement Listeners

```java
class MyFrame extends Frame implements TextListener, ActionListener
```

### Step 2: Override Callback Methods

**TextListener (real-time typing):**

```java
public void textValueChanged(TextEvent te) {
  label1.setText(tf.getText()); // update Label1 while typing
}
```

**ActionListener (Enter key):**

```java
public void actionPerformed(ActionEvent ae) {
  label2.setText(tf.getText()); // update Label2 on Enter
}
```

### Step 3: Register Listeners

```java
tf.addTextListener(this);
tf.addActionListener(this);
```

[TextFieldDemo.java]
```java 
import java.awt.*; 
import java.awt.event.*; 

class MyFrame extends Frame implements TextListener, ActionListener
{
  Label l1, l2; 
  TextField tf; 

  public MyFrame() {
    super("TextField Demo"); 
    l1 = new Label("No Text is Entered Yet");
    l2 = new Label("Enter key is not yet hit");
    tf = new TextField(20);

    tf.addTextListener(this);
    tf.addActionListener(this);

    setLayout(new FlowLayout()); 
    add(l1); 
    add(tf); 
    add(l2); 
  }
  public void textValueChanged(TextEvent te) {
    l1.setText(tf.getText()); // update Label1 while typing
  }

  public void actionPerformed(ActionEvent ae) {
    l2.setText(tf.getText()); // update Label2 on Enter
  }
}
```

## 6. Avoiding “Leaking `this`” Warning

**Problem:** Passing `this` (the frame) to listeners inside the constructor may give a warning (`reference to incomplete object`).

**Solution:** Use an **inner class** as a handler:

```java
class Handler implements TextListener, ActionListener {
  public void textValueChanged(TextEvent te) {
      labelsetText(tf.getText());
  }
  public void actionPerformed(ActionEvent ae) {
      labelsetText(tf.getText());
  }
}

// Register inner class as listener
Handler h = new Handler();
tf.addTextListener(h);
tf.addActionListener(h);
```

This resolves warnings and is a **clean coding practice**.

[TextFieldDemo.java]
```java 
import java.awt.*; 
import java.awt.event.*; 

class MyFrame extends Frame 
{
  Label l1, l2; 
  TextField tf; 

  public MyFrame() {
    super("TextField Demo"); 
    l1 = new Label("No Text is Entered Yet");
    l2 = new Label("Enter key is not yet hit");
    tf = new TextField(20);

    Handler h = new Handler();
    tf.addTextListener(h);
    tf.addActionListener(h);

    setLayout(new FlowLayout()); 
    add(l1); 
    add(tf); 
    add(l2); 
  }

  class Handler implements TextListener, ActionListener {
    public void textValueChanged(TextEvent te) {
        l1.setText(tf.getText());
    }
    public void actionPerformed(ActionEvent ae) {
        l2.setText(tf.getText());
    }
  }
}
```


### Optional Feature: Password Field

* Mask the TextField using:

```java
tf.setEchoChar('*');
```

* Now typed letters appear as asterisks, while the Label still shows actual input.



## Summary & Key Points

 **TextField** allows single-line input.
 **TextEvent** → fires **while typing**.
 **ActionEvent** → fires **on pressing Enter**.
 Use `TextListener` for real-time updates, `ActionListener` for Enter-key events.
`getText()`, `setText()`, `setEchoChar()` are essential methods.
6. Inner classes are preferred to **avoid warnings** when registering listeners in constructor.
Can easily create **password fields** by setting echo character.


# 10. TextArea Operations

* **TextArea** is an AWT component that allows **multi-line text input**.
* Can be used for creating **notepad-like applications**.
* Supports **scrolling**, text selection, and text editing operations.

##  Application Requirements

**UI Components:**

* **Label (l)** → Display selected text
* **TextField (tf)** → Input text to append/insert into TextArea
* **TextArea (ta)** → Multi-line editable area (10 rows × 30 columns)
* **Button (b)** → Trigger action (append, insert, or get selected text)

**Layout:** FlowLayout to arrange components horizontally/vertically.

##  TextArea Key Methods

| Method                      | Purpose                                      |
|  | -- |
| `getText()`                 | Returns all text in the TextArea             |
| `getSelectedText()`         | Returns currently selected portion of text   |
| `append(String s)`          | Adds text at the **end** of TextArea         |
| `insert(String s, int pos)` | Inserts text at **specified caret position** |
| `getCaretPosition()`        | Returns current cursor (caret) position      |
| `setText(String s)`         | Replace all text in TextArea with `s`        |

> **Note:** Caret = Cursor in the TextArea where typing or insertion occurs.

[TextAreaDemo.java]
```java 
import java.awt.*; 
import java.awt.event.*; 

class MyFrame extends Frame{
  Label label; 
  TextArea textArea; 
  Button button; 
  TextField textField; 

  public MyFrame() {
    super("Text Area Demo");

    label = new Label("No Text Entered"); 
    textArea = new TextArea(10, 30); 
    textField = new TextField(20); 
    button = new Button("Click"); 

    setLayout(new FlowLayout()); 

    add(textArea); 
    add(label);
    add(textField); 
    add(button);
  }
}
```


##  Event Handling

**Goal:** Perform actions when the button is clicked.

### Step 1: Implement `ActionListener`

```java
class MyFrame extends Frame implements ActionListener
```

### Step 2: Override `actionPerformed` Method

```java
public void actionPerformed(ActionEvent ae) {
  // Example 1: Get selected text
  label.setText(ta.getSelectedText());

  // Example 2: Append text from TextField
  ta.append(tf.getText());

  // Example 3: Insert text at caret position
  ta.insert(tf.getText(), ta.getCaretPosition());
}
```

### Step 3: Register Listener

```java
b.addActionListener(this);  // Button click triggers actionPerformed
```

## Demonstration Scenarios

| Action                                                      | Method Used                                   | Result                           |
| -- |  | -- |
| Select a portion of TextArea text → Click button            | `getSelectedText()`                           | Label displays selected text     |
| Enter text in TextField → Click button                      | `append(tf.getText())`                        | Text is added at end of TextArea |
| Enter text in TextField → Click button with caret somewhere | `insert(tf.getText(), ta.getCaretPosition())` | Text inserted at cursor position |

> Tip: This allows **dynamic editing**, similar to a notepad.



# 11. ListBox and Choice

* **ListBox (List)**: A component that can display **multiple items** at once.

  * Can allow **single** or **multiple selections**.
  * Supports **scrolling** when items exceed visible rows.
  * Similar to check box but used to display many options.

* **Choice**: A **dropdown box** component.

  * Allows **only one selection** at a time.
  * Similar to radio buttons but used to display many options.

* **Event Types**:

  * **ItemEvent** → Generated when selecting/deselecting an item.
  * **ActionEvent** → Generated when selecting an item and pressing **Enter**.

##  Key Differences Between List and Choice

| Feature       | ListBox                 | Choice                     |
| - | -- | -- |
| Selection     | Multiple or single      | Single only                |
| Display       | Multiple rows visible   | Dropdown, only one visible |
| Similar To    | Checkboxes              | Radio buttons              |
| Event Support | ItemEvent & ActionEvent | ItemEvent (mainly)         |


##  Application Setup

**Components Used**:

* `List list` → List box for days of the week
* `Choice choice` → Dropdown for months
* `TextArea textArea` → Display selected items

**Constructor Example**:

```java
list = new List(4, true);   // 4 visible rows, multiple selection allowed
choice = new Choice();         // Single selection dropdown
textArea = new TextArea(20, 30); // 20 rows, 30 columns
```

**Adding Items**:

```java
// List items
list.add("Monday");
list.add("Tuesday");
// ... add other days

// Choice items
choice.add("January");
choice.add("February");
// ... add other months
```

**Adding Components to Frame**:

```java
setLayout(new FlowLayout());
add(list);
add(choice);
add(textArea);
```


##  Event Handling

### 1 Implementing Listeners

```java
class MyFrame extends Frame implements ItemListener, ActionListener
```

### 2 ItemEvent Handling

* **Goal**: Show selected item from ListBox or Choice in TextArea.
* Use `getSource()` to determine which component triggered the event.

```java
public void itemStateChanged(ItemEvent ie) {
  if (ie.getSource() == list) {
    textArea.setText(list.getSelectedItem()); // ListBox selection
  } else if (ie.getSource() == choice) {
    textArea.setText(choice.getSelectedItem()); // Choice selection
  }
}
```

**Registering Listeners**:

```java
list.addItemListener(this);
choice.addItemListener(this);
```

### 3 ActionEvent Handling (ListBox)


**Register Action Listener**:

```java
list.addActionListener(this);
```
* **Goal**: Display **all selected items** from a multi-select ListBox into TextArea.

```java
public void actionPerformed(ActionEvent ae) {
  String[] selected = L.getSelectedItems();
  String text = "";
  for (String item : selected) {
    text += item + "\n";
  }
  textArea.setText(text);
}
```

## Important ListBox Methods

| Method                                      | Purpose                                         |
| - | -- |
| `add(String item)`                          | Add item to list (deprecated in newer versions) |
| `getItem(int index)`                        | Get item by index                               |
| `getItemCount()`                            | Total number of items                           |
| `getSelectedItem()`                         | Returns selected item (single selection)        |
| `getSelectedItems()`                        | Returns all selected items (multiple selection) |
| `getSelectedIndex()`                        | Returns index of selected item                  |
| `getSelectedIndexes()`                      | Returns indices of all selected items           |
| `remove(String item)` / `remove(int index)` | Remove an item                                  |
| `deselect(int index)`                       | Deselect an item programmatically               |
| `select(int index)`                         | Select an item programmatically                 |
| `setMultipleSelections(boolean flag)`       | Enable/disable multi-selection mode             |

> **Note:** Avoid deprecated methods such as `addItem(String)`, as future Java versions may not support them.


## Practical Tips

 **Multiple Selection in ListBox**:

   * **Shift + Click** → Select a continuous range
   * **Ctrl + Click** → Select non-continuous items

 **Choice** is always single selection; cannot select multiple items.

 **TextArea Display**:

   * Clears previous content when a new item is selected.
   * Can be used to display **selected items dynamically**.

 **Event Strategy**:

   * **ItemListener** → Updates TextArea immediately on selection.
   * **ActionListener** → Use for multi-select actions (press Enter to show all selections).



## Summary

* **ListBox**: For multiple options, supports multiple selections and events.
* **Choice**: For single selection dropdowns.
* **Event Handling**: ItemEvent + ActionEvent in ListBox, ItemEvent in Choice.
* **TextArea**: Used to display dynamically selected items.
* Avoid deprecated methods for future compatibility.



# 12. Scrollbar and AdjustmentEvent

* **Scrollbar**: A GUI component used to **select values** by moving a **tracker (thumb)**.
* Can be **horizontal** or **vertical**.
* Generates **AdjustmentEvent** when the value changes.



##  Parts of a Scrollbar

 **Tracker (Thumb)**: The movable button used to set a value.
 **Minimum Value**: Left/top end of the scrollbar (default usually 0).
 **Maximum Value**: Right/bottom end of the scrollbar.
 **Current Value**: Position of the tracker.
**Unit Increment/Decrement**: Small steps by clicking arrows.
6. **Block Increment/Decrement**: Larger steps by clicking inside the track.


##  Use Case: RGB Color Mixer

* **Goal**: Adjust three scrollbars (Red, Green, Blue) to change the **background color** of a TextField.
* Each scrollbar value ranges **0–255**.
* Combine RGB values to generate **over a million colors**.


##  Creating Scrollbars in Java

### Constructor (Commonly Used)

```java
Scrollbar sb = new Scrollbar(
  Scrollbar.HORIZONTAL, // orientation
  0,                  // initial value
  20,                 // visible amount (size of tracker)
  0,                  // minimum value
  255                 // maximum value
);
```

### Adding Components to Frame

```java
setLayout(null);       // Absolute positioning
tf.setBounds(50, 50, 300, 50);   // TextField bounds
red.setBounds(50, 150, 300, 30);
green.setBounds(50, 200, 300, 30);
blue.setBounds(50, 250, 300, 30);

add(tf);
add(red);
add(green);
add(blue);
```

## Event Handling

* Scrollbars generate **AdjustmentEvent**.
* Interface: `AdjustmentListener`
* Method to override:

```java
public void adjustmentValueChanged(AdjustmentEvent ae)
```

### Updating TextField Color

```java
tf.setBackground(new Color(
  red.getValue(),
  green.getValue(),
  blue.getValue()
));
```

### Registering Listener

```java
red.addAdjustmentListener(this);
green.addAdjustmentListener(this);
blue.addAdjustmentListener(this);
```



## Key Scrollbar Methods

| Method                                           | Purpose                            |
|  | - |
| `getValue()`                                     | Returns current value of scrollbar |
| `setValue(int v)`                                | Set scrollbar to specific value    |
| `setUnitIncrement(int u)`                        | Set increment for arrow clicks     |
| `setBlockIncrement(int b)`                       | Set increment for track clicks     |
| `getMinimum()` / `getMaximum()`                  | Get min/max values                 |
| `setOrientation(Scrollbar.HORIZONTAL/ VERTICAL)` | Set scrollbar orientation          |



## Practical Notes

 **Absolute positioning** (`setLayout(null)`) is often used for custom scrollbar placement.
 **Scrollbar alone does not perform any action**. You must write code to define behavior (e.g., color change).
 RGB color mixing:

   * Adjust each scrollbar independently.
   * Combine values using `Color(red, green, blue)`.



## Summary

* Scrollbar is an adjustable GUI component for **numeric selection**.
* Orientation: **Horizontal** or **Vertical**.
* Generates **AdjustmentEvent**, handled by `AdjustmentListener`.
* Can be used creatively (e.g., color mixing, resizing elements, controlling values).
* Java AWT scrollbars are **manual**; programmer must define behavior.



**Tip:** Practice setting **bounds**, **values**, and **listeners** to understand **event-driven GUI behavior** in Java.



# 13. Layout Managers  FlowLayout & BorderLayout

* **Layout Manager**: Automatically **arranges components** in a container (Frame, Panel, etc.).
* Controls **position, size, and alignment** of components.
* Helps in **designing forms and UI** consistently across platforms.

> Without layout managers, you’d have to manually set positions (`setBounds`), which is tedious.



##  Types of Layout Managers in Java AWT

| Layout Manager    | Description                                                                                                                 |
| -- |  |
| **FlowLayout**    | Arranges components **left-to-right**, line-by-line. Wraps to next line if there’s no space. Default alignment: **center**. |
| **BorderLayout**  | Divides container into **five regions**: `North`, `South`, `East`, `West`, `Center`. Default layout for a **Frame**.        |
| **GridLayout**    | Arranges components in a **grid of rows and columns**. All cells are equal in size.                                         |
| **GridBagLayout** | Similar to GridLayout but allows **empty cells**, variable cell size, and flexible component placement.                     |
| **CardLayout**    | Components are stacked like **cards**. Only one card visible at a time. Useful for **tab-like interfaces**.                 |



##  FlowLayout

* **Behavior**: Components arranged in a **row** and wraps to next line when needed.
* **Alignment options**: `LEFT`, `CENTER` (default), `RIGHT`.
* **Gaps**: Can set **horizontal** and **vertical** gaps between components.

### Example:

```java 
class MyFrame extends Frame{
  Button b1, b2,b3,b4,b5,b6;
  
  public MyFrame(){	
    b1 = new Button("One");
    b2 = new Button("Two");
    b3 = new Button("Three");
    b4 = new Button("Four");
    b5 = new Button("Five");
    b5 = new Button("Six");
    
    FlowLayout fl = new FlowLayout();

    //To change alignment of components
    fl.setAlignment(FlowLayout.CENTER); //Default
    fl.setAlignment(FlowLayout.LEFT);	
    fl.setHgap(100);
    fl.setVgap(10);

    //Then set flow layout as layout of our Frame,
    setLayout(fl);	

    add(b1); add(b2); add(b3); add(b4); add(b5); add(b6);
  }
}
public class BorderLayoutDemo{
  public static void main(String[] args){
    MyFrame mf = newFrame();
    mf.setSize(400,400);
    mf.setVisible(true);
  }
}

```

* **Effect**: Resizes automatically; extra components wrap to next line.



##  BorderLayout

* **Regions**: `North`, `South`, `East`, `West`, `Center`.
* Default layout for **Frame**.
* **Each region can hold only one component**. So you can only show 5 components but you can nest containers like **Panels** to hold multiple components.

### Adding buttons using Frame Constructor

```java
pubic MyFrame() {

  button1 = new Button("One");
  button2 = new Button("Two");
  button3 = new Button("Three");
  button4 = new Button("Four");
  button5 = new Button("Five");

  add(button1, BorderLayout.NORTH);
  add(button2, BorderLayout.SOUTH);
  add(button3, BorderLayout.EAST);
  add(button4, BorderLayout.WEST);
  add(button5, BorderLayout.CENTER);
}
```

### Using Panel inside BorderLayout:

* **Panel** is a **container** with its own layout manager.
* The default layout of Panel is FlowLayout
* Can add multiple buttons to a Panel and then add the Panel to a BorderLayout region.

```java

pubic MyFrame() {

  button1 = new Button("One");
  button2 = new Button("Two");
  button3 = new Button("Three");
  button4 = new Button("Four");
  button5 = new Button("Five");

  add(button1, BorderLayout.NORTH);
  add(button2, BorderLayout.SOUTH);
  // add(button3, BorderLayout.EAST);
  add(button4, BorderLayout.WEST);
  add(button5, BorderLayout.CENTER);

  Panel p = new Panel();
  p.setLayout(new GridLayout(3, 1)); // 3 rows, 1 column
  p.add(new Button("Monday"));
  p.add(new Button("Tuesday"));
  p.add(new Button("Wednesday"));

  add(p, BorderLayout.EAST); // Add Panel to east region
}
```

* **Effect**: Buttons appear **vertically** in east region, like a toolbar.

## GridLayout

* Components arranged in a **grid** of **rows x columns**.
* All cells have **equal size** adjusted based on frame size. 
* Example (3 rows, 2 columns):

```java
setLayout(new GridLayout(3, 2));
add(button1);
add(button2);
...
```

## 6. GridBagLayout

* Flexible version of **GridLayout**.
* In GridLayout, we can't skip any cell. But in GridBagLayout we can leave **empty cells**.
* Specify **row, column, width, height** for each component.
* Used for **complex forms**.


## CardLayout

* Stack components like **cards**; only **one visible at a time**.
* Useful for **tabbed interfaces** or **multi-step forms**.
* Switching between cards can be done using **buttons** or **choices**.



## Key Notes

 **FlowLayout**: Simple, line-by-line arrangement.
 **BorderLayout**: Useful for **main frame**, supports panels for nested layouts.
 **Panels**: Can have their own layout, e.g., **FlowLayout** or **GridLayout**.
 **GridLayout**: Equal-sized grid cells; simple table-like structure.
 **GridBagLayout**: Advanced, flexible grid with empty spaces.
 **CardLayout**: Stack components; only one visible, like tabs.


## Tips

* Use **Panel + BorderLayout** to create **toolbars** or side menus.
* For responsive design, **combine layouts** (e.g., Panel with GridLayout inside BorderLayout).
* Always **practice creating applications** with different layouts to understand behavior.


# 14. LayoutManagers - GridLayout & GridBagLayout

##  GridLayout

* **Purpose**: Arranges components in a **grid of rows and columns**.
* All cells are **equal size**, and resizing the frame resizes all components proportionally.
* **Properties**:

  * **Rows**: Number of rows
  * **Columns**: Number of columns
  * **Gaps**: Optional horizontal and vertical spacing between components.


```java
class MyFrame extends Frame
{
  Button button1, button2, button3, button4, button5;

  pubic MyFrame() {
    super("GridLayout Demo");
  
    setLayout(new GridLayout(3, 3)); // 3 rows, 3 columns
  
    button1 = new Button("One");
    button2 = new Button("Two");
    button3 = new Button("Three");
    button4 = new Button("Four");
    button5 = new Button("Five");
  
  
    add(button1);
    add(button2);
    add(button3);
    add(button4);
    add(button5);
    // Adding more components automatically fills the grid
    add(new Button("Six"));
  }
}
```

* **Notes**:
  * Changing rows and columns changes layout dynamically.
  * Can be used for applications like **calculators**, where buttons are arranged uniformly.



##  GridBagLayout

* **Purpose**: Flexible grid-based layout.
* Allows:
  * **Unequal component sizes**
  * **Empty cells**
  * Components to span **multiple rows or columns**
* Requires **GridBagConstraints** to specify placement.

### Key Concepts:

* **Grid coordinates**:
  * `gridx`: Column number (X-axis)
  * `gridy`: Row number (Y-axis)
* **Component placement**: Assign constraints when adding a component.


```java
class MyFrame extends Frame
{
  Button button1, button2, button3, button4, button5;
  
  pubic MyFrame() {
    super("GridLayout Demo");
  
    GridBagLayout gbl = new GridBagLayout();
    GridBagConstraints gbc = new GridBagConstraints();

    setLayout(gbl);
  
    button1 = new Button("One");
    button2 = new Button("Two");
    button3 = new Button("Three");
    button4 = new Button("Four");
    button5 = new Button("Five");

    // First button at (1,1)
    gbc.gridx = 1;
    gbc.gridy = 1;
    add(button1, gbc);

    // Second button at (3,1)
    gbc.gridx = 3;
    gbc.gridy = 1;
    add(button2, gbc);

    // Third button at (2,2)
    gbc.gridx = 2;
    gbc.gridy = 2;
    add(button3, gbc);
  
    // Fourth button at (4,2)
    gbc.gridx = 4;
    gbc.gridy = 2;
    add(button4, gbc);

    // Fifth button at (2,3)
    gbc.gridx = 2;
    gbc.gridy = 3;
    add(button5, gbc);  
  }
}
```
* **Notes**:

  * Components can be placed **anywhere in the grid**.
  * Can create **staircase or diagonal patterns** by assigning incremental `gridx` and `gridy`.
  * Buttons or components added **without constraints** may appear outside the intended grid.



##  Differences Between GridLayout and GridBagLayout

| Feature          | GridLayout                       | GridBagLayout                       |
| - | -- | -- |
| Grid flexibility | Fixed rows & columns             | Flexible, can skip or span cells    |
| Component size   | All equal                        | Can vary depending on constraints   |
| Empty cells      | Not allowed                      | Allowed                             |
| Use case         | Uniform grids (e.g., calculator) | Complex forms with irregular layout |



##  Practical Tips

* **GridLayout**: Simple for **uniform layouts**.
* **GridBagLayout**: Powerful for **complex UIs**, but requires practice with **GridBagConstraints**.
* Practice by creating **buttons in different grid patterns**, like diagonal or staggered layouts.
* Can combine **panels with different layouts** inside GridBagLayout for even more flexibility.


# 15. Handling KeyEvent

* **KeyEvent** is generated whenever a key is pressed on the keyboard. Upon TextField in Java AWT, KeyEvent is converted into TextEvent.
* It has **three types**:
   **KeyPressed** – Triggered when a key is pressed.
   **KeyTyped** – Triggered when a valid character is typed (holding the key can generate multiple KeyTyped events).

     * Only for character keys. Non-character keys (Shift, Ctrl, Alt) do not generate KeyTyped.
   **KeyReleased** – Triggered when a key is released.

**Key Points**:

* KeyEvent can be captured **on containers** like a Frame.
* Pressing a single key can generate all three events.
* KeyTyped events repeat if the key is held down (like in Notepad).


##  KeyEvent Methods

| Method                    | Purpose                                                      |
| - |  |
| `getKeyChar()`            | Returns the character of the key pressed.                    |
| `getKeyCode()`            | Returns the Unicode or virtual key code.                     |
| `getKeyModifiersText()`   | Returns which modifier keys (Shift, Ctrl, Alt) were pressed. |
| `getKeyText(int keyCode)` | Returns the key name as string (e.g., "Home", "A").          |

* **Virtual Key Constants** (`VK_*`) are predefined for all keys (e.g., `VK_CONTROL`, `VK_A`, `VK_F1`).



##  KeyListener Interface

* **Interface to handle KeyEvents.**
* Must implement **all three methods**:

   `keyPressed(KeyEvent e)`
   `keyReleased(KeyEvent e)`
   `keyTyped(KeyEvent e)`

**Usage**:

```java
class MyFrame extends Frame implements KeyListener {
  Label l1, l2, l3, l4;

  MyFrame() {
    super("KeyEventDemo");
    setLayout(null);  // No layout; manual positioning

    // Create labels
    l1 = new Label(""); l2 = new Label(""); 
    l3 = new Label(""); l4 = new Label("");

    // Set bounds (x, y, width, height)
    l1.setBounds(20, 20, 100, 20);
    l2.setBounds(20, 50, 100, 20);
    l3.setBounds(20, 80, 100, 20);
    l4.setBounds(20, 110, 200, 20);

    // Add labels to frame
    add(l1); add(l2); add(l3); add(l4);

    // Add KeyListener to frame
    addKeyListener(this);
  }

  public void keyPressed(KeyEvent k) {
    l1.setText("KeyPressed");
    l2.setText("");
  }

  public void keyReleased(KeyEvent k) {
    l2.setText("KeyReleased");
    l1.setText("");
    l3.setText("");
    l4.setText("");
  }

  public void keyTyped(KeyEvent k) {
    l3.setText("KeyTyped");
    l4.setText(new java.util.Date(k.getWhen()) + "");
  }
}
```

##  Key Event Flow

 **Press key** → `KeyPressed` event triggers → label1 shows **KeyPressed**
 **Hold key** → `KeyTyped` event triggers repeatedly → label3 shows **KeyTyped**
 **Release key** → `KeyReleased` event triggers → label2 shows **KeyReleased**

* Label4 shows the **time of the key event**.
* Using `setText("")` clears previous events for clarity.


## Practical Tips

* Use `null` layout when you want **manual positioning** of labels/components.
* Use **`getKeyChar()`** for character keys, **`getKeyCode()`** for non-character keys.
* **Practice capturing different keys** to see how KeyPressed, KeyTyped, and KeyReleased behave.



# 16. Handling MouseEvent

Mouse events are triggered by **actions of the mouse pointer** on a component (like a Frame, Panel, or Button). The main cases are:

| Event Type        | Trigger Condition                                                                   |
| -- | -- |
| **mouseEntered**  | Cursor enters the component area.                                                   |
| **mouseExited**   | Cursor leaves the component area.                                                   |
| **mouseClicked**  | Mouse button pressed and released at the same location (single or multiple clicks). |
| **mousePressed**  | Mouse button is pressed.                                                            |
| **mouseReleased** | Mouse button is released.                                                           |
| **mouseMoved**    | Mouse moves without pressing any button.                                            |
| **mouseDragged**  | Mouse moves while a button is pressed (drag).                                       |

**Notes**:

* `mouseClicked` is a combination of `mousePressed` + `mouseReleased`.
* `mouseDragged` only occurs when a button is pressed while moving.
* Mouse coordinates can be obtained using `getX()` and `getY()` for **component coordinates**, or `getXOnScreen()`/`getYOnScreen()` for **screen coordinates**.

##  MouseEvent Class

**Useful Methods**:

| Method                              | Purpose                                                                               |
| -- | - |
| `getButton()`                       | Returns which mouse button is pressed (compare with `BUTTON1`, `BUTTON2`, `BUTTON3`). |
| `getClickCount()`                   | Returns number of clicks (single, double click).                                      |
| `getPoint()`                        | Returns the cursor location as a `Point` object.                                      |
| `getX()` / `getY()`                 | X/Y coordinates relative to the component.                                            |
| `getXOnScreen()` / `getYOnScreen()` | X/Y coordinates relative to the screen.                                               |
| `isPopupTrigger()`                  | Checks if right-click (context menu) is pressed.                                      |

**Constants**: `BUTTON1`, `BUTTON2`, `BUTTON3` correspond to left, middle, and right mouse buttons.



##  Mouse Listener Interfaces

### a) MouseListener

Handles **five main events**:

 `mouseClicked(MouseEvent e)`
 `mousePressed(MouseEvent e)`
 `mouseReleased(MouseEvent e)`
 `mouseEntered(MouseEvent e)`
`mouseExited(MouseEvent e)`

### b) MouseMotionListener

Handles **two events**:

 `mouseMoved(MouseEvent e)`
 `mouseDragged(MouseEvent e)`

> To handle all mouse events, implement **both interfaces**.



##  Sample Application

**Objective**: Show mouse events and coordinates on a frame using labels.

```java
class MyFrame extends Frame implements MouseListener, MouseMotionListener {

  Label l1, l2; // l1 = event name, l2 = coordinates

  MyFrame() {
    super("MouseEventDemo");
    setLayout(null); // manual positioning

    // Create labels
    l1 = new Label(""); l2 = new Label("");

    // Set bounds (x, y, width, height)
    lsetBounds(20, 20, 200, 20);
    lsetBounds(20, 50, 200, 20);

    add(l1); add(l2);

    // Register listeners
    addMouseListener(this);
    addMouseMotionListener(this);
  }

  // MouseListener methods
  public void mouseClicked(MouseEvent e)   { lsetText("Mouse Clicked"); }
  public void mousePressed(MouseEvent e)   { lsetText("Mouse Pressed"); }
  public void mouseReleased(MouseEvent e)  { lsetText("Mouse Released"); }
  public void mouseEntered(MouseEvent e)   { lsetText("Mouse Entered"); }
  public void mouseExited(MouseEvent e)    { lsetText("Mouse Exited"); }

  // MouseMotionListener methods
  public void mouseMoved(MouseEvent e)     { lsetText("X: " + e.getX() + ", Y: " + e.getY()); }
  public void mouseDragged(MouseEvent e)   { lsetText("X: " + e.getX() + ", Y: " + e.getY()); }
}
```

**Behavior**:

* Label1 shows **event type** (`Clicked`, `Pressed`, `Released`, `Entered`, `Exited`).
* Label2 shows **current mouse coordinates** (updated during move or drag).
* Moving, pressing, releasing, dragging, entering, or exiting the frame triggers the corresponding event.



## Practical Tips

* Use `null` layout for manual positioning of components when handling mouse events.
* Use `getX()`/`getY()` for component-relative coordinates; `getXOnScreen()`/`getYOnScreen()` for screen coordinates.
* Register listeners with the component (`addMouseListener`, `addMouseMotionListener`).
* Mouse events can be combined or tracked individually (click vs press/release vs drag).


# 17. Handling WindowEvent

##  What are Window Events?

Window events are **events generated by interactions with a window** (like a `Frame`). These are used to handle opening, closing, activating, deactivating, minimizing, or restoring a window.

### **Seven Types of Window Events**

| Event Type            | Trigger Condition                                                                                                           |
|  |  |
| **windowOpened**      | When the window is opened. Useful for initializing files, resources, or connections.                                        |
| **windowClosing**     | When the user clicks the close button (before the window closes). Often used to terminate the program via `System.exit(0)`. |
| **windowClosed**      | After the window has been closed. Cannot see the label for this event.                                                      |
| **windowIconified**   | When the window is minimized (iconified).                                                                                   |
| **windowDeiconified** | When a minimized window is restored (maximized).                                                                            |
| **windowActivated**   | When the window gains focus (becomes active).                                                                               |
| **windowDeactivated** | When the window loses focus (becomes inactive).                                                                             |

**Notes:**

* Some events (like `windowClosed` or `windowIconified`) may not be visible on a label if the window is not showing.
* Handling `windowClosing` is **essential** to allow the program to terminate properly using `System.exit(0)`.


##  WindowListener Interface

`WindowListener` is an interface in Java AWT that provides **seven abstract methods**, each corresponding to one of the window events:

```java
public interface WindowListener {
  void windowOpened(WindowEvent e);
  void windowClosing(WindowEvent e);
  void windowClosed(WindowEvent e);
  void windowIconified(WindowEvent e);
  void windowDeiconified(WindowEvent e);
  void windowActivated(WindowEvent e);
  void windowDeactivated(WindowEvent e);
}
```

**Important:**

* If you implement `WindowListener`, you **must override all seven methods**.
* Even if you don’t use some events, empty method bodies are required.

##  Sample Application

**Objective:** Display window event messages on a `Label`.

```java
import java.awt.*;
import java.awt.event.*;

class MyFrame extends Frame implements WindowListener {
  Label l;

  MyFrame() {
    super("WindowEventDemo");
    l = new Label("Window Event Messages");
    setLayout(new FlowLayout());
    add(l);

    addWindowListener(this);  // Register listener
  }

  public void windowOpened(WindowEvent e)       { l.setText("Window Opened"); }
  public void windowClosing(WindowEvent e)      { l.setText("Window Closing"); System.exit(0); }
  public void windowClosed(WindowEvent e)       { l.setText("Window Closed"); }
  public void windowIconified(WindowEvent e)    { l.setText("Window Minimized"); }
  public void windowDeiconified(WindowEvent e)  { l.setText("Window Restored"); }
  public void windowActivated(WindowEvent e)    { l.setText("Window Activated"); }
  public void windowDeactivated(WindowEvent e)  { l.setText("Window Deactivated"); }

  public static void main(String[] args) {
    MyFrame f = new MyFrame();
    f.setSize(400, 200);
    f.setVisible(true);
  }
}
```

**Behavior**:

* Label displays the current **window event**.
* Clicking the close button triggers `windowClosing`, which calls `System.exit(0)`.
* Minimizing, restoring, or switching focus triggers corresponding messages.



##  Practical Tips

 **Always handle `windowClosing`** to allow proper termination of the application.
 Use labels or console output to **debug or track window events**.
 You don’t need to perform actions for all seven events; you can leave unused methods empty.
 In later videos, you can learn **shorter ways to handle window closing** using adapters, without implementing all seven methods.



**Key Takeaway:**

* Window events allow fine control over a window's lifecycle and state.
* Handling `windowClosing` is essential to close a Java AWT application correctly.


# 18. Layout Managers Card Layout

`CardLayout` is a **layout manager that allows multiple components (cards) to share the same display space**, and only one card is visible at a time. It's similar to **tabbed panes** without tabs.

##  Key Concepts

 **Card**: A panel or container added to the `CardLayout`. Only one card is visible at a time.
 **Main Panel**: The container holding all cards. Its layout manager is set to `CardLayout`.
 **Switching Cards**: Can be done using methods like:

   * `first(container)` – shows the first card
   * `last(container)` – shows the last card
   * `next(container)` – shows the next card
   * `previous(container)` – shows the previous card
   * `show(container, "cardName")` – shows card by name



##  Components Required

* **Panels**

  * `P1` – contains buttons (`B1, B2, B3`)
  * `P2` – contains text fields (`T1, T2, T3`)
  * `CP` – panel for radio buttons (or checkboxes) to select cards
  * `mainP` – main panel containing `P1` and `P2`, set with `CardLayout`
* **Controls**

  * 2 radio buttons (`C1`, `C2`) or checkboxes to switch between cards



##  Layout Structure

```
Frame (BorderLayout)
 ├── North: CP (radio buttons)
 └── Center: mainP (CardLayout)
       ├── Card "One": P1 (buttons)
       └── Card "Two": P2 (text fields)
```

* **Frame layout:** `BorderLayout`
* **Main panel layout:** `CardLayout`
* **Individual cards:** default `FlowLayout`



##  Handling Events

* **Event Type:** `ItemEvent` (for radio buttons or checkboxes)
* **Listener:** `ItemListener`
* **Method:** `public void itemStateChanged(ItemEvent e)`

**Example Implementation:**

```java
import java.awt.*;
import java.awt.event.*;

class CardLayoutDemo extends Frame implements ItemListener {
  Panel mainP, P1, P2, CP;
  Button B1, B2, B3;
  TextField T1, T2, T3;
  Checkbox C1, C2;
  CheckboxGroup CG;
  CardLayout cl;

  CardLayoutDemo() {
    super("CardLayout Demo");

    // Buttons
    B1 = new Button("1"); B2 = new Button("2"); B3 = new Button("3");

    // TextFields
    T1 = new TextField(10); T2 = new TextField(10); T3 = new TextField(10);

    // Panels for cards
    P1 = new Panel();
    Padd(B1); Padd(B2); Padd(B3);

    P2 = new Panel();
    Padd(T1); Padd(T2); Padd(T3);

    // CardLayout panel
    mainP = new Panel();
    cl = new CardLayout();
    mainP.setLayout(cl);
    mainP.add(P1, "One");
    mainP.add(P2, "Two");

    // Radio buttons
    CG = new CheckboxGroup();
    C1 = new Checkbox("One", CG, true);
    C2 = new Checkbox("Two", CG, false);
    CP = new Panel();
    CP.add(C1); CP.add(C2);

    // Add panels to frame
    add(CP, BorderLayout.NORTH);
    add(mainP, BorderLayout.CENTER);

    // Event handling
    CaddItemListener(this);
    CaddItemListener(this);

    // Frame settings
    setSize(400, 200);
    setVisible(true);
  }

  public void itemStateChanged(ItemEvent e) {
    if (CgetState()) cl.show(mainP, "One");
    else cl.show(mainP, "Two");
  }

  public static void main(String[] args) {
      new CardLayoutDemo();
  }
}
```

## Behavior

 **Default view:** Card "One" with buttons visible.
 **Selecting radio button C2:** switches to Card "Two" with text fields.
 **Selecting C1 again:** switches back to buttons.

## 6. Key Points

* Each **card is a separate panel** added to a main panel with `CardLayout`.
* Use **radio buttons or checkboxes** to control which card is visible.
* `CardLayout` methods (`first`, `last`, `next`, `previous`, `show`) control which card is displayed.
* The **frame layout** can remain `BorderLayout`, while the **card container** uses `CardLayout`.
* Useful for **tab-like interfaces** without creating actual tabs.



# 19. Adapter Classes

Adapter classes provide a **simpler way to handle event listeners** that have **multiple abstract methods**. Instead of implementing all methods (even unused ones), you can **extend an adapter class** and override **only the methods you need**.

##  The Problem with Listeners

* **Single-method listeners** (functional interfaces) like `ActionListener` are easy:

  ```java
  public void actionPerformed(ActionEvent e) { ... }
  ```

  Only one method to implement.

* **Multi-method listeners** like `WindowListener`:

  ```java
  windowActivated
  windowClosed
  windowClosing
  windowDeactivated
  windowDeiconified
  windowIconified
  windowOpened
  ```

  * If you implement `WindowListener`, you must override **all seven methods**.
  * Even if you need only `windowClosing`, you must write dummy bodies for the other six—this is tedious.



##  Adapter Classes: The Solution

* Adapter classes **already implement all methods** of the listener with empty (dummy) bodies.

* You can **extend an adapter class** and **override only the methods you need**.

* Examples:

  | Listener            | Adapter Class      |
  | - |  |
  | WindowListener      | WindowAdapter      |
  | MouseListener       | MouseAdapter       |
  | MouseMotionListener | MouseMotionAdapter |
  | KeyListener         | KeyAdapter         |
  | FocusListener       | FocusAdapter       |

* **Not needed** for single-method listeners (`ActionListener`, `ItemListener`, `AdjustmentListener`) because they are functional interfaces.



##  Using WindowAdapter

###  Inner Class Approach

```java
class MyFrame extends Frame {
  MyFrame() {
    addWindowListener(new MyWindowAdapter());
  }

  class MyWindowAdapter extends WindowAdapter {
    public void windowClosing(WindowEvent we) {
        System.exit(0);
    }
  }
}
```
* Inner class inherits `WindowAdapter`.
* Only `windowClosing()` is overridden.
* Other methods have default empty implementation.

###  Separate Class Approach

```java
class MyWindowAdapter extends WindowAdapter {
  public void windowClosing(WindowEvent we) {
    System.exit(0);
  }
}

class MyFrame extends Frame {
  MyFrame() {
    addWindowListener(new MyWindowAdapter());
  }
}
```

* The adapter class is **independent** and reusable for multiple frames.

###  Anonymous Class Approach (Most Common)

```java
addWindowListener(new WindowAdapter() {
  public void windowClosing(WindowEvent we) {
    System.exit(0);
  }
});
```

* Creates **on-the-fly adapter** without defining a separate class.
* Only overrides the required method.
* **Cleaner and shorter**, widely used in practice.



##  Key Points

 **Adapter classes are abstract** and implement all methods of their listener.
 **Cannot instantiate directly** because they are abstract.
 **Extend the adapter** (inner, outer, or anonymous class) and override the methods you need.
 **Reduces code clutter** when you need only some events from a listener.
Applicable for **mouse, key, focus, and window events**.



### Summary

* Use **listeners** when they are **single-method interfaces**.
* Use **adapter classes** when **listeners have multiple methods**, but you need only a few.
* **Best practice:** Use **anonymous adapter classes** for events like `windowClosing`.


# 20. Different Ways of Handling Event

In Java, there are multiple ways to handle events. This video demonstrates **four approaches** using a simple counter application:

* **Application:**

  * A `TextField` shows a number (counter).
  * A `Button` increments the counter each time it is clicked.



## Method 1: **Frame Class Implements Listener**

* Make the **frame class** implement `ActionListener`.
* Override the `actionPerformed()` method inside the frame.
* Add the listener to the button with `b.addActionListener(this)`.

```java
class MyFrame extends Frame implements ActionListener {
  TextField tf;
  Button b;
  int count = 0;

  MyFrame() {
    super("Event Demo");
    tf = new TextField("0", 20);
    b = new Button("Click");
    setLayout(new FlowLayout());
    add(tf);
    add(b);
    b.addActionListener(this);  // Frame itself is listener
  }

  public void actionPerformed(ActionEvent ae) {
    count++;
    tf.setText(String.valueOf(count));
  }
}
```

**Pros:** Simple for small applications.
**Cons:** Frame class may become bulky if handling multiple events.



## Method 2: **Inner Class as Listener**

* Define a **separate class inside the frame** implementing `ActionListener`.
* Only this inner class handles the button click.
* Add the listener as an **anonymous object** of the inner class.

```java
class MyFrame extends Frame {
  TextField tf;
  Button b;
  int count = 0;

  MyFrame() {
    super("Event Demo");
    tf = new TextField("0", 20);
    b = new Button("Click");
    setLayout(new FlowLayout());
    add(tf);
    add(b);
    b.addActionListener(new MyListener()); // Inner class listener
  }

  class MyListener implements ActionListener {
    public void actionPerformed(ActionEvent ae) {
      count++;
      tf.setText(String.valueOf(count));
    }
  }
}
```

**Pros:** Keeps listener logic separate from frame.
**Reusable within the frame.**

## Method 3: **Anonymous Class as Listener**

* Instead of defining a class, create **on-the-fly anonymous class**.
* Override the method inline.

```java
b.addActionListener(new ActionListener() {
  public void actionPerformed(ActionEvent ae) {
      count++;
      tf.setText(String.valueOf(count));
  }
});
```

**Pros:** No need to define a separate class.
**Cleaner than inner class if used only once.**



## Method 4: **Lambda Expression (Java 8+)**

* Works for **functional interfaces** (interfaces with **one abstract method**), like `ActionListener`.
* Syntax is **compact**, eliminates boilerplate code.

```java
b.addActionListener(ae -> {
  count++;
  tf.setText(String.valueOf(count));
});
```

* Can also be written as a **single line**:

```java
b.addActionListener(ae -> tf.setText(String.valueOf(++count)));
```

**Pros:** Most concise and modern approach.
**Recommended** for simple functional interfaces.
**Cannot be used** with listeners that have multiple abstract methods (e.g., `WindowListener`).



## Key Notes

| Method            | When to Use                   | Pros                       | Cons                                    |
| -- | -- | -- |  |
| Frame as Listener | Small apps                    | Simple, direct             | Frame may get bulky                     |
| Inner Class       | Frame handles multiple events | Organizes code             | Not reusable outside frame              |
| Anonymous Class   | One-time listener             | No class definition needed | Slightly longer syntax                  |
| Lambda            | Functional interfaces         | Very concise               | Only works for single-method interfaces |



**Analogy:**

> Different cars, same functionality. The make, body type, and style may differ, but the result is the same — the counter increments on button click.


# 21. Menus

In Java, **menus** allow users to select operations via a **menu bar**, **menus**, **sub-menus**, and **menu items**. This video demonstrates how to create a menu-driven GUI application.

## Components of a Menu

| Component           | Java Class         | Description                                           |
| ------------------- | -------------------| ------------------------------------------------------|
| Menu Bar            | `MenuBar`          | Top bar that holds menus.                             |
| Menu                | `Menu`             | A dropdown item on the menu bar (e.g., File).         |
| Menu Item           | `MenuItem`         | An item inside a menu (e.g., Open, Save).             |
| Sub-Menu            | `Menu`             | A menu inside another menu (e.g., Close → Close All). |
| Checkable Menu Item | `CheckboxMenuItem` | Can be selected/deselected (e.g., Auto Save).         |
| TextField           | `TextField`        | Displays status of selected menu item (optional).     |

**Note:** The look and feel may differ between OS (Windows vs. Mac), but functionality remains the same.

## Menu Hierarchy Example

```
MenuBar
 └── File (Menu)
      ├── Open (MenuItem)
      ├── Save (MenuItem)
      ├── Close (Sub-Menu)
      │     ├── Close (MenuItem)
      │     └── Close All (MenuItem)
      └── Auto Save (CheckboxMenuItem)
```

## Steps to Develop Menu

 **Create Menu Items**:

   ```java
   MenuItem open = new MenuItem("Open");
   MenuItem save = new MenuItem("Save");
   MenuItem close = new MenuItem("Close");
   MenuItem closeAll = new MenuItem("Close All");
   CheckboxMenuItem auto = new CheckboxMenuItem("Auto Save");
   ```

 **Create Menus and Sub-Menus**:

   ```java
   Menu file = new Menu("File");
   Menu sub = new Menu("Close");
   ```

 **Add Menu Items to Menus**:

   ```java
   sub.add(close);
   sub.add(closeAll);

   file.add(open);
   file.add(save);
   file.add(sub);
   file.add(auto);
   ```

 **Create Menu Bar and Add Menu**:

   ```java
   MenuBar mb = new MenuBar();
   mb.add(file);
   setMenuBar(mb);  // Attach menu bar to frame
   ```

**Create and Add Text Field (Optional)**:

   ```java
   TextField tf = new TextField(20);
   setLayout(new FlowLayout());
   add(tf);
   ```

## Handling Menu Events

* **MenuItem** → **ActionListener**

  ```java
  open.addActionListener(ae -> tf.setText("Open"));
  save.addActionListener(ae -> tf.setText("Save"));
  close.addActionListener(ae -> tf.setText("Close"));
  closeAll.addActionListener(ae -> tf.setText("Close All"));
  ```

* **CheckboxMenuItem** → **ItemListener**

  ```java
  auto.addItemListener(ie -> {
      if(auto.getState()) tf.setText("Auto Save On");
      else tf.setText("Auto Save Off");
  });
  ```

**Note:** Lambda expressions make it concise since these are **functional interfaces**.

## Summary

 **Menu structure:** `MenuBar → Menu → MenuItem / Sub-Menu → MenuItem`.
 **CheckboxMenuItem** allows toggling (checked/unchecked).
 **Events:** Use `ActionListener` for normal menu items and `ItemListener` for checkbox menu items.
 **Functional interfaces + Lambda expressions** simplify event handling.
**OS Differences:** Appearance may differ across Windows and Mac, but functionality is consistent.

**Tip:** Practice creating menus with multiple sub-menus and checkboxes. Also, try using **icons** for menu items for more advanced interfaces.


# 22. Painting , Color and Font

Java allows drawing on frames and other containers using the **Graphics API**. You can draw shapes, text, and control colors and fonts.

## Basics of Painting

* **Container:** Any GUI container (like `Frame`) can have custom drawing.
* **Method:** Override the `paint(Graphics g)` method.

  ```java
  public void paint(Graphics g) {
      // Drawing code here
  }
  ```
* **Graphics Class:** Provides methods for drawing shapes, text, images, and setting colors and fonts.
* **Repainting:** To redraw the frame after events (like mouse clicks), call `repaint()` instead of calling `paint()` directly.

  * `repaint()` triggers the system to call `paint(Graphics g)` automatically.



## Drawing Shapes

* **Draw Oval / Circle:**

  ```java
  g.drawOval(x, y, width, height);    // Outline
  g.fillOval(x, y, width, height);    // Filled circle
  ```
* **Other Drawing Methods:**

  * `drawLine(x1, y1, x2, y2)` – Draws a line
  * `drawRect(x, y, width, height)` – Draws rectangle
  * `drawPolygon(...)`, `drawPolyline(...)`
  * `drawString("Text", x, y)` – Draws text


## Mouse Events for Drawing

* **Mouse Coordinates:** Use `MouseEvent` methods `getX()` and `getY()`.
* **Mouse Listener:** To handle clicks:

  ```java
  addMouseListener(new MouseAdapter() {
      public void mouseClicked(MouseEvent me) {
          x = me.getX();
          y = me.getY();
          repaint();  // triggers paint()
      }
  });
  ```
* **Mouse Motion Listener:** To draw as mouse moves:

  ```java
  addMouseMotionListener(new MouseAdapter() {
      public void mouseMoved(MouseEvent me) {
          x = me.getX();
          y = me.getY();
          repaint();
      }
  });
  ```

## Colors

* **Class:** `java.awt.Color`
* **Predefined Colors:** `Color.RED`, `Color.BLUE`, `Color.GREEN`, etc.
* **Custom Colors:** Using RGB values (0–255):

  ```java
  Color myColor = new Color(red, green, blue);
  g.setColor(myColor);
  ```

## Fonts

* **Class:** `java.awt.Font`
* **Constructor:** `Font(String name, int style, int size)`
  Example:

  ```java
  Font f = new Font("Times New Roman", Font.BOLD, 30);
  g.setFont(f);
  g.drawString("Hello", x, y);
  ```
* **Styles:** `Font.PLAIN`, `Font.BOLD`, `Font.ITALIC`
* **Finding Fonts:** Use system preferences, IDE settings, or any font selection tool.


## 6️⃣ Example: Drawing a Circle at Mouse Click

```java
import java.awt.*;
import java.awt.event.*;

public class DrawCircle extends Frame {
  int x = 0, y = 0;

  DrawCircle() {
    setSize(400, 400);
    setVisible(true);

    addMouseListener(new MouseAdapter() {
      public void mouseClicked(MouseEvent me) {
        x = me.getX();
        y = me.getY();
        repaint();
      }
    });
  }

  public void paint(Graphics g) {
    g.setColor(Color.RED);
    g.fillOval(x, y, 50, 50);
  }

  public static void main(String[] args) {
    new DrawCircle();
  }
}
```

## 7️⃣ Tips

* Use **`paint()`** for all custom drawing.
* Call **`repaint()`** after updating coordinates or state.
* Use **MouseAdapter** to override only required mouse methods.
* Use **Colors** and **Fonts** to enhance visuals.
* Combine shapes, text, and colors to create more complex drawings.


**Practice Ideas:**

 Draw multiple circles at each click and retain previous ones.
 Draw different shapes (rectangles, polygons) on mouse events.
 Display text at the mouse pointer in different colors and fonts.
 Try moving shapes along with the mouse cursor (dragging).



# 23. Animation

Animation in Java is about moving objects smoothly on the screen. This is done using **graphics for drawing** and **threads for continuous movement**.


## Understanding Coordinates and Movement

* Java frames use a **cartesian coordinate system**:

  * `(0,0)` → Top-left corner
  * `X` increases → Right
  * `Y` increases → Down
* Shapes (like a circle) are drawn inside a rectangle:

  * The top-left corner of this rectangle defines the `(X,Y)` of the circle.
* **Movement Logic**:

  * To move a circle diagonally, increment both `X` and `Y`:

    ```text
    X = X + 1, Y = Y + 1
    ```
  * When hitting boundaries, reverse direction by changing signs:

    * Example: `TX = -TX` or `TY = -TY`
* **Translation Variables**: Represent speed and direction:

  * `TX` → change in X per frame
  * `TY` → change in Y per frame



## Drawing the Ball

* Use `paint(Graphics g)` to draw:

  ```java
  public void paint(Graphics g) {
      g.setColor(Color.RED);         // Set color
      g.fillOval(x, y, 50, 50);      // Draw filled circle
  }
  ```
* Use `repaint()` to redraw the frame after coordinates change.



## Continuous Movement with Threads

* **Threading is required** for smooth animation:

  * A `while(true)` loop inside a thread continuously updates the position and repaints.
* **Runnable Interface**:

  * If your class already extends `Frame`, implement `Runnable` for threading.

  ```java
  class AnimationFrame extends Frame implements Runnable {
    public void run() {
      while(true) {
        x += TX;
        y += TY;
        // Check boundaries
        if (x < 0 || x > width - 50) TX = -TX;
        if (y < 20 || y > height - 50) TY = -TY;
        repaint();
        try { Thread.sleep(5); } catch (Exception e) {}
      }
    }
  }
  ```



## Boundary Logic for Bouncing

* **Right/Left boundaries** → X-axis:

  ```java
  if (x < 0 || x > frameWidth - ballWidth) TX = -TX;
  ```
* **Top/Bottom boundaries** → Y-axis (consider title bar):

  ```java
  if (y < titleBarOffset || y > frameHeight - ballHeight) TY = -TY;
  ```
* Multiplying the translation by `-1` changes the direction, creating a bounce effect.



## Adjusting Speed

* Use `Thread.sleep(milliseconds)` in the loop:

  ```java
  Thread.sleep(5); // slows down the animation
  ```
* Smaller sleep → faster movement
* Larger sleep → slower movement



## 6️⃣ Color and Graphics

* Set color using `Graphics.setColor(Color.RED)`
* Fill shapes using `fillOval` or `fillRect`
* Draw outlines using `drawOval` or `drawRect`



## 7️⃣ Full Logic Flow

 **Initialize ball coordinates** `(x, y)` and translation `(TX, TY)`.
 **Draw ball** in `paint()` using graphics.
 **Start thread** that continuously:

   * Updates `x` and `y` using `TX` and `TY`
   * Checks boundaries and reverses direction
   * Calls `repaint()` to redraw
 **Sleep** briefly to control speed
Loop infinitely for continuous movement



## 8️⃣ Key Points

* Animation = **Drawing + Continuous Update**
* **Multithreading** is essential for smooth movement.
* Use **paint()** and **repaint()** for drawing/updating objects.
* Changing `TX` and `TY` signs controls the **bouncing direction**.
* Adjust sleep to control speed and ensure smooth animation.



**Practice Ideas**:

 Make the ball move faster/slower.
 Change colors randomly on bouncing.
 Add multiple balls with independent threads.
 Draw other shapes (rectangles, polygons) instead of a ball.
Add diagonal and angled bouncing logic.
