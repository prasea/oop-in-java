# AWT vs SWING

### 1. Java GUI Framework Evolution

Java provides multiple GUI frameworks, introduced over time with increasing capability:

* **AWT (Abstract Window Toolkit)** â€“ First GUI framework (Java 1)
* **Swing** â€“ Improved GUI framework (Java 2)
* **JavaFX** â€“ Most modern and advanced GUI framework

Swing sits between AWT and JavaFX and is designed to overcome AWTâ€™s limitations while keeping GUI development relatively simple.


### 2. Platform Dependence vs Independence
* **AWT is platform dependent**
* **Swing is platform independent**

This distinction is central to understanding **why Swing exists**.


### 3. Look and Feel (L&F)
* **AWT** borrows GUI appearance from the host operating system
* **Swing** defines its own look and feel (pluggable and customizable)


### 4. Heavyweight vs Lightweight Components
* **AWT components** are heavyweight (OS-dependent)
* **Swing components** are lightweight (Java-drawn)


### 5. Java Foundation Classes (JFC)
Swing is part of a broader set called **Java Foundation Classes (JFC)**.



### A. Why Swing Was Introduced When AWT Already Existed

Although Java itself is platform independent, **AWT applications are not visually consistent across operating systems**.

Why?

* AWT components (Button, Checkbox, Menu, Dialog, etc.) are **borrowed from the host OS**
* On Windows â†’ Windows-style components
* On macOS â†’ macOS-style components

So while the *code runs everywhere*, the *appearance changes*.

Swing was introduced to:

* Provide **consistent UI across platforms**
* Offer **more GUI components**
* Reduce OS dependency
* Support better design patterns (MVC)


### B. What â€œAbstractâ€ Means in AWT

The word **Abstract** in *Abstract Window Toolkit* does **not** mean Javaâ€™s `abstract` keyword.

In AWT:

* You **can** create objects like `Button`, `TextField`, etc.
* The *abstraction* refers to **look and feel**, not object creation

AWT does **not define how components look** â€” the OS does.


### C. Swingâ€™s Platform Independence Explained (Analogy)

**AWT analogy**
A person travels to different countries and wears **local clothes** in each place.
â†’ Appearance changes depending on location.

**Swing analogy**
A person carries their **own clothes** and wears them everywhere.
â†’ Appearance remains the same.

Similarly:

* AWT â†’ Uses OS look and feel
* Swing â†’ Uses Java-defined look and feel


### D. Swing Components vs AWT Components

| AWT         | Swing        |
| ----------- | ------------ |
| `Button`    | `JButton`    |
| `TextField` | `JTextField` |
| `Frame`     | `JFrame`     |
| `MenuBar`   | `JMenuBar`   |

Swing components typically:

* Start with **J**
* Are more flexible
* Support advanced features


### E. Heavyweight vs Lightweight Components

**AWT (Heavyweight)**
* Relies heavily on OS resources
* More interaction with native system

**Swing (Lightweight)**
* Drawn by Java itself
* Faster rendering
* Less OS dependency


### F. Extra Components Available in Swing
Swing provides many components **not available in AWT**, such as:

* `JSlider`
* `JProgressBar`
* `JColorChooser`
* `JFileChooser`
* `JSpinner`
* `JTabbedPane`
* Internal frames (`JInternalFrame`)

These make Swing more suitable for **rich, user-friendly applications**.


### G. Look and Feel (L&F) in Swing
Swing supports **pluggable look and feel**, such as:

* Metal
* Nimbus
* Windows
* Windows Classic
* macOS

Even though visual differences are subtle (flat vs raised buttons, checkbox styles), the **consistency across OS remains**.


## 3. Summary

* **AWT** was Javaâ€™s first GUI framework but is **platform dependent**
* **Swing** was introduced in Java 2 to overcome AWT limitations
* Swing components:

  * Are **lightweight**
  * Have **their own look and feel**
  * Are **platform independent**
  * Offer **more components**
* Swing is part of **Java Foundation Classes (JFC)**
* Swing applications look consistent across operating systems, unlike AWT

Swing ensures *visual consistency, richer components, and better control* over GUI design compared to AWT.


# 2. First Swing Application

* Swing applications typically extend **`JFrame`**
* Core Swing components used:
  * `JLabel`
  * `JButton`
* Swing classes are imported from **`javax.swing`**
* Some supporting classes (layouts, listeners) still come from **AWT**


### 2. Swing vs AWT Programming Style

* Swing follows a **very similar coding style to AWT**
* Event handling, layouts, and component methods (`setText`, `add`, etc.) remain familiar
* Major difference:
  * Swing provides **simpler window closing**
  * Swing offers **more features** with less code


### 3. Layout Managers in Swing

* Default layout for `JFrame` is **BorderLayout**
* To control component placement, layouts must be explicitly set
* `FlowLayout` is borrowed from **AWT**


### 4. Event Handling in Swing

* Uses `ActionListener`
* Listener interfaces are imported from **`java.awt.event`**
* Button click events are handled the same way as in AWT


### 5. Default Close Operation

* Swing simplifies application termination using:

  * `setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)`
* No need for `WindowListener` like in AWT


### 6. Default Button & Keyboard Interaction

* Swing supports **default buttons**
* Pressing **Enter** activates the default button
* Pressing **Spacebar** activates the focused button
* Focus can be changed using **Tab**


### 7. Icons and Tooltips

* Buttons and labels can display **images**
* Tooltip text provides user guidance
* These features come from `JComponent`, the parent class of most Swing components


## Detailed Breakdown

### A. Creating the Frame

```java
class MyFrame extends JFrame {
  MyFrame() {
      super("Swing Demo");
  }
}
```
* `JFrame` is Swingâ€™s main window container
* `super()` sets the title of the window

### B. Adding Components

```java
JLabel l = new JLabel("Clicked count: 0");
JButton b = new JButton("Click");

add(l);
add(b);
```

* Swing components are prefixed with **J**
* Components are added directly to the frame


### C. Fixing Layout Issues

By default:
* `JFrame` uses **BorderLayout**
* Components may overlap or resize unexpectedly

Solution:
```java
setLayout(new FlowLayout());
```

`FlowLayout` comes from `java.awt`, not Swing. Swing **reuses AWT layout managers**


### D. Closing the Application Properly
* Ensures the JVM terminates when the window closes
* Much simpler than AWTâ€™s `WindowListener`

```java
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
```


### E. Handling Button Clicks
* `ActionListener` is part of `java.awt.event`
* Swing still borrows event-handling infrastructure from AWT

```java
class MyFrame extends JFrame implements ActionListener {
  public void actionPerformed(ActionEvent e) {
    count++;
    l.setText("Clicked count: " + count);
  }
}
```

### F. Making a Default Button for Complete Frame

```java
getRootPane().setDefaultButton(b);
```

Effects:
* Button appears highlighted
* Pressing **Enter** triggers this button anywhere in the frame

Behavior comparison:

* **Enter** â†’ activates default button
* **Spacebar** â†’ activates focused button
* **Tab** â†’ moves focus between components


### G. Using Images on Buttons

```java
Button b = new JButton("Click");
b.setIcon(new ImageIcon("path/to/image.png"));
```

* `ImageIcon` allows images on buttons
* The button still works as a default button
* Enhances UI without changing logic


### H. Tooltips for User Guidance
* Tooltip appears when hovering over the component
* Improves usability
* Available to all Swing components via `JComponent`

```java
label.setToolTipText("Counter");
```


### I. Why These Features Are Powerful

All of these:

* Tooltips
* Icons
* Default buttons
* Keyboard handling

come **for free** because Swing components inherit from **`JComponent`**



```java 
class MyFrame extends JFrame implements ActionListener {

  JLabel label; 
  JButton button;
  int count;

  public MyFrame() {
    super("Swing Demo"); 

    setLayout(new FlowLayout());
    label = new JLabel("Clicked " + count + "Times");
    button = new JButton("Click");

    add(label);
    add(button);

    button.addActionListener(this);

    getRootPane().setDefaultButton(button);
    button.setIcon(new ImageIcon("/path/to/image.png"));
    label.setToolTipText("Counter");
  }

  public void actionPerformed(ActionEvent) {
    count++;
    label.setText("Clicked " +count+ " Times");
  }
}

public class SwingComponents {
  public static void main(String[] args) {
    MyFrame f = new MyFrame(); 
    f.setSize(500, 500); 
    f.setVisible(true); 
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  }
}
```

## 3. Summary

* Swing applications extend `JFrame`
* Swing coding style is very similar to AWT
* Layout managers and event listeners are still borrowed from AWT
* Swing simplifies:

  * Window closing
  * Keyboard interaction
  * UI enhancements (icons, tooltips)
* Default buttons improve keyboard accessibility
* Swing provides a richer, more user-friendly GUI with minimal extra effort


# 3. JTextField, JFormattedTextField


### 1. Swing Text Input Components

Swing provides multiple text input components:

* **`JTextField`** â€“ single-line text input
* **`JFormattedTextField`** â€“ input restricted to a specific format (date, number, currency, etc.)
* **`JTextArea`** â€“ multi-line text input

All of these are Swing equivalents of AWT components, with **additional power and control**.


### 2. Reuse of AWT Concepts

* Swing text components behave very similarly to AWT text components
* Methods like `setText()`, `getText()`, `addActionListener()` still apply
* Layout managers and event listeners are still borrowed from AWT


### 3. Formatting Support (New in Swing)

* Swing introduces **formatted text fields**
* Input can be restricted to:

  * Dates
  * Numbers
  * Currency
  * Percentages
* Formatting is enforced using formatter classes


## Detailed Breakdown


`JTextField` is a Basic Text Field


```java
JTextField tf1 = new JTextField(15);
add(tf1);
```

* `15` â†’ number of columns (controls width)
* Single-line input only


### Important Methods

* `addActionListener()`
  Triggered when **Enter** is pressed inside the text field
* `setText(String)`
* `getText()`
* `setToolTipText(String)`

Tooltip support comes from **`JComponent`**


## `JFormattedTextField` â€“ Why It Matters

A **formatted text field** restricts user input to a specific pattern.

Examples:

* Only dates
* Only numbers
* Currency values
* Percentages

This prevents **invalid input at the UI level**.


## C. Date-Formatted Text Field

#### 1. Import formatting classes

```java
import java.text.*;
```

#### 2. Define the date format

```java
DateFormat df = new SimpleDateFormat("dd/MM/yyyy");
```

* `dd` â†’ day
* `MM` â†’ month (capital letters)
* `yyyy` â†’ year

Order and separators can be customized

#### 3. Create formatted text field

```java
JFormattedTextField tf2 = new JFormattedTextField(df);
tf2.setColumns(15);
```

#### 4. Set an initial value (important!)
```java
import java.util.Date;
// tf2.setValue(0);
tf2.setValue(new Date());
```

Without a value:

* Format is **not visible**
* Field behaves like a normal text field

`new Date()` sets todayâ€™s date
Value `0` â†’ 1 January 1970 (Java epoch)

```java 
class MyFrame extends JFrame
{
  public MyFrame() {
    DateFormat df = new SimpleDateFormat("dd/MM/yyyy");
    JFormattedTextField ftf = new JFormattedTextField(df);
    ftf.setColumns(15);
    fts.setValue(0);
    setLayout(newFlowLayout());
    add(ftf);
  }
}
```

## D. Number-Formatted Text Field

### Required Classes
* `NumberFormat` â†’ formatting rules
* `NumberFormatter` â†’ enforces those rules
* `JFormattedTextField` â†’ applies formatter


```java
NumberFormat nf = NumberFormat.getInstance();
```

#### 2. Create number formatter

```java
NumberFormatter nft = new NumberFormatter(nf);
```

`NumberFormat` â†’ `java.text`
`NumberFormatter` â†’ `javax.swing.text`


#### 3. Restrict invalid input

```java
nft.setAllowsInvalid(false);
```

* Blocks alphabets and symbols
* Accepts only numeric input


#### 4. Set limits (optional but powerful)

```java
nft.setMaximum(10000);
```

* Prevents values beyond the limit


#### 5. Apply formatter to text field

```java
JFormattedTextField tf3 = new JFormattedTextField(nft);
tf3.setColumns(15);
tf3.setValue(0);
```

Setting a value is **mandatory** for formatting to activate

```java 
class MyFrame exteds JFrame {
  public MyFrame() {
    NumberFormat nf = NumberFormat.getInstance();
    NumberFormatter nft = new NumberFormatter(nf);
    nft.setAllowsInvalid(false);
    nft.setMaximum(10000);
    JFormattedTextField tf3 = new JFormattedTextField(nft);
    tf3.setColumns(15);
    tf3.setValue(0);
  }
}
```

## E. Currency-Formatted Text Field

### Change Number Format

```java
NumberFormat nf = NumberFormat.getCurrencyInstance(Locale.US);
```

* Automatically adds currency symbol
* Uses locale-specific formatting

Example output:

```
$0.00
```

Still enforces:

* Numeric-only input
* Maximum limits (if set)


## F. `JTextArea` â€“ Multi-line Text Input

```java
JTextArea ta = new JTextArea(5, 20);
```
* Rows â†’ height
* Columns â†’ width


### Common Methods

* `setText()`
* `getText()`
* `copy()`
* `paste()`
* `setToolTipText()`

Same behavior as AWT `TextArea`, but Swing version


## G. Why Formatted Text Fields Are Important

They:

* Prevent invalid user input
* Reduce validation logic
* Improve data quality
* Enhance user experience

Formatting is done using **formatter objects**, not simple method calls
Think of it as *configuring rules, then attaching them*


## 3. Summary

* Swing provides:

  * `JTextField` for simple input
  * `JFormattedTextField` for restricted input
  * `JTextArea` for multi-line input
* Formatting requires:

  * Format definition
  * Formatter object
  * Initial value
* Date, number, and currency formatting are supported
* Swing still borrows:

  * Layout managers
  * Event listeners
* All text components inherit powerful features from `JComponent`



# Swing CheckBoxes and Radio Buttons (JCheckBox & JRadioButton)

Swing components covered:

* `JCheckBox`
* `JRadioButton`
* `ButtonGroup`
* Mnemonics
* Event handling using `ActionListener`


## 2. Difference Between CheckBoxes and Radio Buttons

### CheckBoxes (`JCheckBox`)

* Used when **multiple options can be selected at the same time**
* Example:

  * Text can be **Bold**
  * Text can be **Italic**
  * Text can be **Bold + Italic**

### Radio Buttons (`JRadioButton`)

* Used when **only one option must be selected**
* Example:

  * Text can be **Lowercase**
  * OR **Uppercase**
  * Not both


### Functionality:

* Selecting **Bold** makes the text bold
* Selecting **Italic** makes the text italic
* Both checkboxes together â†’ **Bold + Italic**
* Radio buttons:

  * Lower â†’ converts text to lowercase
  * Upper â†’ converts text to uppercase


## Mnemonics (Keyboard Shortcuts)

Swing allows setting **mnemonics** for faster keyboard access.

### Example:

* **Alt + B** â†’ toggles Bold
* **Alt + I** â†’ toggles Italic

#### How mnemonics work:

* On Windows: `Alt + Key`
* On Mac: `Ctrl + Option + Key`

```java
checkbox.setMnemonic(KeyEvent.VK_B);
```

> Mnemonics improve **accessibility and usability**


## Creating Components in Swing

### Components used:

* `JTextField`
* `JCheckBox`
* `JRadioButton`

Each component:

* Is created inside the constructor
* Is added to the frame
* Uses **FlowLayout**


## Radio Button Grouping (Important Difference from AWT)

### AWT vs Swing

| AWT                                   | Swing                            |
| ------------------------------------- | -------------------------------- |
| `CheckboxGroup` passed to constructor | `ButtonGroup` created separately |

### Swing approach:

```java
ButtonGroup bg = new ButtonGroup();
bg.add(r1);
bg.add(r2);
```

âœ” Ensures **only one radio button is selected**


## Event Handling in Swing

### Key Difference from AWT:

* In **AWT** â†’ usually `ItemListener`
* In **Swing** â†’ can use **ActionListener**

In this application:

* All checkboxes and radio buttons use **ActionListener**

```java
implements ActionListener
```

```java
public void actionPerformed(ActionEvent e)
```


## Action Command Usage

Each component generates an **action command** (usually its label).

You can also **set your own command**:

```java
r1.setActionCommand("lower");
r2.setActionCommand("upper");
```

Then handle logic using:

```java
switch(e.getActionCommand())
```

âœ” Swing allows **String-based switch cases**, which makes code cleaner.


## Handling Text Case (Radio Buttons)

### Logic:

* Get text from text field
* Convert it
* Set it back

```java
textField.setText(textField.getText().toLowerCase());
textField.setText(textField.getText().toUpperCase());
```


## Handling Font Style (CheckBoxes)

### Font Styling Logic:

* Font styles use **bitwise OR (`|`)**
* `Font.BOLD`
* `Font.ITALIC`

### Steps:

1. Initialize style variables:

```java
int b = 0, i = 0;
```

2. Check checkbox selection:

```java
if (c1.isSelected()) b = Font.BOLD;
if (c2.isSelected()) i = Font.ITALIC;
```

3. Apply font:

```java
Font f = new Font("Times New Roman", b | i, 20);
textField.setFont(f);
```

âœ” Allows:

* Normal
* Bold
* Italic
* Bold + Italic



```java 

package swingitemdemo;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;


class MyFrame extends JFrame implements ActionListener
{
  JCheckBox c1,c2;
  JRadioButton r1,r2;

  JTextField tf;

  MyFrame()
  {
    super("Demo");
    
    tf=new JTextField("Demo Text",20);
    tf.setBounds(10,20,100,80);
    
    c1=new JCheckBox("Bold");
    c1.setMnemonic(KeyEvent.VK_B);
    
    c2=new JCheckBox("Italic");
    c2.setMnemonic(KeyEvent.VK_I);
    
    r1=new JRadioButton("lower");
    r2=new JRadioButton("UPPER");
    //Only one radio button can be selected
    ButtonGroup bg=new ButtonGroup(); 
    bg.add(r1);
    bg.add(r2);
    
    c1.addActionListener(this);
    c2.addActionListener(this);
    r1.addActionListener(this);
    r2.addActionListener(this);
    
    r1.setActionCommand("lower");
    r2.setActionCommand("UPPER");
    
    setLayout(new FlowLayout());
    
    add(tf);
    add(c1);
    add(c2);
    add(r1);
    add(r2);          
  }
    
  public void actionPerformed(ActionEvent ae)
  {
    switch(ae.getActionCommand())
    {
      case "lower": 
        tf.setText(tf.getText().toLowerCase());
        break;
      case "UPPER": 
        tf.setText(tf.getText().toUpperCase());
        break;
    }
    int b=0,i=0;
    
    if(c1.isSelected())
      b=Font.BOLD;
    if(c2.isSelected())
      i=Font.ITALIC;
    
    // Font f=new Font("Times New Roman",Font.BOLD|Font.Italic,15);
    Font f=new Font("Times New Roman",b|i,15);
    tf.setFont(f);      
  }    
}

public class SwingItemDemo 
{
  public static void main(String[] args) 
  {
      MyFrame f=new MyFrame();
      f.setSize(500,500);
      f.setVisible(true);
      f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  }    
}

```

# Borders in Swing (javax.swing.border)

In **Swing**, borders are used to:
* Group related components together
* Visually separate sections of a form
* Improve the **look and organization** of GUI applications

Borders are commonly applied to:
* `JPanel`
* Sometimes directly to components like `JButton`, `JTextField`, etc.

### Example Use Case

* A **Login** section with:
  * Label
  * TextField
  * OK button
    enclosed inside a titled border
* Another section like:
  * â€œForgot passwordâ€
  * â€œIâ€™m not a robotâ€
    enclosed inside a different border

This makes the UI clean and user-friendly.


## Basic Application Structure (Without Border)

Components used:
* `JLabel`
* `JTextField`
* `JButton`
* `JPanel`
* `JFrame`

### Typical Flow:

1. Create components (label, text field, button)
2. Add them to a `JPanel`
3. Set layout
4. Add panel to `JFrame`

At this stage:

* Components are visible
* No border is shown


## Border Package and Factory

To use borders, import:

```java
import javax.swing.border.*;
```

### Important Concept:

Borders are **not created using `new` directly**
They are created using **factory methods** from `BorderFactory`

Example:

```java
Border br = BorderFactory.createLoweredBevelBorder();
panel.setBorder(br);
```
```java 

package swingborders;
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;

class MyFrame extends JFrame 
{
  JLabel l;
  JTextField tf;
  JButton b;
  
  JPanel p;
  
  MyFrame()
  {
    l=new JLabel("Name");
    tf=new JTextField(20);
    b=new JButton("OK");
    p=new JPanel();
    
    p.add(l);
    p.add(tf);
    p.add(b);
    
    Border br = BorderFactory.createLoweredBevelBorder();
    p.setBorder(br);
    
    setLayout(new FlowLayout());
    add(p);
  }
  
}
public class SwingBorders 
{
  
  public static void main(String[] args) 
  {
    MyFrame f=new MyFrame();
    f.setSize(800,800);
    f.setVisible(true);
    
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  }
}
```

## Bevel Borders

### Lowered Bevel Border

* Appears **pressed inside**
* Also called **embossed**

```java
Border br = BorderFactory.createLoweredBevelBorder();
```

### Raised Bevel Border

* Appears **raised above surface**

```java
Border br = BorderFactory.createRaisedBevelBorder();
```

### Generic Bevel Border

You can specify the type using constants:

```java
Border br = BorderFactory.createBevelBorder(BevelBorder.LOWERED);
Border br = BorderFactory.createBevelBorder(BevelBorder.RAISED);
```

âœ” Advantage: same method, different appearance using parameters


## Etched Border

Etched borders look similar to bevel borders but have a **different finish**.

```java
Border br = BorderFactory.createEtchedBorder(EtchedBorder.LOWERED);
```

Types:

* `EtchedBorder.LOWERED`
* `EtchedBorder.RAISED`

Used when you want a **soft 3D effect**.


## Line Border

A simple border drawn using a **single line**.

```java
Border br = BorderFactory.createLineBorder(Color.RED, 5);
```

Parameters:

* Color
* Thickness

Commonly used to:

* Highlight panels
* Show warnings or focus areas


## Titled Border (Very Important)

Titled borders allow you to display **text on the border**.

### Simple Titled Border

```java
Border br = BorderFactory.createTitledBorder("Login");
```

Output:

* A border with title **Login**


## Titled Border with Custom Border Style

You can combine a border type + title:

```java
Border br = BorderFactory.createTitledBorder(
    BorderFactory.createLineBorder(Color.RED),
    "Login"
);
```

âœ” Result:

* Red line border
* Title text â€œLoginâ€


## 9. Title Position and Alignment

Swing allows control over:

* Title position
* Title justification

### Example:

```java
Border br = BorderFactory.createTitledBorder(
    BorderFactory.createLineBorder(Color.RED),
    "Login",
    TitledBorder.CENTER,
    TitledBorder.ABOVE_TOP
);
```

### Common Constants:

**Justification**

* `TitledBorder.LEFT`
* `TitledBorder.CENTER`
* `TitledBorder.RIGHT`

**Position**

* `TitledBorder.ABOVE_TOP`
* `TitledBorder.TOP`
* `TitledBorder.BELOW_TOP`

âœ” This lets you place the title **inside or outside the border**


## Compound Border

A **compound border** combines **two borders** into one.

Concept:

* Outer border
* Inner border

Example idea:

```java
Border outer = BorderFactory.createLineBorder(Color.RED);
Border inner = BorderFactory.createLoweredBevelBorder();
Border compound = BorderFactory.createCompoundBorder(outer, inner);
```

âœ” Useful for advanced UI styling
âœ” Often asked as a theory question


## Borders Not Covered in Detail

* **Dashed Border**
  * Requires custom painting
  * More advanced

* **Empty Border**
  * Used to add spacing (padding)
  * No visible line


## Why Borders Are Important

Borders help to:
* Beautify Swing applications
* Organize complex forms
* Improve user experience
* Clearly separate logical sections


# JTree Component in Swing

`JTree` is a **Swing component** used to represent data in a **hierarchical tree structure**, similar to:

* Windows Explorer directory tree
* Folder â†’ subfolder â†’ files

### Typical Use Cases

* File system browsers
* Organizational hierarchies
* Menu structures
* Any parentâ€“child structured data


## Real-World Analogy

Think of:

```
C:
 â””â”€â”€ MyJava
     â”œâ”€â”€ AWTFirst.java
     â”œâ”€â”€ Circle.java
     â””â”€â”€ MenuDemo
         â”œâ”€â”€ File1.java
         â””â”€â”€ File2.java
```

This structure maps **naturally** to a `JTree`.


## Components Used in the Application

* `JTree` â†’ to display hierarchical data
* `JLabel` â†’ to show the selected node information
* `JScrollPane` â†’ to add scrolling
* `JFrame` â†’ main window
* `DefaultMutableTreeNode` â†’ tree nodes
* `File` (java.io) â†’ read directory contents


## Tree Nodes in Swing

Swing trees are built using **nodes**, not directly using `JTree`.

### TreeNode Interface

* `TreeNode` is an **interface**
* Cannot be instantiated directly

### DefaultMutableTreeNode

* Concrete class used for tree nodes
* Every item in a tree (root, folder, file) is a `DefaultMutableTreeNode`


## Creating the Root Node

```java
DefaultMutableTreeNode root = new DefaultMutableTreeNode("C:\\MyJava");
```

* This becomes the **topmost node**
* All other nodes are added under this root


## Reading Files from a Directory

Using Java IO:

```java
File f = new File("C:\\MyJava");
```

To list files and directories:

```java
File[] files = f.listFiles();
```

* Includes both **files and folders**
* Directories are treated as `File` objects too


## Adding Files as Tree Nodes (Single Level)

```java
for (File x : f.listFiles()) {
  DefaultMutableTreeNode node =
      new DefaultMutableTreeNode(x.getName());
  root.add(node);
}
```

Result:
* Root â†’ children (files/folders)
* No expansion for subfolders yet


## Handling Directories (Expandable Nodes)

To differentiate:

```java
if (x.isDirectory()) {
    // folder logic
} else {
    // file logic
}
```

### Folder Handling Logic

1. Create a node for the folder
2. Read files inside the folder
3. Add them as child nodes
4. Add folder node to root

```java
DefaultMutableTreeNode temp =
    new DefaultMutableTreeNode(x.getName());

for (File y : x.listFiles()) {
  temp.add(
      new DefaultMutableTreeNode(y.getName())
  );
}

root.add(temp);
```

Now folders are **expandable**


## Creating the JTree

Once the tree structure is ready:

```java
JTree tree = new JTree(root);
```

* The tree uses the **root node**
* Automatically builds hierarchy


## Adding Scrollbars (Very Important)

Trees can grow large â†’ scrolling is required.

### JScrollPane Rule

> Always add the component **inside** `JScrollPane` during creation.

```java
JScrollPane sp = new JScrollPane(tree);
```

Then add scroll pane to frame, **not the tree directly**.


## Layout and Component Placement

Using default `BorderLayout`:

* Tree (inside scroll pane) â†’ `CENTER`
* Label â†’ `SOUTH`

```java
add(sp, BorderLayout.CENTER);
add(label, BorderLayout.SOUTH);
```


## Handling Tree Selection Events

To detect which node is selected:

### Listener Used

```java
TreeSelectionListener
```

### Implementation

```java
implements TreeSelectionListener
```

Add listener:

```java
tree.addTreeSelectionListener(this);
```


## Tree Selection Event Handling

Override method:

```java
public void valueChanged(TreeSelectionEvent e) {
    label.setText(e.getPath().toString());
}
```

### What `getPath()` Returns

* Path from root to selected node
* Example:

```
[C:\MyJava, MenuDemo, File1.java]
```

âš  This is **tree path**, not OS file system path


## Displaying Only File Name (Enhancement)

Current output:

```
[C:\MyJava, MenuDemo, File1.java]
```

To show only:

```
File1.java
```

### Hint Approaches

* Convert path to string and:

  * Extract substring after last comma
  * Remove `[` and `]`
* Or:

  * Use `TreePath.getLastPathComponent()`

(Left as a **practice task** by instructor)


```java 
package swingtree;

import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import javax.swing.tree.*;
import java.io.*;
import java.util.StringTokenizer;

class MyFrame extends JFrame implements TreeSelectionListener
{
  JTree tree;
  JLabel label;
  
  MyFrame()
  {
    super("Tree Demo");
    //valid path must be given
    DefaultMutableTreeNode root=new DefaultMutableTreeNode("C:\\MyJava");
    File f=new File("C:\\MyJava");
    
    for(File x: f.listFiles())
    {
      if(x.isDirectory())
      {
        DefaultMutableTreeNode temp=new DefaultMutableTreeNode(x.getName());
        for(File y:x.listFiles())
        {
          temp.add(new DefaultMutableTreeNode(x.getName()));
        }
        root.add(temp);
      }
      else
          root.add(new DefaultMutableTreeNode(x.getName()));
    }
    
    tree=new JTree(root);
    label=new JLabel("No Files Selected");
    
    tree.addTreeSelectionListener(this);
    JScrollPane sp=new JScrollPane(tree);
    
    // add(tree,BorderLayout.CENTER);
    add(sp,BorderLayout.CENTER);
    add(label,BorderLayout.SOUTH);
      
  }

  @Override
  public void valueChanged(TreeSelectionEvent e) {
    label.setText(e.getPath().toString());
  } 
}

public class SwingTree 
{
  public static void main(String[] args) 
  {
    MyFrame f=new MyFrame();
    f.setSize(400,400);
    f.setVisible(true);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      
  }    
}

```

## Summary

`JTree` is a powerful Swing component used to:

* Organize data hierarchically
* Display file systems and structured data
* Handle user selections dynamically

With:

* `DefaultMutableTreeNode`
* `File` class
* `TreeSelectionListener`
  you can build fully functional tree-based GUIs.


# JLayeredPane in Swing

## 1. What is a JLayeredPane?

`JLayeredPane` is a **Swing container** that allows components to be arranged in **layers**, meaning components can **overlap each other**.

### Key Idea

* A normal frame is **2D (x, y)**
* `JLayeredPane` adds a **third dimension (z-axis)**
  â†’ components can be placed **above or below** each other

Think of layers as **transparent sheets stacked from screen â†’ towards you**.


## 2. Why Do We Need Layered Panes?

Use `JLayeredPane` when:

* Components must overlap
* You want to show/hide panels dynamically
* You need multiple â€œscreensâ€ inside one frame

### Real-World Example

Multi-step forms:

1. Basic information
2. Address details
3. Security questions

All panels exist in the **same frame**, but different layers are shown one at a time.


## 3. Demo Explained (Conceptual View)

### Components in the Demo

* **3 colored panels (labels)**:

  * Red
  * Green
  * Blue
* **1 black label**:

  * Moves with mouse
  * Changes layer dynamically
* **3 radio buttons**:

  * Red / Green / Blue
  * Decide which layer the black label belongs to

### Visual Effect

* Colored labels are in **different layers**
* Black label:

  * Moves with mouse
  * Appears **above or below** colored panels depending on selection

This proves that components are arranged in **3D layers**, not just flat positions.


## 4. Core Swing Classes Used

* `JLayeredPane` â†’ manages layers
* `JLabel` â†’ colored rectangles (panels)
* `JRadioButton` â†’ layer selection
* `ButtonGroup` â†’ mutual exclusivity
* `JPanel` â†’ holds radio buttons
* `MouseMotionListener` â†’ track mouse movement
* `ActionListener` â†’ handle radio button clicks
* `Color` â†’ background colors


## 5. Understanding Layers

### Layer Concept

Each component is added with a **layer number**:

```java
lp.add(component, new Integer(layerNumber));
```

### Rules

* Higher layer number â†’ appears **on top**
* Same layer â†’ overlap depends on addition order

Example:

| Component   | Layer               |
| ----------- | ------------------- |
| Red label   | 0                   |
| Green label | 1                   |
| Blue label  | 2                   |
| Black label | changes dynamically |


## 6. Creating Radio Buttons (Layer Controls)

* Three radio buttons: Red, Green, Blue
* Added to a `ButtonGroup`
* Added to a top panel (`NORTH`)
* `ActionListener` detects selection
* Selection decides the **layer of the black label**


## 7. Creating Colored Labels

Each colored panel is actually a `JLabel`:

Key steps:

1. Set bounds (absolute positioning)
2. Set background color
3. Make it opaque

```java
label.setBounds(x, y, width, height);
label.setBackground(Color.RED);
label.setOpaque(true);
```

Different bounds are used so panels **partially overlap**, making layers visible.


## 8. Adding Components to JLayeredPane

```java
JLayeredPane lp = new JLayeredPane();

lp.add(redLabel, new Integer(0));
lp.add(greenLabel, new Integer(1));
lp.add(blueLabel, new Integer(2));
lp.add(blackLabel, new Integer(3));
```

This controls the **z-order** (depth).


## 9. Moving the Black Label with Mouse

### Event Used

`MouseMotionListener`

### Logic

* Track mouse position
* Move black label to mouse coordinates

```java
label.setLocation(e.getX(), e.getY());
```

Result:

* Black box follows the mouse smoothly


## 10. Changing Layers Dynamically

### Method Used

```java
lp.setLayer(component, layerNumber);
```

### Based on Radio Button Selection

* Red selected â†’ black label above red
* Green selected â†’ black label above green
* Blue selected â†’ black label above blue

This is the **core power of JLayeredPane**.


## 11. Layout Used

* Radio button panel â†’ `BorderLayout.NORTH`
* Layered pane â†’ `BorderLayout.CENTER`

âš  `JLayeredPane` usually uses **absolute positioning**, so `setBounds()` is required.


## 12. Important Learning Points (â­ Exam Focus)

* `JLayeredPane` supports overlapping components
* Components are arranged using **layer numbers**
* Higher layer â†’ appears in front
* `setLayer()` allows **dynamic layer changes**
* Commonly used for:

  * Multi-step forms
  * Popups
  * Drag-and-drop visuals
  * Game UIs
* Mouse events + layered panes = interactive UI


## 13. Common Exam / Viva Questions

* What is `JLayeredPane`?
* Difference between `JPanel` and `JLayeredPane`
* Why is `setOpaque(true)` required?
* How do you move a component with the mouse?
* How do you change component layers dynamically?


## 14. Summary

`JLayeredPane` adds a **third dimension** to Swing GUIs.

With it, you can:

* Stack components
* Control visibility using layers
* Create dynamic, interactive interfaces
* Manage multiple panels inside one frame

# **JInternalFrame in Java Swing â€“ Structured Learning Notes**


### 1. **JInternalFrame**

* A child window that exists **inside a JFrame**
* Can be:

  * Minimized (iconified)
  * Maximized
  * Closed
  * Selected (only one active at a time)
* Commonly used in applications like:

  * Text editors
  * Drawing tools
  * IDEs
  * Document-based software (MS Wordâ€“style)


### 2. **JDesktopPane**

* Acts as a **container for multiple JInternalFrame objects**
* Must be set as the **content pane** of the main JFrame
* Without JDesktopPane, internal frames cannot function properly

ðŸ“Œ **Important Rule**

> JInternalFrame **must** be added to a JDesktopPane.


### 3. **Multi-Document Interface (MDI)**

* Allows multiple documents to be open simultaneously
* Each document is represented by a **JInternalFrame**
* Only one internal frame can be selected at a time


## **Application Architecture**

### **Main Components**

| Component        | Purpose                     |
| ---------------- | --------------------------- |
| `JFrame`         | Main application window     |
| `JDesktopPane`   | Hosts internal frames       |
| `JInternalFrame` | Individual document windows |
| `JTextArea`      | Document content            |
| `JScrollPane`    | Automatic scrollbars        |
| `JMenuBar`       | Menu system (New Document)  |


## **Class Design**

### **1. MyInternalFrame (Custom Internal Frame)**

**Why create a custom class?**

* To include:

  * Text area
  * Scroll pane
  * Menu bar
  * Automatic document numbering

#### Responsibilities:

* Extend `JInternalFrame`
* Maintain a static document counter
* Set size, position, and visibility
* Enable window controls (resize, close, maximize, minimize)

#### Features Implemented:

* Title: `Document 1`, `Document 2`, â€¦
* Scrollable text editor
* Internal menu (File â†’ Save)
* Fixed starting position
* Fully controllable window behavior

ðŸ“Œ **Constructor Flags Used**

```java
JInternalFrame(title, true, true, true, true)
```

| Flag        | Meaning |
| ----------- | ------- |
| Resizable   | âœ”       |
| Closable    | âœ”       |
| Maximizable | âœ”       |
| Iconifiable | âœ”       |


### **2. MyFrame (Main Application Window)**

#### Responsibilities:

* Extend `JFrame`
* Set `JDesktopPane` as content pane
* Create menu bar (Document â†’ New)
* Handle menu events
* Create and add internal frames dynamically


## **Event Handling Flow**

### **Menu Action: New Document**

1. User clicks **Document â†’ New**
2. `actionPerformed()` is triggered
3. A new `MyInternalFrame` object is created
4. Internal frame is added to `JDesktopPane`
5. Document becomes visible and selectable


## **Functional Highlights**

* Multiple documents can be open at once
* Each document has:

  * Independent text area
  * Scrollbars auto-appear when needed
* Internal frames can:

  * Move
  * Overlap
  * Be minimized/maximized
* Only one internal frame can be active at a time


## **Conceptual Analogy**

Think of:

* **JFrame** â†’ Desktop monitor
* **JDesktopPane** â†’ Desktop workspace
* **JInternalFrame** â†’ Application windows (Word documents)


## **Common Use Cases**

* Text editors
* Diagram editors
* Banking back-office tools
* IDE-like applications
* Multi-form business systems


## **Potential Confusion Points (Clarified)**

| Confusion                         | Clarification                                                         |
| --------------------------------- | --------------------------------------------------------------------- |
| Why not use JFrame for documents? | JFrame opens separate OS windows; JInternalFrame stays inside one app |
| Why static counter?               | To ensure unique document numbering across all instances              |
| Why JScrollPane needed?           | JTextArea alone doesnâ€™t support scrolling                             |


## **Summary**

* **JInternalFrame** allows multiple child windows inside a single JFrame
* **JDesktopPane** is mandatory for hosting internal frames
* This architecture enables **MDI applications**
* Menus and events control document creation
* Swing provides full window control (close, maximize, minimize)

# **JSplitPane and JTabbedPane in Java Swing â€“ Structured Learning Notes**

### 1. **JSplitPane**

A `JSplitPane` divides a container into **two resizable regions**.

Common analogy:

> The vertical splitter in Windows File Explorer

#### Types of Splits:

* `JSplitPane.HORIZONTAL_SPLIT` â†’ Left / Right
* `JSplitPane.VERTICAL_SPLIT` â†’ Top / Bottom

#### Features:

* Movable divider
* Adjustable divider location
* Each side can contain **any component**


### 2. **Application Demonstrated**

The example application contains:

| Left Pane          | Right Pane             |
| ------------------ | ---------------------- |
| Color list (JList) | Color display (JLabel) |

When a color is selected from the list, the right pane updates its background color accordingly.


## **Component Structure**

### **Main Components Used**

| Component               | Purpose                       |
| ----------------------- | ----------------------------- |
| `JFrame`                | Main application window       |
| `JSplitPane`            | Splits the window             |
| `JList`                 | Displays selectable colors    |
| `JLabel`                | Displays color output         |
| `JScrollPane`           | Adds scrolling support        |
| `ListSelectionListener` | Handles list selection events |


## **Modelâ€“View Concept (Important Theory)**

* **Model** â†’ Data (array of color strings)
* **View** â†’ UI component (`JList`)
* Swing separates **data** from **presentation**

This improves:

* Maintainability
* Flexibility
* Reusability


## **Detailed Breakdown: JSplitPane Implementation**

### **Step 1: Prepare Data (Model)**

* An array of color names (`String[]`)
* Acts as the **data source**


### **Step 2: Create JList (View)**

* `JList` is created using the color array
* Wrapped inside a `JScrollPane` to support scrolling


### **Step 3: Prepare Right Pane**

* A `JLabel` is used to display color
* `setOpaque(true)` is required for background color to appear
* Wrapped inside another `JScrollPane`


### **Step 4: Create JSplitPane**

```java
new JSplitPane(
    JSplitPane.HORIZONTAL_SPLIT,
    leftScrollPane,
    rightScrollPane
)
```


### **Step 5: Adjust Divider**

* `setDividerLocation(200)`
* Ensures better visual balance


### **Step 6: Initial State**

* First list item selected using:

```java
list.setSelectedIndex(0);
```

* Initial color set to **Red**


## **Event Handling: ListSelectionListener**

### **Why ListSelectionListener?**

* Triggers when selection changes in a `JList`
* More appropriate than MouseListener or KeyListener


### **Event Flow**

1. User selects a color
2. `valueChanged()` method is triggered
3. Selected value is retrieved
4. Color of label is updated using `switch`


### **Key Technical Note**

* `getSelectedValue()` returns `Object`
* Must be **typecast** to `String`


## **Color Update Logic**

* Implemented using `switch-case`
* Each case updates label background color


## **JSplitPane Summary**

* Splits UI into two dynamic sections
* Divider can be resized at runtime
* Ideal for **masterâ€“detail layouts**
* Common in file managers and admin tools



# **JTabbedPane â€“ Alternative Layout**


## **What is JTabbedPane?**

A `JTabbedPane` organizes components into **clickable tabs**.

ðŸ“Œ Analogy:

> Browser tabs (Chrome, Firefox)


## **Why Use Tabs Instead of Split Pane?**

| JSplitPane                           | JTabbedPane                   |
| ------------------------------------ | ----------------------------- |
| Shows both components simultaneously | Shows one component at a time |
| Resizable divider                    | Tab-based navigation          |
| Good for comparison                  | Good for compact UI           |


## **Conversion: Split Pane â†’ Tabbed Pane**

### **Steps**

1. Remove `JSplitPane`
2. Create `JTabbedPane`
3. Add components as tabs

```java
tp.addTab("Colors", scrollPane1);
tp.addTab("Display", scrollPane2);
```


### **Result**

* One tab shows color list
* Another tab shows color display
* Same logic works across tabs
* Data is shared between tabs


## **Key Insight**

Even though components are on different tabs:

* They belong to the **same application**
* Events and data updates work seamlessly


## **Common Use Cases**

### **JSplitPane**

* File explorers
* Admin dashboards
* Configuration tools
* IDE layouts

### **JTabbedPane**

* Forms with multiple sections
* Settings screens
* Browsers
* Multi-step workflows


## **Potential Confusion Points (Clarified)**

| Confusion                   | Clarification                                 |
| --------------------------- | --------------------------------------------- |
| Why JScrollPane for JLabel? | Ensures consistent layout and scalability     |
| Why setOpaque(true)?        | JLabel wonâ€™t show background color otherwise  |
| Can tabs communicate?       | Yes, they share the same data and event logic |
| AWT alternative?            | CardLayout (less powerful than JTabbedPane)   |


## **Summary**

* **JSplitPane** divides a window into two resizable sections
* **JTabbedPane** organizes components into tabs
* Both simplify complex UI design
* Event handling allows components to interact
* Swing offers advanced layout control compared to AWT


# **Java Swing â€“ JSlider and JProgressBar**


1. **JSlider** â€“ a control for selecting values within a range (similar to a scroll bar).
2. **JProgressBar** â€“ a visual component showing progress or task completion.

Both are essential for **interactive UIs** where user input or progress feedback is required.

## **1. JSlider**

### **Key Features**

* Represents **a value within a range** (min â†’ max)
* Can be **horizontal or vertical**
* Supports **major ticks** (e.g., 0, 10, 20 â€¦)
* Supports **minor ticks** (e.g., every 1 unit)
* Labels can be painted to display tick values


### **Important Properties**

| Property                   | Description                        |
| -------------------------- | ---------------------------------- |
| `setMajorTickSpacing(int)` | Interval for major ticks           |
| `setMinorTickSpacing(int)` | Interval for minor ticks           |
| `setPaintTicks(true)`      | Show tick marks on slider          |
| `setPaintLabels(true)`     | Show numeric labels on major ticks |


### **Constructor Variants**

1. `JSlider()` â€“ default horizontal slider, 0â€“100
2. `JSlider(min, max)` â€“ range with default value
3. `JSlider(min, max, initialValue)` â€“ range with initial value
4. `JSlider(orientation, min, max, initialValue)` â€“ allows vertical/horizontal orientation


## **2. JProgressBar**

### **Key Features**

* Shows progress of a task (like download or installation)
* Can be **horizontal or vertical**
* Can display percentage text
* Can be **indeterminate** (for unknown task length)


### **Important Properties**

| Property                       | Description                        |
| ------------------------------ | ---------------------------------- |
| `setString("text")`            | Set text displayed on progress bar |
| `setStringPainted(true)`       | Show text on progress bar          |
| `setValue(int)`                | Update progress value dynamically  |
| `setIndeterminate(true/false)` | Animates if progress unknown       |


## **3. Example Application: Slider + Progress Bar + Circle**

### **UI Layout**

* **BorderLayout**:

  * **North** â†’ Slider
  * **Center** â†’ Panel for drawing circle
  * **South** â†’ Panel containing progress bar

### **Components**

| Component        | Purpose                                                 |
| ---------------- | ------------------------------------------------------- |
| `JSlider`        | Controls the size of the circle                         |
| `JPanel`         | Area where circle is drawn (overrides `paintComponent`) |
| `JProgressBar`   | Shows percentage value of slider                        |
| `ChangeListener` | Updates circle and progress bar dynamically             |


### **Implementation Steps**

#### **Step 1: Create Slider**

```java
JSlider slider = new JSlider(JSlider.HORIZONTAL, 0, 100, 50);
slider.setMajorTickSpacing(10);
slider.setMinorTickSpacing(1);
slider.setPaintTicks(true);
slider.setPaintLabels(true);
```

#### **Step 2: Create Progress Bar**

```java
JProgressBar pb = new JProgressBar();
pb.setStringPainted(true);
pb.setValue(slider.getValue());
```

#### **Step 3: Create Drawing Panel**

* Override `paintComponent(Graphics g)` in `JPanel`
* Draw a circle using current slider value:

```java
int size = slider.getValue();
g.fillOval(200, 200, size, size);
```

#### **Step 4: Add Components to JFrame**

```java
add(slider, BorderLayout.NORTH);
add(circlePanel, BorderLayout.CENTER);
add(progressPanel, BorderLayout.SOUTH);
```

#### **Step 5: Add Event Handling**

* Implement `ChangeListener` for slider

```java
slider.addChangeListener(new ChangeListener() {
    public void stateChanged(ChangeEvent e) {
        int value = slider.getValue();
        circlePanel.repaint();
        pb.setValue(value);
        pb.setString(value + "%");
    }
});
```


### **Key Notes**

* In **Swing**, drawing is done in `paintComponent()`, not `paint()`.
* Slider values must be **retrieved using `getValue()`**
* Progress bar string must be painted (`setStringPainted(true)`)
* Indeterminate mode is useful for unknown progress tasks
* Proper layout managers (`BorderLayout`) ensure correct placement


## **Summary**

* **JSlider** allows user-controlled input within a range
* **JProgressBar** provides visual feedback of progress
* Both can interact dynamically (slider value â†’ circle size & progress bar)
* Essential for interactive Swing applications (games, tools, installers)


# **Java Swing â€“ JComboBox, JList, and JSpinner**

These components are **used to select items from a collection of values**.

## **1. JComboBox (Dropdown)**

### **Key Features**

* Shows **one selected item at a time**
* Clicking the combo box displays the **full list**
* Selection can trigger **events**

### **Implementation**

```java
String[] countries = {"India", "USA", "UK", "Nepal"};
JComboBox<String> cb = new JComboBox<>(countries);
```

### **Event Handling**

* Implements `ActionListener`

```java
cb.addActionListener(this); // 'this' implements ActionListener
```

```java
@Override
public void actionPerformed(ActionEvent e) {
    textField.setText((String) cb.getSelectedItem());
}
```


## **2. JList (List Box)**

### **Key Features**

* Shows **multiple items at a time**
* Supports **single or multiple selection** (`Ctrl` or `Command` key)
* Usually **scrollable**, added inside `JScrollPane`

### **Implementation**

```java
String[] months = {"January", "February", "March", "April", "May"};
JList<String> list = new JList<>(months);
list.setVisibleRowCount(5);  // show 5 items at a time
JScrollPane scrollPane = new JScrollPane(list);
```

### **Event Handling**

* Implements `ListSelectionListener`

```java
list.addListSelectionListener(this);
```

```java
@Override
public void valueChanged(ListSelectionEvent e) {
    textField.setText((String) list.getSelectedValue());
}
```


## **3. JSpinner (Spinner)**

### **Key Features**

* Allows **increment/decrement** of values
* Can be **numeric or list-based**
* Triggers **ChangeEvent** on value change

### **Types**

1. **Numeric Spinner**

```java
JSpinner spinner1 = new JSpinner(new SpinnerNumberModel(1, 1, 31, 1));
```

* Initial value: 1
* Minimum: 1
* Maximum: 31
* Step increment: 1

2. **List Spinner**

```java
String[] days = {"Monday", "Tuesday", "Wednesday"};
JSpinner spinner2 = new JSpinner(new SpinnerListModel(days));
```

### **Event Handling**

* Implements `ChangeListener`

```java
spinner1.addChangeListener(this);
spinner2.addChangeListener(this);
```

```java
@Override
public void stateChanged(ChangeEvent e) {
    if (e.getSource() == spinner1) {
        textField.setText(String.valueOf(spinner1.getValue()));
    } else {
        textField.setText((String) spinner2.getValue());
    }
}
```


## **4. Layout & Adding Components**

* Use **FlowLayout** or any suitable layout:

```java
setLayout(new FlowLayout());
add(cb);
add(spinner1);
add(spinner2);
add(scrollPane);
add(textField);
```


## **5. Key Notes**

* **JComboBox** â†’ Single selection visible, dropdown only
* **JList** â†’ Multiple selection possible, scrollable
* **JSpinner** â†’ Increment/decrement numeric or list values
* Swing uses **MVC pattern**:

  * **Model** â†’ Data (array or SpinnerModel)
  * **View** â†’ Component (JComboBox, JList, JSpinner)
  * **Controller** â†’ Event listener


## **6. Summary**

* All three components allow **item selection**
* Events must be handled according to the **type of component**
* Use **JScrollPane** for long lists
* Numeric spinners are useful for dates, counts, etc.
* List spinners are useful for predefined string sets (days, months)


# **Java Swing â€“ JMenuBar, JMenuItem, and JToolBar**

Swing provides **ready-made classes** for menus and toolbars to make desktop applications more interactive.


## **1. Toolbar (JToolBar)**

### **Key Features**

* Holds **buttons with icons or text**
* Can be **detachable/floating** or docked at a frame border
* Used for **quick access to common actions**

### **Implementation**

```java
JToolBar tb = new JToolBar();
JButton b1 = new JButton(new ImageIcon("resource/images/open.png"));
JButton b2 = new JButton(new ImageIcon("resource/images/save.png"));
// create other buttons similarly

// Add buttons to toolbar
tb.add(b1);
tb.add(b2);
tb.addSeparator(); // optional separator to group buttons
```

### **Adding Toolbar to JFrame**

```java
add(tb, BorderLayout.NORTH);  // toolbar docked at top
```

> **Tip:** Images for buttons should be small (e.g., 32x32 px) and placed in a resource folder.


## **2. Menu (JMenuBar, JMenu, JMenuItem)**

### **Key Features**

* Standard menu system for desktop apps
* Can have **multiple menus** (File, Edit, View, etc.)
* Each menu can have **menu items**
* Supports **mnemonics (shortcuts)**

### **Implementation**

```java
JMenuBar mb = new JMenuBar();      // menu bar
JMenu fileMenu = new JMenu("File"); // menu

JMenuItem saveItem = new JMenuItem("Save");
JMenuItem openItem = new JMenuItem("Open");
openItem.setMnemonic(KeyEvent.VK_O); // shortcut: Alt+O

fileMenu.add(saveItem);
fileMenu.addSeparator();  // adds a line separator
fileMenu.add(openItem);

mb.add(fileMenu);
setJMenuBar(mb);           // add menu bar to frame
```


## **3. JTextArea for Editing**

* Use `JTextArea` as the main text component
* Wrap it inside `JScrollPane` to make it scrollable

```java
JTextArea ta = new JTextArea();
JScrollPane sp = new JScrollPane(ta);
add(sp, BorderLayout.CENTER);
```


## **4. Action Handling**

* Buttons and menu items generate **ActionEvent**
* Can use the **same ActionListener** for both

```java
b1.addActionListener(this);
openItem.addActionListener(this);

@Override
public void actionPerformed(ActionEvent e) {
    String command = e.getActionCommand();
    if (command.equals("Open")) {
        // handle file open
    } else if (command.equals("Save")) {
        // handle file save
    }
}
```

> **Note:** Image buttons donâ€™t have a visible label, so you can set an **action command** manually if needed:

```java
b1.setActionCommand("Open");
```


## **5. Summary**

| Component     | Purpose                                   |
| ------------- | ----------------------------------------- |
| **JToolBar**  | Quick access buttons with icons/text      |
| **JMenuBar**  | Container for menus                       |
| **JMenu**     | Individual menu (File, Edit, etc.)        |
| **JMenuItem** | Menu item (Open, Save, etc.)              |
| **JTextArea** | Main editing area, usually in JScrollPane |

* Toolbars can **float/dock**
* Menus support **mnemonics and separators**
* Buttons and menu items can **share action listeners**


# **Java Swing â€“ ActionListener, JFileChooser, and JColorChooser**

Swing allows you to **handle user actions** like button clicks or menu selections using **ActionListener**. You can also let users **choose files or colors** with JFileChooser and JColorChooser.


## **1. Adding ActionListener**

### **Step 1: Implement ActionListener**

```java
public class MyFrame extends JFrame implements ActionListener {
    JButton b1, b2;
    JMenuItem m1, m2;
    JTextArea ta;

    public MyFrame() {
        // Initialize buttons, menu items, and text area
        b1 = new JButton("Save");
        b2 = new JButton("Open");
        m1 = new JMenuItem("Save");
        m2 = new JMenuItem("Open");

        // Set action commands (useful for buttons with icons)
        b2.setActionCommand("Open");
        b1.setActionCommand("Save");

        // Add ActionListener
        b1.addActionListener(this);
        b2.addActionListener(this);
        m1.addActionListener(this);
        m2.addActionListener(this);
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        String command = ae.getActionCommand();
        if (command.equals("Open")) {
            openFile();
        } else if (command.equals("Save")) {
            chooseColor();
        }
    }
}
```

> **Tip:** Buttons with **icons** do not have text, so you must set `setActionCommand` to identify them in the listener.


## **2. File Chooser (JFileChooser)**

### **Step 1: Open a File**

```java
private void openFile() {
    try {
        JFileChooser fc = new JFileChooser();
        int choice = fc.showOpenDialog(this); // this = parent JFrame
        if (choice == JFileChooser.APPROVE_OPTION) {
            File f = fc.getSelectedFile();
            FileInputStream fis = new FileInputStream(f);

            byte[] b = new byte[fis.available()];  // read all bytes
            fis.read(b);
            String str = new String(b);           // convert bytes to string

            ta.setText(str);                      // set text to JTextArea
            fis.close();                           // close the stream
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

* `showOpenDialog(this)` opens the file chooser with the JFrame as parent
* `getSelectedFile()` returns the selected file
* Use `FileInputStream` to **read file contents**


## **3. Color Chooser (JColorChooser)**

### **Step 1: Choose a Font Color**

```java
private void chooseColor() {
    Color col = JColorChooser.showDialog(
        this,               // parent JFrame
        "Font Color",       // dialog title
        Color.RED           // initial color
    );
    if (col != null) {
        ta.setForeground(col); // set text color
    }
}
```

* Opens a color chooser dialog
* Returns a `Color` object
* Apply to `JTextArea` using `setForeground()`


## **4. Summary of Integration**

| Component            | Usage                                                               |
| -------------------- | ------------------------------------------------------------------- |
| **ActionListener**   | Handles events from buttons & menu items                            |
| **JFileChooser**     | Open file dialog and read file contents                             |
| **JColorChooser**    | Open color picker dialog and change text color                      |
| **setActionCommand** | Assign a command to a button or icon for identification in listener |

### **Flow**

1. User clicks a button or menu item
2. `actionPerformed()` is triggered
3. Check `getActionCommand()` to identify action
4. Call relevant method (`openFile()` or `chooseColor()`)


âœ… **Resulting Behavior in Your App**

* Toolbar buttons and menu items share the same event listener
* Clicking **Open** opens a file and displays content in JTextArea
* Clicking **Save (used for color)** opens a color chooser and changes font color
