
# Introduction to Generics 

## 1. Background: Object Class and Generalization

### The `Object` Class

* `Object` is the **topmost parent class** in Java
* Located in `java.lang`
* Every Java class **directly or indirectly extends Object**

```java
Object obj = "Hello";   // Valid
Object obj = 10;        // Valid (Integer object)
```

### Why Object Enables Generalization

* A reference of type `Object` can hold:

  * `String`
  * `Integer`
  * Any custom class
* This allows **generalization** (one reference ‚Üí many types)

---

## 2. The Core Problem with Object-Based Generalization

### Problem 1: Mandatory Typecasting

```java
Object obj = new String("Hello");
String str = (String) obj; // Typecasting required
```

* Without casting ‚Üí compile-time error
* Typecasting is unavoidable when retrieving data

---

### Problem 2: No Compile-Time Type Checking

```java
Object obj = new String("Hello");
obj = new Integer(10)
String str = (String) obj; // No compile-time error

```
Though Integer object is being casted to String, no compile-time checking provided. You get RunTime Error. 

**Compiler allows it**
**Runtime crash occurs**

```text
ClassCastException: Integer cannot be cast to String
```

---

### Problem 3: Runtime Errors Instead of Compile-Time Errors

* Compiler does not verify correctness
* Errors appear **only during execution**
* Leads to unstable and unsafe programs

---

## 3. Object Array Example (Real Problem Scenario)

### Creating an Object Array

```java
Object[] obj = new Object[3];
obj[0] = "Hi";
obj[1] = "Bye";
obj[2] = 10;   // Mistake, but compiler allows it
```

### Programmer‚Äôs Intention

* Store **only Strings**

### Reality

* Compiler allows **any Object**
* Programmer mistake is not detected

---

### Runtime Failure

```java
public static void main(String[] args) {
  Object[] obj = new Object[3];
  obj[0] = "Hi";
  obj[1] = "Bye";
  obj[2] = new Integer(10);  

  String str; 
  for (int i = 0; i < 3; i++) {
    str = (String) obj[i];
    System.out.println(str);
  }
}
```

- First two values print
- Third value crashes

```text
ClassCastException: Integer cannot be cast to String
```

---

## 4. Summary of Problems Before Generics

| Issue                  | Explanation              |
| ---------------------- | ------------------------ |
| ‚ùå No Type Safety       | Any object can be stored |
| ‚ùå Forced Typecasting   | Required when reading    |
| ‚ùå Runtime Errors       | Errors detected too late |
| ‚ùå Programmer-Dependent | No compiler protection   |

---

## 5. Introduction to Generics (Java 1.5+)

### What Are Generics?

* A way to write **type-safe, reusable code**
* Enforces **compile-time type checking**
* Eliminates unnecessary typecasting

---

## 6. Generic Class Concept

### Generic Type Parameter

* Usually written as `T`
* Acts as a **placeholder for a real type**

```java
class GenericDemo<T> {
  T[] data;
}
```

‚ö† Java does not allow direct creation of generic arrays

---

### Correct Generic Array Creation

```java
data = (T[]) new Object[3];
```

‚úî Internally uses `Object[]`
‚úî Externally behaves like `T[]`

---

## 7. Using the Generic Class

### Creating a String-Type Generic Object & Storing Valid Data

```java
public class GenericDemo<T> {
  T data[] = (T[]) new Object[3];

  public static void main(String[] args) {
    GenericDemo<String> gd = new GenericDemo<>();
    gd.data[0] = "Hi";
    gd.data[1] = "Bye";
    String s = gd.data[0];
  }
}
```

* `T` becomes `String`
* `data` behaves like `String[]`

---


### Invalid Assignment (Compile-Time Error)

```java
gd.data[2] = 10;  // ‚ùå Error
```

‚úî Error detected **before execution**

---

## 8. Benefits of Generics (Key Takeaways)

### ‚úÖ Compile-Time Type Safety

* Errors caught early
* No runtime surprises

### ‚úÖ No Typecasting Required

```java
String s = gd.data[0];  // No cast needed
```

### ‚úÖ Cleaner, Safer Code

* Intent is clearly defined
* Compiler enforces correctness

### ‚úÖ Generalization with Control

* Can store **any type**
* But only **one specified type at a time**

---

## Comparison: Object vs Generics

| Feature         | Object    | Generics     |
| --------------- | --------- | ------------ |
| Type Safety     | ‚ùå No      | ‚úÖ Yes        |
| Typecasting     | Mandatory | Not needed   |
| Error Detection | Runtime   | Compile-time |
| Code Clarity    | Poor      | Excellent    |

---

# Summary

* Before Java 1.5, **Object** was used for generalization
* Object-based design caused:

  * No type safety
  * Mandatory typecasting
  * Runtime `ClassCastException`
* **Generics** solve these problems by:

  * Enforcing compile-time checks
  * Eliminating unsafe assignments
  * Improving code readability and safety
* A generic class can:

  * Work with any type
  * Restrict usage to a specific type when instantiated

---


Below is a **clean, structured, and exam-ready explanation** of this lecture on **Generics with Examples**, distilled from your transcript and aligned with how Java actually uses generics in practice.

---

# Defining Generic Class

## Key Idea to Remember First

> **Generics allow a class to work with any object type, but only ONE type at a time, enforced at compile time.**

---

## Example 1: Generic Class to Store One Value

### Requirement

* Create a class that can store **one object**
* It should support **any type** (String, Integer, Student, etc.)
* Once a type is specified, **only that type should be allowed**

---

## Step 1: Define a Generic Class

```java
class Data<T> {
  private T obj;

  public void setData(T value) {
    obj = value;
  }

  public T getData() {
    return obj;
  }
}
```

### Explanation

* `T` is a **generic type parameter**
* `T` represents **any object type**
* `obj` can store **only one object**
* The class itself is reusable for any type

---

## Step 2: Using the Generic Class (Integer Example)

```java
public class GenericDemo {
  public static void main(String[] args) {
    Data<Integer> d = new Data<>();
    d.setData(10);
    System.out.println(d.getData());
  }
}
```

### Important Notes

* `Integer` replaces `T`
* Autoboxing occurs (`10` ‚Üí `Integer`)
* No typecasting required
* Output: `10`

---

## Compile-Time Type Safety

```java
d.setData("Hi"); // ‚ùå Compile-time error
```

‚úî Error caught **before running the program**

---

## Step 3: Using the Same Class for String

```java
public class GenericDemo {
  public static void main(String[] args) {
    Data<String> d = new Data<>();
    d.setData("Hi");
    System.out.println(d.getData());
  }
}
```

‚úî Works correctly
‚úî Same class, different type

---

## Key Observations (Example 1)

| Feature                 | Result                          |
| ----------------------- | ------------------------------- |
| One class               | Works for all object types      |
| Type specified at usage | `Data<String>`, `Data<Integer>` |
| Wrong type assignment   | Compile-time error              |
| Typecasting             | ‚ùå Not required                  |

---

## Example 2: Generic Array Class

### Requirement

* Create a class similar to an array
* Should store **multiple elements**
* Should support **any type**
* Should allow:

  * `append()` ‚Üí add element
  * `display()` ‚Üí print elements

---

## Step 1: Generic Class Definition

```java
class MyArray<T> {
  T[] A;
  int length = 0;

  @SuppressWarnings("unchecked")
  public MyArray() {
    A = (T[]) new Object[10];
  }

  public void append(T value) {
    A[length++] = value;
  }

  public void display() {
    for (int i = 0; i < length; i++) {
      System.out.println(A[i]);
    }
  }
}
```

---

## Why `Object[]` is Used Internally

```java
A = new T[10]; // Invalid
```
This is NOT allowed: We cannot create an array of type Generic. 

‚úî Correct approach: Create an array of type Object and type-cast it as Generic. 

```java
A = (T[]) new Object[10];
```

### Reason

* Java does not allow direct creation of generic arrays
* This is due to **type erasure**
* Compiler warning appears ‚Üí handled using `@SuppressWarnings`

---

## Step 2: Using MyArray with Integers

```java
public class GenericDemo {
  public static void main(String[] args) {
    MyArray<Integer> ma = new MyArray<>();
    ma.append(10);
    ma.append(20);
    ma.append(30);
    ma.display();
  }
}
```

### Output

```
10
20
30
```

‚úî Type-safe
‚úî No casting
‚úî Compile-time checking

---

## Step 3: Using the Same Class with Strings

```java
public class GenericDemo {
  public static void main(String[] args) {  
    MyArray<String> ma = new MyArray<>();
    ma.append("A");
    ma.append("B");
    ma.append("C");
    ma.display();
  }
}
```

### Output

```
A
B
C
```

‚úî Same class
‚úî Different data type
‚úî No code duplication

---

## What Happens If You Store Wrong Type?

```java
ma.append(10); // ‚ùå Compile-time error
```

‚úî Error caught immediately
‚úî Prevents runtime crashes

---

## Why the Warning Occurs (Unchecked Cast)

```java
A = (T[]) new Object[10];
```

* Compiler warns about unchecked conversion
* This is unavoidable in generic array creation
* Safe here because access is controlled
* Suppressed using:

```java
@SuppressWarnings("unchecked")
```

---

## Why This Is Important (Real Java Usage)

* All **Collection Framework classes** use generics:

  * `ArrayList<T>`
  * `HashMap<K, V>`
  * `Set<T>`
* Understanding this helps you:

  * Use collections correctly
  * Avoid `ClassCastException`
  * Write reusable libraries

---

## Summary (High-Value Takeaways)

* Generics allow **type-safe generalization**
* A generic class:

  * Works for any object type
  * Enforces one specific type per instance
* Benefits over `Object`:

  * ‚úÖ Compile-time checking
  * ‚úÖ No runtime `ClassCastException`
  * ‚úÖ No typecasting
* Generic arrays:

  * Cannot be created directly
  * Use `Object[]` + casting internally
* These concepts form the **foundation of Java Collections**

---

Below is the **optimized learning material** created from your YouTube transcript, following pedagogical structuring and clarity improvements.

---

# Bounds on Generics

## 1Ô∏è‚É£ Generics Without Type Parameters (Raw Types)

### üîπ Concept

If you **do not specify a generic type parameter**, Java treats the generic type as `Object`.
This is known as using a **raw type**.

### üîπ Example

```java

public class GenericDemo {
  public static void main(String[] args) {    
    MyArray arr = new MyArray(); // No generic parameter
    arr.append("Hi");
    arr.append(10);
    arr.append("Go");
    arr.display();
  }
}
```

### üîπ What Happens?

* The compiler **allows mixed types**
* Internally, everything becomes `Object`
* You will receive **unchecked warnings**
* Type safety is **lost**

### üîπ Why It Works

* Java defaults `T` ‚Üí `Object`
* Autoboxing allows primitive values like `10` ‚Üí `Integer`

### ‚ö†Ô∏è Warning

Using raw types is discouraged because:

* Errors move from **compile-time to runtime**
* Type safety is compromised

‚úÖ **Conclusion**
If no generic parameter is provided:

```java
MyArray<T> ‚Üí MyArray<Object>
```

---

## 2Ô∏è‚É£ Multiple Generic Parameters

### üîπ Concept

Java allows **multiple generic parameters** in a class.

### üîπ Syntax

```java
class MyArray<T, K> {
  T[] A;
  int length = 0;

  @SuppressWarnings("unchecked")
  public MyArray() {
    A = (T[]) new Object[10];
  }

  public void append(T value) {
    A[length++] = value;
  }

  public void display() {
    for (int i = 0; i < length; i++) {
      System.out.println(A[i]);
    }
  }
}
```

### üîπ Usage

```java
MyArray<Integer, String> obj = new MyArray<>();
```

### üîπ Common Use Case

* **Key‚ÄìValue pairs** (e.g., `Map<K, V>`)

NOTE:  If parameters are omitted:

```java
MyArray ‚Üí MyArray<Object, Object>
```

---

## 3Ô∏è‚É£ Generics and Inheritance (Subtypes)

```java 
class MyArray<T> {
  T[] A;
  int length = 0;

  @SuppressWarnings("unchecked")
  public MyArray() {
    A = (T[]) new Object[10];
  }

  public void append(T value) {
    A[length++] = value;
  }

  public void display() {
    for (int i = 0; i < length; i++) {
      System.out.println(A[i]);
    }
  }
}
```

### üîπ Rule 1: Extending Without Specifying Type

```java
class MyArray2 extends MyArray { }
```

* `MyArray` defaults to `Object`
* `MyArray2` works only with `Object`

---

### üîπ Rule 2: Fixing the Type in Subclass

```java
class MyArray2 extends MyArray<String> { }

public class GenericDemo {
  public static void main(String[] args) {
    MyArray2 ma = new MyArray2();
    ma.append(10);
    ma.append("Bye");
    ma.append("Hello");
    ma.display();
  }
}
```

* `MyArray2` becomes **String-only**
* Cannot store `Integer`

---

### üîπ Rule 3: Propagating Generic Type

```java
class MyArray2<T> extends MyArray<T> { }
```

* Subclass remains generic
* Type passed at object creation flows to both classes

```java
MyArray2<String> obj = new MyArray2<>();
```

**Golden Rule**

> If a subclass wants flexibility, it **must also be generic**.

---

## 4Ô∏è‚É£ Bounded Generic Types (Upper Bounds)

### üîπ Concept

Bounds restrict what types a generic can accept.

### üîπ Syntax

```java
class MyArray<T extends Number> { }
```

### üîπ Allowed Types

‚úî Integer
‚úî Float
‚úî Double
‚úî Long

‚ùå String (not a subclass of `Number`)

---

### üîπ Example

```java
MyArray<Float> arr = new MyArray<>();
arr.append(12.5f);
```

---

## 5Ô∏è‚É£ Bounded Types with Custom Classes

### üîπ Class-Based Bound

```java
class A { }
class B extends A { }
class C extends A { }

class MyArray<T extends A> {
  T[] A;
  int length = 0;

  @SuppressWarnings("unchecked")
  public MyArray() {
    A = (T[]) new Object[10];
  }

  public void append(T value) {
    A[length++] = value;
  }

  public void display() {
    for (int i = 0; i < length; i++) {
      System.out.println(A[i]);
    }
  }
}

public class GenericDemo {
  public static void main(String[] args) {
    MyArray<A> ma = new MyArray<>();
    MyArray<B> mb = new MyArray<>();
    MyArray<C> mc = new MyArray<>();
    MyArray<String> ms = new MyArray<>(); // ERROR
  }
}

```

‚úî Allowed: `A`, `B`, `C`
‚ùå Not allowed: `String`

---

## 6Ô∏è‚É£ Bounds with Interfaces

### üîπ Important Rule

Even for interfaces, Java uses the keyword **`extends`**

```java
interface A { }

class B implements A { }
class C implements A { }

class MyArray<T extends A> { }
```

‚úî `A`, `B`, `C` allowed
‚ùå `String` not allowed

**Key Insight**

> `extends` works for both:

* class inheritance
* interface implementation

---

## Common Confusion Points Clarified

| Confusion                      | Clarification                        |
| ------------------------------ | ------------------------------------ |
| Why warning appears            | Raw types cause unchecked operations |
| Why extends used for interface | Java syntax rule for generics        |
| Why subclass must be generic   | To preserve type flexibility         |
| Why Object allowed everywhere  | All classes extend Object            |

---

## üß† Metacognitive Reflection

Ask yourself:

* When should I **avoid raw types**?
* Where does **type safety** matter most in my code?
* Can this generic be replaced by a **built-in collection**?

---

## Summary (High-Value Takeaways)

* Omitting generic parameters ‚Üí defaults to `Object`
* Multiple generic parameters are allowed (`<T, K>`)
* Subclasses must either:

  * fix the type, or
  * become generic themselves
* Bounded generics restrict allowed types
* `extends` is used for **both classes and interfaces**
* Generics improve **compile-time safety**
* In real projects, **built-in generics** are preferred

---
