# Java I/O (Inputâ€“Output) â€” Conceptual Foundations

### 1. What Is Java I/O and Why It Exists

**Java I/O (Inputâ€“Output)** refers to how a Java program **exchanges data with the outside world**.

A Java program does not work in isolation. It frequently needs to:

* Read input (keyboard, file, network, memory)
* Write output (monitor, file, network, memory)

This exchange of data is what we call **Inputâ€“Output (I/O)**.

---

### 2. Program Context vs External Resources

#### Java Program Memory Context

A running Java program occupies specific memory regions:

1. **Method Area**

   * Stores class-level information (bytecode, methods, static variables)

2. **Stack**

   * Stores local variables and reference variables
   * Used for method calls

3. **Heap**

   * Stores objects created using `new`

**Method Area + Stack = Program Context (Program Territory)**

---

#### Resources (External to Program Context)

Everything **outside** this program context is considered a **resource**, including:

* Keyboard (input)
* Monitor (output)
* Files on disk
* Network / remote programs
* Heap objects (accessed indirectly)

The program **cannot directly touch these resources**â€”it must communicate via I/O mechanisms.

---

### 3. What Does Input and Output Mean?

* **Input**: Data flowing *into* the program
  Examples:

  * Typing on keyboard
  * Reading from a file
  * Receiving data from a network

* **Output**: Data flowing *out of* the program
  Examples:

  * Displaying text on monitor
  * Writing to a file
  * Sending data over a network

**I/O is simply the transfer of data between a program and resources.**

---

### 4. Streams: The Core Concept of Java I/O

#### Definition

A **stream** is a **flow of data**.

Data can flow:

* From resource â†’ program (Input Stream)
* From program â†’ resource (Output Stream)

---

#### Why the Term â€œStreamâ€?

Analogy:

* Water flowing through a pipe = stream of water
* Data flowing through a connection = stream of data

Examples:

* Keyboard â†’ Program
* Program â†’ File
* Program â†” Network
* Heap Object â†” Program

Data flows continuously, not all at once.

---

### 5. Data Flow Is Continuous (Not One-Time)

When you type:

```
A â†’ S â†’ D
```

Each character flows **one after another** as a stream of:

* bytes
* or characters

This continuous flow is what defines a stream.

---

### 6. Buffer: Solving Speed Mismatch Problems

#### The Problem

Different devices work at **different speeds**:

* CPU is very fast
* Disk is slow
* Network speed varies

If one side is faster than the other:

* Fast sender â†’ slow receiver â†’ data loss
* Slow sender â†’ fast receiver â†’ wasted time

---

#### The Solution: Buffer

A **buffer** is a temporary memory area that:

* Stores data temporarily
* Smooths speed differences between sender and receiver

---

#### Real-World Analogies

1. **Throwing Balls**

   * Sender throws balls fast
   * Receiver catches slower
   * Buffer = basket to hold balls temporarily

2. **Video Streaming**

   * Video buffers before playing
   * Download speed â‰  playback speed

3. **Bucket Bath Example**

   * Tap fills bucket upto certain level (buffer)
   * Person uses water from bucket
   * Bathing and filling happen simultaneously

**Buffer ensures reliable and efficient data transfer.**

---

### 7. How Data Is Actually Transferred

Important concept:

âŒ Data is **NOT sent as a whole object**
âœ… Data is sent **byte by byte**

Examples:

* String `"John"` â†’ `J â†’ O â†’ H â†’ N`
* Number `126` â†’ `1 â†’ 2 â†’ 6`

Even complex data:

* Is broken into smaller units
* Sent sequentially as bytes (or characters)

This is fundamental to understanding Java streams.

---

### 8. Java Stream Classes (High-Level View)

Java provides **built-in classes** to handle streams.

Learning Java I/O is learning how to use these classes.

---

## Two Main Stream Categories

### 1ï¸âƒ£ Byte Streams

* Handle raw bytes
* Used for binary data (images, files, network)
* Base classes:

  * `InputStream`
  * `OutputStream`

---

### 2ï¸âƒ£ Character Streams

* Handle characters (Unicode)
* Each character = **2 bytes** in Java
* Used for text data
* Base classes:

  * `Reader`
  * `Writer`

---

#### Input vs Output

| Direction | Byte Stream  | Character Stream |
| --------- | ------------ | ---------------- |
| Input     | InputStream  | Reader           |
| Output    | OutputStream | Writer           |

Even character streams internally work with bytesâ€”Java abstracts this for Unicode support.


---

## Summary

* **Java I/O** enables data exchange between programs and external resources
* A **stream** is a continuous flow of data
* **Input** flows into the program, **Output** flows out
* **Buffers** handle speed mismatches between devices
* Data is transferred **byte by byte**, not as whole objects
* Java provides:

  * **Byte streams** (`InputStream`, `OutputStream`)
  * **Character streams** (`Reader`, `Writer`)
* Understanding these fundamentals makes advanced I/O easy to master

---


# **ðŸ“˜Java I/O â€” InputStream & OutputStream**


## 1. Why `InputStream` and `OutputStream` Are Important

These are the **base classes** for all byte streams in Java. Understanding these thoroughly makes learning their subclasses much easier.

`InputStream` and `OutputStream` are the **base (parent) classes** for all **byte stream** classes in Java.

**Key Idea**
If you understand:

* `InputStream`
* `OutputStream`

You automatically understand **all other byte stream classes**, because they inherit from these two.

---

## 2. `InputStream`: Reading Data into a Program

### Conceptual View

* **Resource**: File, keyboard, network, etc.
* **Program**: Java application
* **Direction**: Resource â†’ Program

`InputStream` is used when **data flows into the program**.

---

## 3. Core `InputStream` Methods (Conceptual Understanding)

### 3.1 `int read()`

* Reads **one byte** at a time
* Return type is `int` (byte is an integral value)
* Returns:

  * `0â€“255` â†’ valid data
  * `-1` â†’ **end of stream (no data left)**

**Important Rule**

* Once a byte is read, it is **consumed**
* It is **no longer available** in the stream

Example:

```
Data: A B C D
read() â†’ A
read() â†’ B
read() â†’ C
read() â†’ D
read() â†’ -1
```

---

### 3.2 `int read(byte[] b)`

* Reads **multiple bytes at once**
* Number of bytes read = array size

Example:

```java
byte[] b = new byte[5];
```

* Reads 5 bytes in one operation
* Faster than reading byte-by-byte

NOTE: Data read is **removed from the stream** after reading.

---

### 3.3 `int read(byte[] b, int offset, int length)`

* Reads bytes into a portion of an array
* Allows:
  * Start position (`offset`)
  * Number of bytes (`length`)

Used when you **donâ€™t want to fill the entire array** from index `0`.

---

## 4. Checking Available Data

### `int available()`

* Returns number of bytes **currently available**
* Useful to:

  * Avoid unnecessary blocking
  * Decide buffer size

Note: Value may not always represent total remaining data (especially in network streams).

---

## 5. Skipping Data

### `long skip(long n)`

* Skips `n` bytes
* Skipped bytes are **discarded**
* They are not read into the program

Rarely used, but helpful in specific cases.

---

## 6. Mark and Reset (Advanced / Rarely Used)

### 6.1 `mark(int readLimit)`

* Marks the current position in the stream
* Allows returning back to this position later

### 6.2 `reset()`

* Moves the stream back to the last marked position

### 6.3 `boolean markSupported()`

* Checks whether marking is supported

**Critical Rule**

* Mark/reset works **only on buffered streams**
* Unbuffered streams cannot preserve consumed data

---

### Example Concept

1. Mark position at `A`
2. Read `B`, `C`, `D`
3. Call `reset()`
4. Reading resumes again from `A`

NOTE: Mark has a **validity limit** (`readLimit`):

* If exceeded, mark is invalidated

---

## 7. Closing the Stream

### `void close()`

* Releases system resources
* Must be called after usage


---

### Most Important `InputStream` Methods

| Frequently Used | Rarely Used |
| --------------- | ----------- |
| `read()`        | `skip()`    |
| `read(byte[])`  | `mark()`    |
| `available()`   | `reset()`   |
| `close()`       |             |

---

## 8. `OutputStream`: Writing Data Out of a Program

### Conceptual View

* **Program â†’ Resource**
* Used for:

  * Writing to files
  * Sending data over network
  * Display output

---

## 9. Core `OutputStream` Methods

### 9.1 `void write(int b)`

* Writes **one byte**
* Only the **lower 8 bits** are written


---

### 9.2 `void write(byte[] b)`

* Writes entire byte array
* Efficient bulk write

---

### 9.3 `void write(byte[] b, int offset, int length)`

* Writes partial data from array
* Useful for selective output

---

## 10. Flushing Output Data

### `void flush()`

* Forces buffered data to be written immediately
* Used with **buffered output streams**

Without flush:

* Data may stay in buffer
* Not immediately written to resource


```java
out.write(data);
out.flush();
```

---

## 11. Closing the Output Stream

### `void close()`

* Flushes remaining data
* Releases resources

NOTE: Always close output streams to prevent data loss.

---

## 12. Key Conceptual Mapping

| InputStream         | OutputStream       |
| ------------------- | ------------------ |
| `read()`            | `write()`          |
| Reads from resource | Writes to resource |
| Consumes data       | Sends data         |
| End â†’ `-1`          | No return value    |

---

## Summary

* `InputStream` and `OutputStream` are **foundation classes** for byte streams
* Data is processed **byte by byte**
* `InputStream`:

  * `read()` is the most important method
  * `available()` helps check remaining data
  * Mark/reset require buffering
* `OutputStream`:

  * `write()` sends data out
  * `flush()` forces buffered output
  * `close()` is mandatory
* Mastering these classes makes **all Java I/O subclasses easy**

---



# **ðŸ“˜java.io Class - Java Stream, Reader, and Writer Classes**


## 1. Big Picture: Java I/O Class Ecosystem

Java I/O is built around a **clear class hierarchy**:

```
Object
 â”œâ”€â”€ InputStream        (byte input)
 â”œâ”€â”€ OutputStream       (byte output)
 â”œâ”€â”€ Reader             (character input)
 â””â”€â”€ Writer             (character output)
```

**Key Insight**
If you understand:

* `InputStream` & `OutputStream` â†’ all **byte streams**
* `Reader` & `Writer` â†’ all **character streams**

then learning individual classes becomes **easy and intuitive**.

---

## 2. Byte Streams (`InputStream` & `OutputStream`)

Byte streams handle **raw binary data** (files, images, network, objects).

---

### 2.1 `InputStream` Family (Reading Bytes)

#### Base Class

* `InputStream`
  Contains core methods like `read()`, `available()`, `skip()`, `close()`

---

### Important `InputStream` Subclasses

#### ðŸ”¹ `ByteArrayInputStream`

* Source of data: **byte array**
* Treats a byte array as a stream. It reads from **byte array**
* Useful for in-memory data

---

#### ðŸ”¹ `FileInputStream`

* Reads data from a **file**
* One of the most commonly used streams

---

#### ðŸ”¹ `FilterInputStream`

* Adds **extra functionality** to another InputStream
* Acts as a wrapper (decorator)

Subclasses:

* **`BufferedInputStream`** â­
  * Uses buffer for connecting source and destination if they have difference in their speed of working.
  * Reduces disk/network access by holding data for a while. 

* **`DataInputStream`**
  * Reads Java primitive types (`int`, `float`, etc.)

* `LineNumberInputStream`
  * Reads data with line numbers (legacy)

* `PushbackInputStream`
  * Generally after program reads data from stream, the data is lost from stream.
  * Using PushbackInputStream allows pushing bytes back into the stream

---

#### ðŸ”¹ `ObjectInputStream` â­

* Reads **Java objects**
* Used for deserialization
* Very important in real-world applications

---

#### ðŸ”¹ `PipedInputStream`

* It can be connected to `PipedOutputStream`
* Used for **inter-thread communication**

---

#### ðŸ”¹ `SequenceInputStream`

* Reads data **sequentially from multiple InputStreams**
* Example: file1 â†’ file2 â†’ file3

---

#### ðŸ”¹ `StringBufferInputStream`

* Reads data from a string
* **Deprecated** (legacy)

---

### â­ Most Useful InputStreams (Practically)

* `FileInputStream`
* `BufferedInputStream`
* `ObjectInputStream`

---

## 3. `OutputStream` Family (Writing Bytes)

For **every important InputStream**, there is usually a corresponding OutputStream.

| InputStream          | OutputStream          |
| -------------------- | --------------------- |
| ByteArrayInputStream | ByteArrayOutputStream |
| FileInputStream      | FileOutputStream      |
| BufferedInputStream  | BufferedOutputStream  |
| DataInputStream      | DataOutputStream      |
| ObjectInputStream    | ObjectOutputStream    |
| PipedInputStream     | PipedOutputStream     |

---

### Important OutputStream Classes

#### ðŸ”¹ `ByteArrayOutputStream`

* Writes data to a byte array

---

#### ðŸ”¹ `FileOutputStream`

* Writes data to a file

---

#### ðŸ”¹ `BufferedOutputStream`

* Uses buffering for performance

---

#### ðŸ”¹ `DataOutputStream`

* Writes Java primitive data types

---

#### ðŸ”¹ `PrintStream` â­

* Provides `print()` / `println()`
* `System.out` is a `PrintStream`

---

#### ðŸ”¹ `ObjectOutputStream`

* Writes Java objects (serialization)

---

#### ðŸ”¹ `PipedOutputStream`

* Works with `PipedInputStream`

---

## 4. Character Streams (`Reader` & `Writer`)

Character streams handle **text data** and support **Unicode**
(Characters = 2 bytes in Java)

---

## 4.1 `Reader` Family (Character Input)

Equivalent to `InputStream` but for characters.

### Important Reader Classes

* `Reader` (base class)
* **`BufferedReader`** 
* `CharArrayReader`
* `InputStreamReader` 
  (Bridge between byte streams & character streams)
* `FilterReader`
* `PushbackReader`
* `PipedReader`

---

## 4.2 `Writer` Family (Character Output)

Equivalent to `OutputStream` but for characters.

### Important Writer Classes

* `Writer` (base class)
* **`BufferedWriter`** 
* `CharArrayWriter`
* `OutputStreamWriter` 
* `FilterWriter`
* `PipedWriter`
* **`PrintWriter`**
* `StringWriter`

---

## 5. Special Utility Classes

### ðŸ”¹ `StreamTokenizer`

* Breaks input into tokens
* Used in parsing scenarios

---

### ðŸ”¹ `RandomAccessFile`

* Allows **random (non-sequential) file access**
* Can read/write at any position

---

## 6. Exception Hierarchy in Java I/O

Most I/O methods throw **checked exceptions**.

### Common Exceptions

* `IOException` â­ (base class for most I/O errors)
* `FileNotFoundException`
* `EOFException` (End of File)
* `ObjectStreamException`
* `InterruptedIOException`

**Practical Tip**

* While learning/practicing, you may catch `Exception`
* In real applications, handle specific exceptions

---

## 7. How to Remember All These Classes (Strategy)

### Memory Shortcut

1. Remember **InputStream**
2. Automatically know **OutputStream**
3. Replace:

   * `InputStream â†’ Reader`
   * `OutputStream â†’ Writer`
4. Buffered, File, Data, Object, Piped â†’ same idea everywhere

If you remember **5â€“6 key classes**, the rest become predictable.

---

## Summary

* Java I/O is structured around **four base classes**:

  * `InputStream`, `OutputStream`
  * `Reader`, `Writer`
* Byte streams handle **binary data**
* Character streams handle **Unicode text**
* Most streams come in **input/output pairs**
* `Buffered`, `File`, `Object`, and `Print` streams are the most important
* Almost all I/O operations throw `IOException`
* Understanding the **hierarchy** eliminates memorization

---

# **ðŸ“˜Java File I/O: FileOutputStream**

## **1ï¸âƒ£ Purpose**

* **`FileOutputStream`** â†’ Used to **write bytes** to a file.
* **`FileInputStream`** â†’ Used to **read bytes** from a file.

**Scenario:**

1. Create a file `Test.txt`.
2. Write content into it using `FileOutputStream`.
3. Later, read from it using `FileInputStream` 

---

## **2ï¸âƒ£ Writing to a File Using FileOutputStream**

### **Steps:**

1. **Import necessary classes:**

```java
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
```

2. **Create FileOutputStream object:**

```java
FileOutputStream fos = new FileOutputStream("C:/MyJava/Test.txt");
```

* Use **forward slashes** (`/`) in the path.
* If the file is in the same directory as your `.class` file, just use the filename.

3. **Handle Exceptions:**

* `FileNotFoundException` â†’ if the file cannot be created.
* `IOException` â†’ general I/O errors.

```java
try {
    // File writing code
} catch (FileNotFoundException e) {
  e.printStackTrace();
} catch (IOException e) {
  e.printStackTrace();
}
```

---

### **Writing a String to a File**

* Convert a string to a **byte array**:

```java
String str = "Learn Java Programming";
byte[] b = str.getBytes(); // Convert string to bytes
fos.write(b); // Write all bytes at once
```

* **Writing byte by byte**:

```java
for (byte x : b) {
  fos.write(x);
}
```

* **Writing with offset** (write only a part of the array):

```java
int offset = 6; // start from index 6
int length = str.length() - 6; //-6 to skip 0-6 
fos.write(b, offset, length); // writes only "Java Programming"
```

---

## **3ï¸âƒ£ Closing the File**

* Always **close the stream** to release resources:

```java
fos.close();
```

[FileExample.java]
```java 
public class FileExample 
{
  public static void main(String[] args) {
    try {
      FileOutputStream fos = new FileOutputStream(); 
      String str = "Learn Java Programming"; 

      fos.write(str.getBytes());

      fos.close();
    } catch(FileNotFoundException e) {
      System.out.prinln(e);
    } catch(IOException e) {
      System.out.prinln(e);
    }
  }
}
```

* Alternative: **try-with-resources** (recommended):

```java
import java.io.*;

public class FileExample 
{
  public static void main(String[] args) throws Exception {
    try (FileOutputStream fos = new FileOutputStream("C:/MyJava/Test.txt")) {      
    
      String str = "Learn Java Programming"; 

      fos.write(str.getBytes());

      fos.close();
    }
  }
}
```

* Automatically closes the stream at the end of the block.

---

## **4ï¸âƒ£ Key Points**

* `FileOutputStream.write()` has **three forms**:

  1. `write(int b)` â†’ writes one byte.
  2. `write(byte[] b)` â†’ writes entire byte array.
  3. `write(byte[] b, int offset, int length)` â†’ writes part of the byte array.
* You can write **all bytes at once** or **byte by byte**.
* **Try-with-resources** simplifies code and avoids manual closing.

---

## **5ï¸âƒ£ Next Steps**

* Reading from a file using **FileInputStream**.
* Concepts will be similar:

  * Create a `FileInputStream` object.
  * Use `read()` methods to fetch bytes.
  * Handle exceptions.
  * Close the stream (or use try-with-resources).

---

**Summary:**

* **FileOutputStream** is for **writing bytes** to a file.
* Convert **Strings â†’ bytes** using `.getBytes()`.
* Use **try-with-resources** for clean code.
* Offset allows writing **part of data**.
* Always **close streams** to free resources.


---

# **ðŸ“˜Java File I/O: FileInputStream & FileReader**

## **1ï¸âƒ£ Purpose**

* **FileInputStream** â†’ Used to **read bytes** from a file.
* Similar to FileOutputStream, but for **input**.

---

## **2ï¸âƒ£ Reading a File**

### **Step 1: Import Required Classes**

```java
import java.io.FileInputStream;
import java.io.IOException;
```

### **Step 2: Open the File Using Try-With-Resources**

```java
try (FileInputStream fis = new FileInputStream("C:/MyJava/Test.txt")) {
  // Reading logic
} catch (IOException e) {
  e.printStackTrace();
}
```

### **Step 3: Reading Methods**

#### **A. Read All Bytes at Once**

```java
byte[] b = new byte[fis.available()]; // allocate array of file size
fis.read(b); // read all bytes into array
String str = new String(b); // convert bytes to String
System.out.println(str);
```

**Explanation:**

* `fis.available()` â†’ returns number of bytes available in the file
* `fis.read(byte[] b)` â†’ reads all bytes into the array.
* Convert byte array â†’ String â†’ print.

---

#### **B. Read Byte by Byte**

```java 
int x;
while ((x = fis.read()) != -1) { // read each byte until EOF (-1)
  System.out.print((char)x); // convert byte to character and print
}
```

```java
int x;
do {
  x = fix.read(); 
  if(x != -1)
    System.out.print((char)x); // convert byte to character and print
} while(x != -1);
```

**Explanation:**

* `fis.read()` â†’ reads **one byte** and returns its ASCII value.
* Returns **-1** when the end of file (EOF) is reached.
* Print each byte as a character.

> Alternative with do-while loop also works, but `while` loop is cleaner.


```java
import java.io.*;

public class FileExample 
{
  public static void main(String[] args) throws Exception {
    try (FileInputStream fis = new FileOutputStream("C:/MyJava/Test.txt")) {      
    
      int x;
      while ((x = fis.read()) != -1) { 
        System.out.print((char)x); 
      }
      
    }
  }
}
```

---
 
### **Step 4: Using FileReader Instead of FileInputStream**

* Works **similarly**, but handles **characters** instead of bytes.

```java
import java.io.*;

public class FileExample 
{
  public static void main(String[] args) throws Exception {
    try (FileReader fr = new FileReader("C:/MyJava/Test.txt")) {      
    
      int x;
      while ((x = fr.read()) != -1) {
        System.out.print((char)x);
      }
      fr.close();     
    }
  }
}
```

* Only minor changes: `FileInputStream â†’ FileReader`
* Reading logic remains the same.

---

## **3ï¸âƒ£ Key Points**

1. **FileInputStream vs FileReader**

   * `FileInputStream` â†’ reads **bytes**.
   * `FileReader` â†’ reads **characters** (Unicode-friendly).

2. **Reading Options**

   * **All bytes at once** â†’ `read(byte[] b)`
   * **Byte by byte** â†’ `read()`
   * Use **available()** to allocate array size if reading all bytes at once.

3. **EOF Handling**

   * `read()` returns `-1` at the end of file.

4. **Try-with-Resources**

   * Automatically closes the file â†’ no need for explicit `close()`.

---

## **4ï¸âƒ£ Next Steps**

* FileWriter works similarly to FileOutputStream.
* Using FileReader/FileWriter â†’ same logic as FileInputStream/FileOutputStream but works with **characters**.

---

**Summary:**

* **FileInputStream** â†’ reads bytes.
* **FileReader** â†’ reads characters.
* Two reading styles: **all bytes at once** or **byte-by-byte**.
* Always use **EOF (-1)** to terminate loops.
* Try-with-resources simplifies exception handling and closes the file automatically.

---


# **ðŸ“˜Java File I/O Challenge - Copy a File**

## **Task 1: Copy a File and Convert Uppercase to Lowercase**

**Goal:**

* Read from `Source1.txt` (It has all uppercase letters)
* Write to `Source2.txt` (convert letters to lowercase)
* Uppercase letter ASCII range 65-90. Lowercase letter ASCII range 97-122
### **Code Example**

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyToLowerCase {
  public static void main(String[] args) throws IOException {
    FileInputStream fis = new FileInputStream("Source1.txt");
    FileOutputStream fos = new FileOutputStream("Source2.txt");

    int b;
    while ((b = fis.read()) != -1) {
      // Convert uppercase letters (ASCII 65-90) to lowercase
      if (b >= 65 && b <= 90) {
        b += 32;
      }
      fos.write(b);
    }

    fis.close();
    fos.close();
    System.out.println("File copied with lowercase conversion.");
  }
}
```

**Key Points:**

* FileInputStream reads bytes from a file.
* FileOutputStream writes bytes to a file.
* ASCII conversion: `A-Z` (65â€“90) â†’ add 32 â†’ `a-z` (97â€“122).
* Non-alphabet characters remain unchanged.

---

## **Task 2: Combine Two Files into One Using SequenceInputStream**

**Goal:**

* Read from `Source1.txt` and `Source2.txt`
* Write both contents sequentially into `Destination.txt`
* SequenceInputStream takes two FIS. It will start reading data from second stream after it finished reading from first stream. 

### **Code Example**

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.SequenceInputStream;
import java.io.IOException;

public class CombineFiles {
  public static void main(String[] args) throws IOException {
    FileInputStream fis1 = new FileInputStream("Source1.txt");
    FileInputStream fis2 = new FileInputStream("Source2.txt");
    FileOutputStream fos = new FileOutputStream("Destination.txt");

    SequenceInputStream sis = new SequenceInputStream(fis1, fis2);

    int b;
    while ((b = sis.read()) != -1) {
      fos.write(b);
    }

    sis.close();
    fos.close();
    fis1.close();
    fis2.close();
    System.out.println("Files combined into Destination.txt.");
  }
}
```

**Key Points:**

* `SequenceInputStream` allows reading from multiple streams **sequentially**.
* First stream is read completely, then the second.
* Useful for appending files in order.

---

**Summary:**

1. **Task 1** â†’ Copy file and convert uppercase letters to lowercase.
2. **Task 2** â†’ Merge two files sequentially using `SequenceInputStream`.
3. Both tasks use **byte streams** (`FileInputStream`, `FileOutputStream`).
4. ASCII values are used for letter conversion.

---


# ðŸ“˜ Byte Streams & CharArrayReader

## Topic Overview

We'll learn about **in-memory stream processing in Java**, focusing on:

* `ByteArrayInputStream`
* `ByteArrayOutputStream`
* `CharArrayReader`
* (Exercise) `CharArrayWriter`

Unlike file-based streams, these classes work on **arrays in memory**, making them fast and useful for buffering, testing, inter-thread communication, and data transformation.

---


## Conceptual Hierarchy

### 1. Streams Recap (Context)

* **Stream** = sequential flow of data
* Previously learned: `FileInputStream`, `FileOutputStream`
* Key difference here:
  **Source/Destination = Array (not file)**

---

## 2. ByteArrayInputStream

### What It Is

* Reads data **from a byte array**
* Treats an array like a stream
* Useful when data:

  * Comes from memory
  * Comes from another program/thread/network
  * Should be processed using standard stream APIs

### Basic Setup

```java
byte[] b = {'A','B','C','D','E','F','G','H','I','J'};
ByteArrayInputStream bis = new ByteArrayInputStream(b);
```

---

### Reading Byte-by-Byte

* Uses `read()` method
* Returns:
  * byte value (0â€“255)
  * `-1` â†’ end of stream

```java
int x;
while ((x = bis.read()) != -1) {
  System.out.print((char)x);
}
```

NOTE: `read()` always returns an `int`, even for byte streams.

[ByteArrayInputStreamDemo.java]
```java 
import java.io.*;

public class ByteArrayInputStreamDemo 
{
  public static void main(String[] args) throws Exception {
    byte[] b = {'A','B','C','D','E','F','G','H','I','J'};
    ByteArrayInputStream bis = new ByteArrayInputStream(b);

    int x;
    while ((x = bis.read()) != -1) {
      System.out.print((char)x);
    }
  }
}

```

For demo we created ByteArrayInputStream within program but in reality it will be sent to us by another thread or remote computer. 

---

### Reading All Bytes at Once

* Method: `readAllBytes()`
* Returns a `byte[]`

```java
byte[] b = {'A','B','C','D','E','F','G','H','I','J'};
ByteArrayInputStream bis = new ByteArrayInputStream(b);

byte[] data = bis.readAllBytes();
String str = new String(data);

System.out.println(str);
```

âœ” Efficient when the entire data can fit into memory.

---

### Mark and Reset Support

```java
byte[] b = {'A','B','C','D','E','F','G','H','I','J'};
ByteArrayInputStream bis = new ByteArrayInputStream(b);

String str = new String(bis.readAllBytes());

System.out.println(bis.markSupported()); // returns true
```

* Supported because data is in memory
* Unlike files, arrays allow repositioning freely

âš ï¸ Instructor note: Mark/reset is better demonstrated using `BufferedInputStream`

---

## 3. ByteArrayOutputStream

### What It Is

* Writes data **into an internal byte array**
* Acts like a **buffer**
* Data can later be:

  * Converted to byte array
  * Sent to a file
  * Sent to another stream

---

### Creating the Stream

```java
ByteArrayOutputStream bos = new ByteArrayOutputStream(20);
```
* Size is optional
* Stream grows dynamically if needed

---

### Writing Data

```java
bos.write('a');
bos.write('b');
bos.write('c');
bos.write('d');
```

---

### Retrieving Written Data

```java
byte[] result = bos.toByteArray();
for (byte b : result) {
  System.out.print((char)b);
}
```

ðŸ”¹ Without typecasting â†’ ASCII values
ðŸ”¹ With typecasting â†’ characters

---

[ByteArrayOutputStreamDemo.java]
```java 
import java.io.*;

public class ByteArrayOutputStreamDemo
{
  public static void main(String[] args) throws Exception {
    ByteArrayOutputStream bos = new ByteArrayOutputStream(20);

    bos.write('a');
    bos.write('b');
    bos.write('c');
    bos.write('d');

    byte[] result = bos.toByteArray();
    for (byte b : result) {
      System.out.print((char)b);
    }

    bos.close();
  }
}
```

### Writing to a File Using `writeTo()`

```java

public static void main(String[] args) throws Exception {
  ByteArrayOutputStream bos = new ByteArrayOutputStream(20);

  bos.write('a');
  bos.write('b');
  bos.write('c');
  bos.write('d');


  FileOutputStream fos = new FileOutputStream("path/to/Test.txt");
  bos.writeTo(fos);

  bos.close();
}
```

ðŸ“Œ **Important Insight**
`ByteArrayOutputStream` acts as a **temporary staging area**, after which data can be sent anywhere.

---

## 4. CharArrayReader

### Purpose

* Character-based version of `ByteArrayInputStream`
* Works with `char[]` instead of `byte[]`

---

### Example

```java
char[] c = {'J','A','V','A'};
CharArrayReader cr = new CharArrayReader(c);

int x;
while ((x = cr.read()) != -1) {
  System.out.print((char)x);
}
cr.close();
```

âœ” Same logic
âœ” Same `read()` method
âœ” Only difference: character-based data

---

## 5. CharArrayWriter (Student Exercise)

* Similar to `ByteArrayOutputStream`
* Use `CharArrayWriter`
* Write characters
* Convert to:

  * `char[]`
  * or write to another `Writer`

If you understand `ByteArrayOutputStream`, this is straightforward.

---

## Common Confusion Points (Clarified)

### Why use streams for arrays?

âœ” Real-world data often:

* Comes from networks
* Comes from threads
* Comes from APIs
* Is already in memory

Streams provide a **uniform API** to process data regardless of source.

---

### Why not access the array directly?

âœ” Because:

* Code becomes reusable
* Same logic works for files, memory, sockets
* Enables chaining with filters (buffered, data streams)


---

# Summary

* **ByteArrayInputStream** reads data from a byte array like a stream
* **ByteArrayOutputStream** writes data into an internal byte buffer
* Data in `ByteArrayOutputStream` can be reused, converted, or redirected
* **CharArrayReader** is the character-based equivalent of byte input streams
* Array-based streams are fast, flexible, and ideal for in-memory processing
* Once you learn one stream, **most Java streams behave similarly**

---


# **ðŸ“˜Buffered Streams & Buffered Reader**

## **1ï¸âƒ£ BufferedInputStream**

**Purpose:**
* FileInputStream is meant for attaching to source but a BufferedInputStrean doesn't attach to source. It attaches to souce
* It Wraps another input stream (like `FileInputStream`) and adds a buffer to improve reading efficiency.
* Supports `mark()` and `reset()`, which lets you read data, go back to a mark, and read again.

**Key Concept:**

* The buffer temporarily stores data from the source stream so your program can access it faster.
* Without buffer, every `read()` would go directly to the source (file), which is slower.

### **Example: Read byte-by-byte**

```java
import java.io.*;

public class BufferedInputStreamDemo {
  public static void main(String[] args) throws IOException {
    FileInputStream fis = new FileInputStream("test.txt");
    BufferedInputStream bis = new BufferedInputStream(fis);

    int x;
    while ((x = bis.read()) != -1) {
      System.out.print((char)x);
    }
    System.out.println();

    // Check mark support
    System.out.println("FileInputStream markSupported: " + fis.markSupported());
    System.out.println("BufferedInputStream markSupported: " + bis.markSupported());

    bis.close();
    fis.close();
  }
}
```
- Buffer is a temporary area for holding the data. So if there is difference in speed between device and program, then we use buffer. Since data is in buffer, **mark & reset** is supported
- But FileStream moves forward-only

### **Example: Using mark() and reset()**

```java
FileInputStream fis = new FileInputStream("test.txt");
BufferedInputStream bis = new BufferedInputStream(fis);


bis.mark(10);   // mark current position, valid for 10 bytes
System.out.print((char)bis.read()); // read 1 byte
System.out.print((char)bis.read()); // read next byte
bis.reset();    // go back to mark
System.out.print((char)bis.read()); // re-read first byte after mark
```

**Notes:**

* `mark()` sets a bookmark.
* `reset()` moves the stream back to the mark.
* File streams alone do **not** support mark/reset.

---

## **2ï¸âƒ£ BufferedOutputStream**

**Purpose:**

* Wraps another output stream (like `FileOutputStream`) and adds a buffer to improve writing efficiency.
* Data is first written to the buffer and then flushed to the destination.

### **Example: Write bytes**

```java
FileOutputStream fos = new FileOutputStream("output.txt");
BufferedOutputStream bos = new BufferedOutputStream(fos);

bos.write("Hello Buffered Output Stream".getBytes());
bos.flush();   // send buffered data to file

bos.close();
fos.close();
```

**Key Benefit:**

* Improves performance for large writes.
* Reduces the number of actual write operations to the file/device.

---

## **3ï¸âƒ£ BufferedReader**

**Purpose:**

* Wraps a `Reader` (like `FileReader`) and adds a buffer to read characters efficiently.
* Supports `readLine()` to read entire lines of text.

### **Example: Read line-by-line**

```java
FileReader fr = new FileReader("test.txt");
BufferedReader br = new BufferedReader(fr);

String line;
while ((line = br.readLine()) != null) {
  System.out.println("Read line: " + line);
}

br.close();
fr.close();
```

**Notes:**

* Only works with character streams.
* `readLine()` is unique to buffered readers; byte streams do not have it.
* Useful for reading text files line by line.

---

## **4ï¸âƒ£ BufferedWriter**

**Purpose:**

* Wraps a `Writer` (like `FileWriter`) and adds a buffer to write characters efficiently.
* Can write strings or individual characters to files.

### **Example: Write line-by-line**

```java
FileWriter fw = new FileWriter("output.txt");
BufferedWriter bw = new BufferedWriter(fw);

bw.write("This is a line.");
bw.newLine();  // add newline
bw.write("This is another line.");
bw.flush();    // flush buffer to file

bw.close();
fw.close();
```

---

## **5ï¸âƒ£ Summary Table**

| Class                | Wraps        | Works With | Key Feature                              |
| -------------------- | ------------ | ---------- | ---------------------------------------- |
| BufferedInputStream  | InputStream  | byte       | mark/reset, faster byte reading          |
| BufferedOutputStream | OutputStream | byte       | buffer improves writing efficiency       |
| BufferedReader       | Reader       | char       | readLine(), mark/reset, buffered reading |
| BufferedWriter       | Writer       | char       | buffer improves writing efficiency       |

---

**ðŸ’¡ Key Takeaways:**

1. **Buffered streams/readers/writers** add temporary memory to smooth reading/writing.
2. `mark()` and `reset()` only supported in buffered streams.
3. Use `BufferedReader` for text files when you want to read lines efficiently.
4. Always close streams after use (`close()`), or use **try-with-resources**.

---

# **ðŸ“˜Piped Streams**


## **1ï¸âƒ£ Concept of Piped Streams**

**Purpose:**

* `PipedInputStream` and `PipedOutputStream` are **used for inter-thread communication** in Java.
* A producer thread can write data into a pipe (`PipedOutputStream`), and a consumer thread can read that data from the pipe (`PipedInputStream`).
* We have to connect two pipes in main() ethod


**Key Points:**

* Each thread has its own stream reference.
* Streams must be connected using `connect()` before starting threads.
* Pipes do **not automatically synchronize** threads; producer may run faster than consumer unless you explicitly control it (e.g., `Thread.sleep()`).

**Analogy:**
Think of it as a **water pipe**:

* Producer â†’ pushes water (data) into the pipe
* Consumer â†’ reads water from the pipe

---

## **2ï¸âƒ£ Program Structure**

### **Producer Thread**

```java
import java.io.*;

class Producer extends Thread {
  private PipedOutputStream os;

  Producer(PipedOutputStream o) {
      this.os = o;
  }

  public void run() {
    int count = 1;
    try {
      while(true) {
        os.write(count);   // write to pipe
        os.flush();        // ensure data is sent
        
        Thread.sleep(10);  // slow down producer
        
        System.out.println("Producer produced " + count);
        System.out.flush();

        count++;
      }
    } catch(Exception e) {}
  }
}
```

### **Consumer Thread**

```java
class Consumer extends Thread {
  private PipedInputStream is;

  Consumer(PipedInputStream s) {
    this.is = s;
  }

  public void run() {
    int x;
    try {
      while(true) {
        x = is.read();    // read from pipe
        System.out.println("Consumer consumed: " + x);
        System.out.flush();
      }
    } catch(Exception e) {}
  }
}
```

---

## **3ï¸âƒ£ Main Method: Connecting Pipes**

```java
public class PipeDemo {
  public static void main(String[] args) throws Exception {
    PipedInputStream pis = new PipedInputStream();
    PipedOutputStream pos = new PipedOutputStream();

    // Connect the pipes
    pis.connect(pos); // or pos.connect(pis);

    // Create Producer and Consumer
    Producer producer = new Producer(pos);
    Consumer consumer = new Consumer(pis);

    // Start threads
    producer.start();
    consumer.start();
  }
}
```

âœ… **Notes:**

* `pis.connect(pos)` links the two streams so data written by Producer is read by Consumer.
* Without `sleep` or inter-thread communication, Producer can outpace Consumer.
* Pipes are designed for **thread-to-thread data transfer** only; cannot be shared across processes.

---

## **4ï¸âƒ£ Key Takeaways**

1. **Piped Streams** are byte-based (like `InputStream`/`OutputStream`).
2. They allow **direct communication between two threads** without an intermediate shared object.
3. Producer writes data using `PipedOutputStream.write()`.
4. Consumer reads data using `PipedInputStream.read()`.
5. **Threads must be synchronized** manually (sleep, wait/notify, or blocking queues).
6. Always connect the streams **before starting the threads**.

---

**ðŸ’¡ Visualization of Data Flow:**

```
Producer Thread
    |
    | write() 
    v
PipedOutputStream
    |
    v
PipedInputStream
    |
    | read()
    v
Consumer Thread
```

---

# **ðŸ“˜Random Access File**
                                                                         
## **1ï¸âƒ£ What are Random Access Files?**

In Java, files can be accessed in **two ways**:

### **A. Sequential Access**

* Works like a **tape recorder**: the file pointer moves **only forward**.
* If reading: after reading a byte, the pointer moves to the next byte.
* If writing: starts at the beginning, overwrites existing data.
* Cannot read or write at arbitrary positions without reopening the file.
* If a file is opened for read, then perform reading. If file is opened for write, then perform writing. 
* Most commonly used method.

### **B. Random Access**

* With Random access you can open the file for both read & write using same pointer. It can **read and write from the same pointer**.
* Allows moving the file pointer **anywhere in the file** by giving a position of byte from beginning of file.

* Pointer movement can be:
  * From the beginning (`seek(position)`)
  * Relative to the current pointer (using `getFilePointer()` + offset)
* Useful when you know the **structure of the file** and want to access or update specific positions.

---

## **2ï¸âƒ£ Java Class for Random Access**

* `java.io.RandomAccessFile`
* Modes:

  * `"r"` â†’ read-only
  * `"rw"` â†’ read and write
* RandomAccessFile implements **DataInput** and **DataOutput**:

  * Allows reading/writing **primitive data types** directly:
    ```java
    readInt(), writeInt()
    readFloat(), writeFloat()
    readUTF(), writeUTF()
    ```
* Provides key methods:

  * `seek(long position)` â†’ move pointer to a specific byte
  * `getFilePointer()` â†’ get current pointer position
  * `length()` â†’ get file size

---

## **3ï¸âƒ£ Example Program**

Suppose we have a file `data.txt` with alphabets:

```
A B C D E F G H I J
```

### **Read and Write Using RandomAccessFile**

```java
import java.io.*;

public class RandomAccessDemo {
  public static void main(String[] args) throws Exception {
    RandomAccessFile rf = new RandomAccessFile("data.txt", "rw");

    // Read first three bytes
    System.out.println((char) rf.read()); // A
    System.out.println((char) rf.read()); // B
    System.out.println((char) rf.read()); // C

    // File pointer is now at 4th byte (D)
    rf.write('d'); // Overwrite D with lowercase d

    // Next read will be E
    System.out.println((char) rf.read()); // E

    // Skip 3 bytes (F, G, H)
    rf.skipBytes(3);

    // Pointer is now at I
    System.out.println((char) rf.read()); // I

    // Move pointer to 4th byte (index 3)
    rf.seek(3);
    System.out.println((char) rf.read()); // d

    // Get current file pointer
    System.out.println("Current pointer: " + rf.getFilePointer()); // 4 (points to E)
    
    // Move pointer relative to current
    rf.seek(rf.getFilePointer() + 2); // move forward 2 bytes
    System.out.println((char) rf.read()); // G
  }
}
```

---

## **4ï¸âƒ£ Key Points**

1. **Single pointer** is used for both reading and writing.
2. After every operation, pointer moves forward automatically.
3. You can:

   * Move pointer absolutely: `seek(position)`
   * Move pointer relative to current position: `seek(getFilePointer() + offset)`
   * Skip bytes: `skipBytes(n)`
4. Allows **direct modification of file content** without rewriting the whole file.
5. Supports reading and writing **primitive data types**, not just bytes.

---

## **5ï¸âƒ£ Visual Representation**

```
File: A B C D E F G H I J
Pointer â†’ initially at 0

Read 3 bytes:
Pointer â†’ moves to 3 (D)

Write 'd':
File â†’ A B C d E F G H I J
Pointer â†’ moves to 4 (E)

Skip 3 bytes:
Pointer â†’ moves to 7 (I)

Seek to 3:
Pointer â†’ moves to 3 (d)
```

---

**ðŸ’¡ Summary:**
Random Access Files are powerful when you need **non-sequential reading/writing** and know the fileâ€™s internal structure. They are ideal for **databases, indexed files, or any file requiring frequent updates at specific positions**.

---

# **ðŸ“˜File Class**

## **1ï¸âƒ£ What is the `File` class in Java?**

The **`java.io.File`** class is used to **represent a file or directory** in Java.
It does **not handle the content** of the file but allows you to **access file properties, manage files, and directories**.

---

## **2ï¸âƒ£ Creating a File Object**

```java
import java.io.*;

public class FileDemo {
  public static void main(String[] args) throws Exception {
    // Represent a folder
    File folder = new File("C:\\MyJava");

    // Represent a file
    File file = new File("C:\\MyJava\\Data.txt");
  }
}
```

---

## **3ï¸âƒ£ Key Methods in `File` Class**

### **A. Check File Properties**

| Method          | Description                       |
| --------------- | --------------------------------- |
| `isDirectory()` | Checks if the path is a directory |
| `isFile()`      | Checks if the path is a file      |
| `isAbsolute()`  | Checks if the path is absolute    |
| `canRead()`     | Can the file be read?             |
| `canWrite()`    | Can the file be written?          |
| `canExecute()`  | Can the file be executed?         |
| `isHidden()`    | Checks if the file is hidden      |

---

### **B. File Creation and Deletion**

| Method            | Description                             |
| ----------------- | --------------------------------------- |
| `createNewFile()` | Creates a new empty file                |
| `delete()`        | Deletes the file immediately            |
| `deleteOnExit()`  | Deletes the file when the program exits |

---

### **C. Get File Information**

| Method               | Description                                              |
| -------------------- | -------------------------------------------------------- |
| `getName()`          | Returns the name of the file/folder                      |
| `getPath()`          | Returns the path provided when creating the object       |
| `getAbsolutePath()`  | Returns the absolute path of the file                    |
| `getCanonicalPath()` | Returns the real path (resolves shortcuts)               |
| `getParent()`        | Returns the parent directory                             |
| `length()`           | Returns file size in bytes                               |
| `lastModified()`     | Returns last modified time of the file (in milliseconds) |

---

### **D. Modify File Attributes**

| Method                       | Description                         |
| ---------------------------- | ----------------------------------- |
| `setReadOnly()`              | Make the file read-only             |
| `setWritable(boolean flag)`  | Make the file writable or read-only |
| `setLastModified(long time)` | Change the last modified timestamp  |

---

## **4ï¸âƒ£ Listing Files in a Directory**

```java
public static void main(String[] args) throws Exception {
  File folder = new File("C:\\MyJava");
  
  // List file names as String array
  String[] files = folder.list();
  for (String f : files) {
    System.out.println(f);
  }
  
  // List files as File objects
  File[] fileList = folder.listFiles();
  for (File f : fileList) {
    System.out.print(f.getName() + " ");
    System.out.println(f.getPath());
  }
}
```

* `list()` â†’ returns **names** of files/folders.
* `listFiles()` â†’ returns **File objects**, so you can get more info like path, type, etc.

---

## **5ï¸âƒ£ Example: Handling Read-Only Files**

```java
public static void main(String[] args) throws Exception {
  File file = new File("C:\\MyJava\\Data.txt");
  
  // Make file read-only
  file.setReadOnly();
  
  // Try writing to read-only file
  try (FileOutputStream fos = new FileOutputStream(file)) {
    fos.write(65); // 'A'
  } catch (Exception e) {
    System.out.println("Error: " + e.getMessage());
  }
  
  // Make it writable again and try writing
  file.setWritable(true);
}
```

* When a file is **read-only**, writing to it causes a `FileNotFoundException` with â€œAccess is deniedâ€.

---

## **6ï¸âƒ£ Summary**

* The **`File` class** is used to access **file metadata and manage files/directories**, not their content.
* You can:

  * Check properties: `isDirectory()`, `canRead()`, `isHidden()`
  * Create/delete files: `createNewFile()`, `deleteOnExit()`
  * Modify attributes: `setReadOnly()`, `setWritable()`, `setLastModified()`
  * List files in directories: `list()`, `listFiles()`
* Combining `File` with **streams** allows full file manipulation (reading/writing).

---

# **ðŸ“˜Serialisation Storing Data in a File**
---

**1ï¸âƒ£ The Problem**

You have a class:

```java
class Student {
  int rollNumber;
  String name;
  String department;
}
```

**Goal:**
Store an object of `Student` in a file (`My.txt`) and retrieve it later **exactly as it is**.

**Challenges:**

* How do we store an object in a file?
* How do we read it back and reconstruct the object?
* Can we preserve the data types (int, String) without converting everything to a string?

---

**2ï¸âƒ£ First Solution: Store Object as Text (Strings)**

**Idea:** Write each property of the object as a string to a file. Read each line and reconstruct the object.

Using PrintStream we'll print these value in a file. To file [My.txt] an object of `FileOutputStream` is attached to which an object of `PrintStream` is attached

### **Writing the object to file using `PrintStream`:**

```java
import java.io.*;

public class MyWrite {
  public static void main(String[] args) throws Exception {
    FileOutputStream fo = new FileOutputStream("My.txt");
    PrintStream ps = new PrintStream(fo);

    Student s = new Student();
    s.rollNumber = 10;
    s.name = "John";
    s.department = "CSE";

    ps.println(s.rollNumber);   // writes "10" as a string
    ps.println(s.name);         // writes "John"
    ps.println(s.department);   // writes "CSE"

    ps.close();
  }
}
```



### **Reading the object back from file:**
`FileInputStream` cannot read String from a file. For that we need `BufferedReader`
For converting Stream to Reader, we've `InputStreamReader`

```java
import java.io.*;

public class MyRead {
  public static void main(String[] args) throws Exception {
    FileInputStream fi = new FileInputStream("My.txt");
    BufferedReader br = new BufferedReader(new InputStreamReader(fi));

    Student s = new Student();
    s.rollNumber = Integer.parseInt(br.readLine());  // convert string to int
    s.name = br.readLine();
    s.department = br.readLine();

    System.out.println(s.rollNumber + " " + s.name + " " + s.department);
    br.close();
  }
}
```

---

**3ï¸âƒ£ Problems with the First Solution**

1. **Data type is lost:**

   * Everything is stored as a string in the file.
   * Even integers or floats are converted to strings.

2. **Manual type conversion needed:**

   * While reading, you must manually parse integers, floats, etc.

3. **Not scalable:**

   * For larger objects with many fields, writing and reading each property manually is tedious.

---

## **4ï¸âƒ£ Goal for the Next Step**

* Store each member of the object in its **own data type** directly.
* Avoid converting integers, floats, etc., to strings.
* Read them back **without type casting**.

**Solution Preview:**
This is where **DataInputStream / DataOutputStream** comes in (second solution).
Eventually, the **third solution is Serialization**, which allows you to **store the whole object in its original form**, and read it back easily.

---

**Key Concept:** Serialization is basically the process of **writing an object into a file in its entirety** so it can be read back later without losing data types.

---

# **ðŸ“˜PrintStream DEMO**

---

## **1ï¸âƒ£ Overview**

The goal is to **store and read an object of a `Student` class** using **text-based file I/O**:

```java
class Student {
  int rollNumber;
  String name;
  String department;
}
```

The demonstration uses **`PrintStream`** for writing and **`BufferedReader`** for reading.

---

## **2ï¸âƒ£ Writing the Object to a File**

**Steps:**

1. Create a `FileOutputStream` to connect to the file:

```java
FileOutputStream fos = new FileOutputStream("MyJava\\Student1.txt");
```

2. Attach a `PrintStream` to it:

```java
PrintStream ps = new PrintStream(fos);
```

3. Create and initialize a `Student` object:

```java
Student s = new Student();
s.roll = 10;
s.name = "John";
s.dept = "CSE";
```

4. Write each property using `PrintStream.println()`:

```java
ps.println(s.roll);        // calls println(int)
ps.println(s.name);        // calls println(String)
ps.println(s.dept);        // calls println(String)
```

5. Close the streams:

```java
ps.close();
fos.close();
```

âœ… **Result:** The file contains three lines: `"10"`, `"John"`, `"CSE"`.
Note: All values are stored as **strings**, even integers.

[PrintStreamDemo.java]
```java 
import java.io.*; 

class Student {
  int rollno; 
  String name; 
  String dept;
}

public class PrintStreamDemo 
{
  public static void main(String[] args ) throws Exception {
    FileOutputStream fos = new FileOutputStream("C:\\MyJava\\Student1.txt");
    PrintStream ps = new PrintStream(fos);

    Student s = new Student();
    s.rollno = 10; 
    s.name = "John";
    s.dept = "CSE";

    ps.println(s.rollno);
    ps.println(s.name); 
    ps.println(s.dept); 

    ps.close(); 
    fos.close();
  }
}
```

Windows Command prompt
> type Student1.txt
---

## **3ï¸âƒ£ Reading the Object from a File**

**Steps:**

1. Create a `FileInputStream`:

```java
FileInputStream fis = new FileInputStream("MyJava\\Student1.txt");
```

2. Wrap it with `InputStreamReader` and `BufferedReader`:
Upon InputStream, we can't assign a BufferedReader. We need converter/bridge InputStreamReader. 

```java
BufferedReader br = new BufferedReader(new InputStreamReader(fis));
```

3. Create an empty `Student` object and read values from the file:

```java
Student s = new Student();
s.roll = Integer.parseInt(br.readLine()); // convert string to int
s.name = br.readLine();                         // string
s.dept = br.readLine();                   // string
```

4. Print the values:

```java
System.out.println(s.roll);
System.out.println(s.name);
System.out.println(s.dept);
```


[PrintStreamDemo.java]
```java 
import java.io.*; 

class Student {
  int rollno; 
  String name; 
  String dept;
}

public class PrintStreamDemo 
{
  public static void main(String[] args ) throws Exception {
    FileInputStream fis = new FileInputStream("MyJava\\Student1.txt");

    BufferedReader br = new BufferedReader(new InputStreamReader(fis));

    Student s = new Student();
    s.roll = Integer.parseInt(br.readLine());
    s.name = br.readLine();
    s.dept = br.readLine(); 
    
    System.out.println(s.roll);
    System.out.println(s.name);
    System.out.println(s.dept);

    ps.close(); 
    fos.close();
  }
}
```

âœ… **Output on screen:**

```
10
John
CSE
```

---

## **4ï¸âƒ£ Key Points from the Demonstration**

* **PrintStream** can print various data types (int, String, boolean, etc.) using overloaded `println()` methods.
* `System.out` is actually a `PrintStream` object.
* **BufferedReader** reads everything as a **string**, so you need to parse integers or floats manually.
* This method works, but **data types are lost in storage**, which is a limitation.
* **Serialization** (covered later) solves this problem by storing objects in their original form, preserving types.

---

# **ðŸ“˜Serialisation using DataInput and DataOutput Streams**

## **1ï¸âƒ£ Problem Recap**

* Goal: Store a **`Student` object** in a file.
* **First solution:** Used `PrintStream` â†’ stored everything as **strings**, even integers.
* **Problem with first solution:** Data types are lost. Integers, floats, etc., are converted to strings, requiring parsing when reading.

---

## **2ï¸âƒ£ Second Solution: Using Data Streams**

Instead of storing everything as strings, we store **each property in its own data type**:

* **Integer:** stored as integer
* **String:** stored as string
* **Float/Double:** stored as float/double

This uses **`DataOutputStream`** and **`DataInputStream`**.

---

### **2.1 Writing the Object**

```java
class MyWrite{
  public static void main(String[] args) throws Exception {
    // Open file for writing
    FileOutputStream fos = new FileOutputStream("MyJava\\My.txt");

    // Attach DataOutputStream
    DataOutputStream dos = new DataOutputStream(fos);

    // Create Student object
    Student s = new Student();
    s.roll = 10;
    s.name = "John";
    s.dept = "CSE";

    // Write properties in their own types
    dos.writeInt(s.roll);  // integer
    dos.writeUTF(s.name);  // string
    dos.writeUTF(s.dept);  // string

    // Close streams (good practice)
    dos.close();
    fos.close();
  }
}

```

**Notes:**

* `writeInt()` writes an integer in binary format.
* `writeUTF()` writes a string in UTF format (Unicode).
* The file may **not be human-readable** because data is stored in binary format.

---

### **2.2 Reading the Object**

```java
class MyRead {
  public static void main(String[] args ) throws Exception {
    // Open file for reading
    FileInputStream fis = new FileInputStream("MyJava\\My.txt");

    // Attach DataInputStream
    DataInputStream dis = new DataInputStream(fis);

    // Create empty Student object
    Student s = new Student();

    // Read properties in same order and type
    s.roll = dis.readInt();
    s.name = dis.readUTF();
    s.dept = dis.readUTF();

    // Display
    System.out.println(s.roll);
    System.out.println(s.name);
    System.out.println(s.dept);

    // Close streams
    dis.close();
    fis.close();
  }
}

```

**Important:**

* Must **read in the same order** as written: integer first, then strings.
* Otherwise, data will be corrupted or throw an exception.

---

## **3ï¸âƒ£ Key Advantage Over First Solution**

* Each property retains **its original data type**.
* No need for parsing or type conversion when reading.
* Data is stored in a **binary format**, not plain text.

---

## **4ï¸âƒ£ Remaining Problem**

* Even with `DataOutputStream`, we are still writing **each property individually**.
* Problem: If the `Student` class has many properties, writing and reading them manually becomes tedious.
* **Desired solution:** Store the **entire object** at once and retrieve it â€” without accessing internal members individually.

---

## **5ï¸âƒ£ Next Step**

* **Serialization** solves this problem.
* Using serialization, you can save a **complete object** and read it back as the same object, preserving data types and structure.

---

# **ðŸ“˜Data Streams : DataInputStream & DataOutputStream DEMO**
---

## **1ï¸âƒ£ Overview**

* Goal: Store and retrieve a `Student` object in its **own data types** rather than converting everything to strings.
* Streams used:

  * **DataOutputStream** â†’ for writing data
  * **DataInputStream** â†’ for reading data

---

## **2ï¸âƒ£ Writing Data with DataOutputStream**

1. **Create `FileOutputStream`** â†’ connects to a file.

```java
FileOutputStream fos = new FileOutputStream("MyJava\\Student2.txt");
```

2. **Create `DataOutputStream`** â†’ attach to `FileOutputStream`.

```java
DataOutputStream dos = new DataOutputStream(fos);
```

3. **Create Student object** and initialize properties:

```java
Student s = new Student();
s.roll = 10;
s.name = "John";
s.dept = "CSE";
s.average = 80.5f; // float property
```

4. **Write properties in their own data types:**

```java
dos.writeInt(s.rollNumber);    // integer
dos.writeUTF(s.name);          // string
dos.writeFloat(s.average);     // float
dos.writeUTF(s.department);    // string
```

5. **Close streams:**

```java
dos.close();
fos.close();
```

**Key Points:**

* Each data type has its own write method: `writeInt`, `writeFloat`, `writeDouble`, `writeUTF`, etc.
* Data is stored in **binary format** â†’ not human-readable. Hence if you open [Student2.txt], it has weird symbold
* Text files are readable because data is converted to strings; binary files are stored in raw bytes.

---

## **3ï¸âƒ£ Reading Data with DataInputStream**

1. **Create `FileInputStream`** â†’ connects to the same file:

```java
FileInputStream fis = new FileInputStream("MyJava\\Student2.txt");
```

2. **Create `DataInputStream`** â†’ attach to `FileInputStream`:

```java
DataInputStream dis = new DataInputStream(fis);
```

3. **Create empty Student object**:

```java
Student s = new Student();
```

4. **Read data in the same order and type as written**:

```java
s.roll = dis.readInt();
s.name = dis.readUTF();
s.average = dis.readFloat();
s.dept = dis.readUTF();
```

5. **Print the values**:

```java
System.out.println(s.rollNumber);
System.out.println(s.name);
System.out.println(s.average);
System.out.println(s.department);
```

6. **Close streams:**

```java
dis.close();
fis.close();
```

---

## **4ï¸âƒ£ Important Notes**

* **Order matters:** You **must read in the same order** as written; otherwise:
  * You may get **junk values**
  * Or an **exception** like `EOFException`.

* **Binary vs Text Files:**
  * Text file â†’ human-readable, stored as strings.
  * Binary file â†’ stored in raw bytes, may not be readable in a text editor.
* DataInputStream and DataOutputStream **must be paired**: the same type that writes the data must read it.

---

## **5ï¸âƒ£ Next Step**

* Even with Data Streams, we are still **writing each property individually**.
* What if we want to **save and retrieve the entire object at once**?
* Thatâ€™s where **Serialization** comes in â†’ allows storing the **whole object**.

---


# **ðŸ“˜Serialisation Final**
---

## **1ï¸âƒ£ What is Serialization?**

* **Serialization** is the process of **storing the state of an object** so it can be retrieved later.
* **Deserialization** is the process of **reading that object back** into memory.
* Key idea: You donâ€™t have to store or retrieve individual properties manually. The entire object, with all its data, is saved and restored automatically.

---

## **2ï¸âƒ£ How to Serialize an Object**

1. **Create a `Student` class** (or any class you want to serialize):

To make a class serializable using `ObjectOutputStream` and deserialize using `ObjectInputStream`, the class must implement **Serializable**

```java
import java.io.Serializable;

class Student implements Serializable {
  int roll;
  String name;
  String dept;

  // default constructor is mandatory
  public Student() {}
}
```

**Important:**

* Must **implement `Serializable`** (a marker interface; it has no methods).
* Must have a **default (non-parameterized) constructor**.

2. **Write the object to a file using `ObjectOutputStream`:**

```java
class MyWrite 
{
  public static void main(String[] args) throws Exception {
    FileOutputStream fos = new FileOutputStream("student.ser");
    ObjectOutputStream oos = new ObjectOutputStream(fos);

    Student s = new Student();
    s.roll = 10;
    s.name = "John";
    s.dept = "CSE";

    oos.writeObject(s);  // writes the entire object at once
    oos.close();
    fos.close();
  }
}
```

* `writeObject()` handles the **entire object**; no need to write each property manually.

---

## **3ï¸âƒ£ How to Deserialize an Object**

```java
class MyRead
{
  public static void main(String[] args) throws Exception {
    FileInputStream fis = new FileInputStream("student.ser");
    ObjectInputStream ois = new ObjectInputStream(fis);

    Student s = (Student) ois.readObject();  // must type cast
    ois.close();
    fis.close();

    System.out.println(s.roll);
    System.out.println(s.name);
    System.out.println(s.dept);
  }
}
```

* The object is **fully restored** with the same values as when it was written.

---

## **4ï¸âƒ£ Important Rules for Serialization**

1. **Implement `Serializable`**:

   * Marker interface â†’ no methods to override.
   * Tells JVM that this class can be serialized.

2. **Default Constructor Required**:

   * Must have a non-parameterized constructor.
   * Reading (deserialization) fails without it.

3. **Static and Transient Members**:

   * **Static members** â†’ belong to the class, not object â†’ **not serialized**
   * **Transient members** â†’ explicitly marked not to serialize â†’ **not saved**

---

## **5ï¸âƒ£ Benefits of Serialization**

* **Save and retrieve entire objects** easily.
* **No need to manage individual properties** like in DataOutputStream.
* Useful for:

  * Saving object state to files
  * Sending objects over a network
  * Caching objects

---

## **6ï¸âƒ£ File Format**

* Serialized objects are stored in **binary format**, not human-readable.
* File extension can be `.ser` (convention), but any extension works.

---

# **ðŸ“˜Object Streams & Serialisation DEMO**

---

## **1ï¸âƒ£ What is Serialization?**

* **Serialization** is the process of **converting an object into a byte stream** so that it can be **stored in a file, sent over a network, or saved for later use**.
* **Deserialization** is the process of **converting the byte stream back into an object** with the same state as when it was serialized.
* Key advantage: You donâ€™t need to manually write/read each property; the **entire object** is handled automatically.

---

## **2ï¸âƒ£ The Student Class for Serialization**

```java
import java.io.Serializable;

class Student implements Serializable {
  private int rollNumber;
  private String name;
  private float average;
  private String department;

  public static int staticValue = 10;       // Not serialized
  public transient int t;              // Not serialized

  // Default constructor (good practice)
  public Student() {}

  // Parameterized constructor
  public Student(int rollNumber, String name, float average, String department) {
    this.rollNumber = rollNumber;
    this.name = name;
    this.average = average;
    this.department = department;
    staticValue = 500;
    t = 500; // These will not be serialized
  }

  @Override
  public String toString() {
      return "Roll: " + rollNumber + ", Name: " + name +
              ", Average: " + average + ", Dept: " + department +
              ", Static: " + staticValue + ", Transient: " + t;
  }
}
```

**Notes:**

1. **`implements Serializable`** â†’ required for object serialization. Itâ€™s a marker interface; no methods to override.
2. **Transient & Static members** â†’ not serialized.
3. **Default constructor** â†’ good practice, especially for inheritance.

---

## **3ï¸âƒ£ Serializing an Object**

```java
import java.io.*;

public class SerializeDemo {
  public static void main(String[] args) throws Exception {
    FileOutputStream fos = new FileOutputStream("Student3.txt");
    ObjectOutputStream oos = new ObjectOutputStream(fos);

    Student s = new Student(10, "John", 80.5f, "CSE");

    oos.writeObject(s);  // Serialize the object
    oos.close();
    fos.close();

    System.out.println("Object Serialized Successfully!");
  }
}
```

* **`writeObject()`** handles the entire object.
* The file `Student3.txt` becomes **binary**; humans cannot read it properly.

---

## **4ï¸âƒ£ Deserializing an Object**

```java
import java.io.*;

public class DeserializeDemo {
  public static void main(String[] args) throws Exception {
    FileInputStream fis = new FileInputStream("Student3.txt");
    ObjectInputStream ois = new ObjectInputStream(fis);

    Student s = (Student) ois.readObject(); // Typecast is mandatory

    System.out.println("Deserialized Object:");
    System.out.println(s);

    ois.close();
    fis.close();    
  }
}
```

* Only `ObjectInputStream` can read the serialized object.
* **Order or structure mismatch** will cause exceptions (`InvalidClassException`).

---

## **5ï¸âƒ£ Important Points**

1. **Transient & Static Members:**

   * Not serialized.
   * Example: `t` (transient) and `staticValue` â†’ values are not saved in file. It's value is what we set globally NOT in constructor. 

2. **Class Versioning (serialVersionUID):**

   * If the class structure changes after serialization (e.g., constructor removed), deserialization fails.
   * Java assigns a **serialVersionUID** to each class to track versions.
   * Best practice: explicitly declare a `serialVersionUID` to maintain compatibility.

```java
private static final long serialVersionUID = 1L;
```

3. **Binary Nature:**

   * Serialized files are binary; human-readable editing is not possible.
   * Always use `ObjectInputStream` to retrieve objects.

4. **Parameterized Constructor:**

   * Used to initialize object before serialization.
   * During deserialization, the **parameterized constructor is NOT called**; object is reconstructed from byte stream.

---

## **6ï¸âƒ£ Key Takeaways**

* **Serialization**: Save entire object state automatically.
* **Deserialization**: Restore entire object state.
* **Requirements**:

  1. `implements Serializable`
  2. Default constructor (good practice)
  3. Be aware of transient/static members.
* **Versioning matters**: Class structure must match between serialization and deserialization.

---

# **ðŸ“˜Student Challenge  Serialize a Customer**
---

## **1ï¸âƒ£ Task 1: Store and Retrieve Float Numbers**

### **Problem**

* You have an array of float numbers, e.g., `[10.5f, 2.9f, 6.4f, 3.7f]`.
* You need to **store them in a file** and later **read them back**.

### **Key Considerations**

1. Use `FileOutputStream` + `DataOutputStream` for writing floats.
2. Use `FileInputStream` + `DataInputStream` for reading floats.
3. For byte types Java returns `-1` to denote EOF. But Java does not have an end-of-file marker for non-byte types, so you need to **store the number of floats first** i.e. the first write should be number of floats you want to store in file. 

### **Code Example**

```java
import java.io.*;

public class FloatStorageDemo {
  public static void main(String[] args) throws IOException {
    float[] list = {10.5f, 2.9f, 6.4f, 3.7f};

    // Writing floats to file
    FileOutputStream fos = new FileOutputStream("Data.txt");
    DataOutputStream dos = new DataOutputStream(fos);

    dos.writeInt(list.length);           // Write number of floats
    for (float f : list) {
        dos.writeFloat(f);               // Write each float
    }
    dos.close();
    fos.close();

    // Reading floats from file
    FileInputStream fis = new FileInputStream("Data.txt");
    DataInputStream dis = new DataInputStream(fis);

    int length = dis.readInt();          // Read number of floats
    for (int i = 0; i < length; i++) {
        float f = dis.readFloat();
        System.out.println(f);           // Display float
    }
    dis.close();
    fis.close();
  }
}
```

**Output:**

```
10.5
2.9
6.4
3.7
```

**Notes:**

* The file is **binary**, so you cannot read it as plain text.
* Always close the **wrapper stream** (`DataOutputStream`) before the underlying stream (`FileOutputStream`).

---

## **2ï¸âƒ£ Task 2: Serialize and Retrieve Customer Objects**

### **Problem**

* Define a `Customer` class with:

  * `customerID` (auto-generated: C1, C2, â€¦)
  * `name`
  * `phoneNumber`
* Serialize multiple `Customer` objects into a file (`customer.txt`) and retrieve them.
* You can optionally **search for a customer by name**.

### **Customer Class**

```java
import java.io.Serializable;

class Customer implements Serializable {
  private static final long serialVersionUID = 1L;
  
  private static int count = 0;       // For auto ID generation
  private String customerID;
  private String name;
  private String phoneNumber;

  // Non-parameterized constructor
  public Customer() {}

  // Parameterized constructor
  public Customer(String name, String phoneNumber) {
    count++;
    this.customerID = "C" + count;  // Auto-generate ID
    this.name = name;
    this.phoneNumber = phoneNumber;
  }

  @Override
  public String toString() {
    return "CustomerID: " + customerID + ", Name: " + name + ", Phone: " + phoneNumber;
  }
}
```

---

### **Serializing Customers to File**

```java
import java.io.*;

public class SerializeCustomer {
  public static void main(String[] args) throws IOException {
    Customer[] customers = {
      new Customer("Smith", "9876543210"),
      new Customer("John", "9876501234"),
      new Customer("Ajay", "9876512345")
    };

    FileOutputStream fos = new FileOutputStream("customer.txt");
    ObjectOutputStream oos = new ObjectOutputStream(fos);

    oos.writeInt(customers.length);    // Write number of objects
    for (Customer c : customers) {
        oos.writeObject(c);            // Serialize each object
    }

    oos.close();
    fos.close();
    System.out.println("Customers serialized successfully.");
  }
}
```

---

### **Deserializing Customers from File and Searching**

```java
import java.io.*;
import java.util.Scanner;

public class DeserializeCustomer {
  public static void main(String[] args) throws IOException, ClassNotFoundException {
    FileInputStream fis = new FileInputStream("customer.txt");
    ObjectInputStream ois = new ObjectInputStream(fis);

    int length = ois.readInt();               // Read number of objects
    Customer[] customers = new Customer[length];

    for (int i = 0; i < length; i++) {
        customers[i] = (Customer) ois.readObject();
    }

    ois.close();
    fis.close();

    // Searching by name
    Scanner sc = new Scanner(System.in);
    System.out.print("Enter name to search: ");
    String searchName = sc.nextLine();

    for (Customer c : customers) {
      if (c.toString().contains(searchName)) {
        System.out.println(c);
      }
    }
    sc.close();
  }
}
```

**Notes:**

* Always **typecast** when using `readObject()`.
* The `customerID` is automatically generated.
* You can store the **number of objects first** for easier deserialization.
* Objects are stored in **binary format**, readable only via `ObjectInputStream`.

---

âœ… **Key Concepts Covered:**

1. `DataOutputStream` & `DataInputStream` for primitive types like floats.
2. `ObjectOutputStream` & `ObjectInputStream` for object serialization.
3. Auto-generated IDs using a static counter.
4. Storing the number of elements/objects in the file to know how many to read.
5. Transient/static members are **not serialized** (relevant for advanced object handling).

---
